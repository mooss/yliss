#+title: C++ OpenGL window
#+author: FÃ©lix Jamet

#+property: header-args :eval never :main no

* Prelude :noexport:

#+name: include
#+begin_src sh :var cpp="" noweb="" :results output :wrap "src cpp" :eval no-export
./litlib/include.pl "window.org" "$cpp" "$noweb"
#+end_src

* Window

The first step is to be able to display an empty window.
The main characteristics of a window are its width, height and title.
We will use glfw[fn::See https://www.glfw.org/.] to create a window, so we need to store a handle to the window and monitor used.

#+name: window
#+begin_src cpp :noweb no-export
class window
{
  public:
    GLFWwindow* window_handle;
    GLFWmonitor* monitor_handle;

    const std::string& title() const {return title_;}
    unsigned int width() const {return width_;}
    unsigned int height() const {return height_;}

    <<public window>>

  private:
    std::string title_;
    unsigned int width_, height_;
};
#+end_src
#+depends:window :cpp glad/glad.h GLFW/glfw3.h stdexcept

** Titled constructor

#+begin_src cpp :noweb no-export :noweb-ref "public window"
window(std::string title, unsigned int width, unsigned int height):
    title_(title), width_(width), height_(height),
    window_handle(nullptr), monitor_handle(nullptr)
{
    glfwInit();
    <<Create window>>
    <<OpenGL setup>>
}
#+end_src

*** Create window

If =monitor_handle='s value is =nullptr=, this is not a problem because when =glfwCreateWindow= is called this way, it simply creates a window in windowed mode.

The last parameter of =glfwCreateWindow= is for context sharing, which we will not use.
 
#+name: Create window
#+begin_src cpp
window_handle = glfwCreateWindow(width_, height_, title.c_str(), monitor_handle, nullptr);
if(window_handle == nullptr){
    glfwTerminate();
    throw std::runtime_error("Failed to create glfw window");
}
#+end_src

*** OpenGL setup

The OpenGL context holds the state of the current OpenGL instance.
A process can make several OpenGL contexts.
The call to =glfwCreateWindow= in the section above spawned an OpenGL context[fn:: See https://www.glfw.org/docs/latest/context_guide.html].
Before doing any OpenGL work, the OpenGL context associated to the =window_handle= is made current via =glfwMakeContextCurrent=.

#+name: OpenGL setup
#+begin_src cpp
glfwMakeContextCurrent(window_handle);
if(!gladLoadGLLoader((GLADloadproc) glfwGetProcAddress)){
    glfwDestroyWindow(window_handle);
    glfwTerminate();
    throw std::runtime_error("Failed to create OpenGL context with glad");
}

int fb_width, fb_height;
glfwGetFramebufferSize(window_handle, &fb_width, &fb_height);
glViewport(0, 0, fb_width, fb_height);
#+end_src

** Destructor

We only have to tell glfw to liberate the resources it has allocated.
#+begin_src cpp :noweb-ref "public window"
~window()
{
    glfwDestroyWindow(window_handle);
    glfwTerminate();
}
#+end_src

** Empty window test

#+begin_src cpp :noweb no-export :eval yes :flags -I include -ldl -lGL -lglfw src/glad.c
<<include(noweb="window")>>

void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods){
    if(key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
        glfwSetWindowShouldClose(window, GLFW_TRUE);
}

int main(){
    window empty_window("Empty window", 640u, 480u);
    glfwSetKeyCallback(empty_window.window_handle, key_callback);
    glClearColor(0.4, 0.007843137, 0.235294118, 0); // Tyrian purple.
    while(!glfwWindowShouldClose(empty_window.window_handle)){
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glfwPollEvents();
        glfwSwapBuffers(empty_window.window_handle);
    }
    return 0;
}
#+end_src

#+RESULTS:
:results:
:end:

** Not implemented

This section contains some notes about features that could be needed at some point but that I didn't bother to implement yet.

*** Resizing

To support resizing on the fly a callback must be set with =glfwSetFramebufferSizeCallback=.
To start, see the =Viewport= section of =https://learnopengl.com/Getting-started/Hello-Window=.

* Lazy window

The goal of this section is to provide some boilerplate that can help with experimentation but does not necessarily have its place inside a proper window class.
Here, it allows us to make a window with a default white background, that simply closes when pressing escape and that has an handy =game_loop= that can be given a lambda to start drawing with opengl.

#+name: lazy_window
#+begin_src cpp
void escape_close(GLFWwindow* window, int key, int scancode, int action, int mods){
    if(key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
        glfwSetWindowShouldClose(window, GLFW_TRUE);
}

struct lazy_window: public window {
    lazy_window(std::string title, unsigned int width, unsigned int height):
        window(title, width, height)
    {
        glfwSetKeyCallback(this->window_handle, escape_close);
        glClearColor(1, 1, 1, 0);
    }

    template<typename F>
    void game_loop(F rendering) {
        while(!glfwWindowShouldClose(this->window_handle)){
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
            rendering();
            glfwSwapBuffers(this->window_handle);
            glfwPollEvents();
        }
    }
};
#+end_src

#+depends:lazy_window :noweb window

The following draws absolutely nothing, but it does it handily:
#+begin_src cpp :noweb no-export :eval yes :flags -I include -ldl -lGL -lglfw src/glad.c
<<include(noweb="lazy_window")>>

int main(){
    lazy_window lazy("sloth", 640u, 480u);
    lazy.game_loop([](){});
    return 0;
}
#+end_src

#+RESULTS:
:results:
:end:

