#+title: C++ OpenGL window
#+author: FÃ©lix Jamet

#+property: header-args :eval never :main no

* Prelude :noexport:

#+name: include
#+begin_src sh :var args="" :results output :wrap "src cpp" :eval no-export
./litlib/include.pl "window.org" "$args"
#+end_src


* Window

The first step is to be able to display an empty window.
The main characteristics of a window are its width, height and title.
We will use glfw[fn::See https://www.glfw.org/.] to create a window, so we need to store a handle to the window and monitor used.

#+name: window
#+begin_src cpp :noweb no-export
class window
{
  public:
    GLFWwindow* window_handle;
    GLFWmonitor* monitor_handle;

    const std::string& title() const {return title_;}
    std::size_t width() const {return width_;}
    std::size_t height() const {return height_;}

    <<window/public>>

  private:
    std::string title_;
    std::size_t width_, height_;
};
#+end_src
#+depends:window :cpp glad/glad.h GLFW/glfw3.h stdexcept


** Titled constructor

#+begin_src cpp :noweb no-export :noweb-ref window/public
window(const std::string& title, unsigned int width, unsigned int height):
    title_(title), width_(width), height_(height),
    window_handle(nullptr), monitor_handle(nullptr)
{
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    <<window/Titled constructor>>
}
#+end_src

*** Create window

If =monitor_handle='s value is =nullptr=, this is not a problem because when =glfwCreateWindow= is called this way, it simply creates a window in windowed mode.

The last parameter of =glfwCreateWindow= is for context sharing, which we will not use.
 
#+begin_src cpp :noweb-ref "window/Titled constructor"
window_handle = glfwCreateWindow(width_, height_, title.c_str(), monitor_handle, nullptr);
if(window_handle == nullptr){
    glfwTerminate();
    throw std::runtime_error("Failed to create glfw window");
}
#+end_src

*** OpenGL setup

The OpenGL context holds the state of the current OpenGL instance.
A process can make several OpenGL contexts.
The call to =glfwCreateWindow= in the section above spawned an OpenGL context[fn:: See https://www.glfw.org/docs/latest/context_guide.html].
Before doing any OpenGL work, the OpenGL context associated to the =window_handle= is made current via =glfwMakeContextCurrent=.

#+begin_src cpp :noweb-ref "window/Titled constructor"
glfwMakeContextCurrent(window_handle);
if(!gladLoadGLLoader((GLADloadproc) glfwGetProcAddress)){
    glfwDestroyWindow(window_handle);
    glfwTerminate();
    throw std::runtime_error("Failed to create OpenGL context with glad");
}

int fb_width, fb_height;
glfwGetFramebufferSize(window_handle, &fb_width, &fb_height);
glViewport(0, 0, fb_width, fb_height);
#+end_src

*** Automatic resizing

The OpenGL viewport must be adjusted to fit the window when the user resizes the window.
This requires to register a callback, and below is the method that will technically handle this callback:

#+begin_src cpp :noweb-ref window/public
void resize_viewport(GLFWwindow* window, int width, int height) {
    glViewport(0, 0, width, height);
    width_ = width;
    height_ = height;
}
#+end_src

Note that this method triggers a modification of the =width_= and =height_= attributes of =window=, hence why it is a method and not a free function.
Sadly, a method pointer cannot be trivially transformed into a function pointer, which is why =glfwSetWindowUserPointer= and =glfwGetWindowUserPointer= must be used to transmit the =this= pointer to a captureless lambda delegating the work to the =resize_viewport=.

This technique was explained here: https://stackoverflow.com/a/28660673.

#+begin_src cpp :noweb-ref "window/Titled constructor"
glfwSetWindowUserPointer(window_handle, this);
auto callback = [](GLFWwindow* handle, int width, int height) {
    static_cast<window*>(glfwGetWindowUserPointer(handle))->resize_viewport(handle, width, height);
};
glfwSetFramebufferSizeCallback(window_handle, callback);
#+end_src


** Destructor

We only have to tell glfw to liberate the resources it has allocated.
#+begin_src cpp :noweb-ref "window/public"
~window()
{
    glfwDestroyWindow(window_handle);
    glfwTerminate();
}
#+end_src


** Empty window test

#+begin_src cpp :noweb no-export :eval yes :flags -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb window")>>

void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods){
    if(key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
        glfwSetWindowShouldClose(window, GLFW_TRUE);
}

int main(){
    window empty_window("Empty window", 640u, 480u);
    glfwSetKeyCallback(empty_window.window_handle, key_callback);
    glClearColor(0.4, 0.007843137, 0.235294118, 0); // Tyrian purple.
    while(!glfwWindowShouldClose(empty_window.window_handle)){
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glfwPollEvents();
        glfwSwapBuffers(empty_window.window_handle);
    }
    return 0;
}
#+end_src

#+RESULTS:
:results:
:end:


* Lazy window

The goal of this section is to provide some boilerplate that can help with experimentation but does not necessarily have its place inside a proper window class.
Here, it allows us to make a window with a default white background, that simply closes when pressing escape and that has an handy =game_loop= that can be given a lambda to start drawing with opengl.

#+name: lazy_window
#+begin_src cpp
void escape_close(GLFWwindow* window, int key, int scancode, int action, int mods){
    if(key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
        glfwSetWindowShouldClose(window, GLFW_TRUE);
}

struct lazy_window: public window {
    lazy_window(const std::string& title, unsigned int width, unsigned int height):
        window(title, width, height)
    {
        glfwSetKeyCallback(this->window_handle, escape_close);
        glClearColor(1.0f, 1.0f, 1.0f, 0.0f);
    }

    <<lazy_window/public>>;
};
#+end_src
#+depends:lazy_window :noweb window

Packaged within =lazy_window= are the following rendering functions.
#+begin_src cpp :noweb-ref lazy_window/public
template<typename F>
void render_one(F rendering) const { // Great for OpenGL calls debugging via LOG_AND_CALL.
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    rendering();
    glfwSwapBuffers(this->window_handle);
    glfwPollEvents();
}

template<typename F>
void render_n(std::size_t n, F rendering) const { // Useful to observe quickly the result of some asjustment.
    for(std::size_t i = 0; i < n; ++i) {
        render_one(rendering);
    }
}

template<typename F>
void game_loop(F rendering) const { // Closes automatically when escape is pressed.
    while(!glfwWindowShouldClose(this->window_handle)){
        render_one(rendering);
    }
}
#+end_src


** Usage

The following draws absolutely nothing, but it does it handily:
#+begin_src cpp :noweb no-export :eval yes :flags -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb lazy_window")>>

int main(){
    lazy_window lazy("Sloth", 640u, 480u);
    lazy.game_loop([]{});
    return 0;
}
#+end_src

#+RESULTS:
:results:
:end:


* Screenshots

I thought that being able to take screenshots of the OpenGL scene being rendered would be very difficult while keeping external dependencies small, but thankfully stb (https://github.com/nothings/stb) has a header ready for this.
I'm amazed by this thing.

Some preprocessing is needed to first extract the pixels into a buffer but my work was cut out for me thanks to this post on the subject: https://lencerf.github.io/post/2019-09-21-save-the-opengl-rendering-to-image-file/.
I adapted it to the =window= class to make the following function:

#+name: save_screenshot
#+begin_src cpp
void save_screenshot(const window& source, const std::string& destination) {
    GLsizei channels = 3;
    GLsizei stride = channels * source.width();
    stride += (stride % 4) ? (4 - stride % 4): 0; // Make stride a multiple of 4 (for alignment).
    GLsizei buffer_size = stride * source.height();
    std::vector<char> buffer(buffer_size);

    glPixelStorei(GL_PACK_ALIGNMENT, 4);
    glReadBuffer(GL_FRONT);
    glReadPixels(0, 0, source.width(), source.height(), GL_RGB, GL_UNSIGNED_BYTE, buffer.data());

    stbi_flip_vertically_on_write(true);
    stbi_write_png(
        destination.c_str(), source.width(), source.height(),
        channels, buffer.data(), stride
    );
}
#+end_src
#+depends:save_screenshot :noweb window stb_image_write :cpp string vector glad/glad.h

Concerning the =stb_image_write= dependency, I had to make it a noweb dependency rather than a C++ dependency because this was the only way to =#define= the mandatory =STB_IMAGE_WRITE_IMPLEMENTATION= before the inclusion.
#+name: stb_image_write
#+begin_src cpp
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include <stb_image_write.h>
#+end_src

The following helper makes it a little less cumbersome to capture and save the first frame rendered:
#+name: game_loop_screen_first
#+begin_src cpp
template<typename Callable>
void game_loop_screen_first(
    const lazy_window& source, const std::string& destination, Callable render
) {
    source.render_one(render);
    save_screenshot(source, destination);
    source.game_loop(render);
}
#+end_src
#+depends:game_loop_screen_first :noweb save_screenshot lazy_window
