#+title: C++ OpenGL window
#+author: FÃ©lix Jamet

#+property: header-args :eval never :main no

* Prelude :noexport:

#+name: include
#+begin_src sh :var cpp="" noweb="" :results output :wrap "src cpp" :eval no-export
./litlib/include.pl "window.org" "$cpp" "$noweb"
#+end_src

* Window

The first step is to be able to display an empty window.
The main characteristics of a window are its width, height and title.
We will use glfw[fn::See https://www.glfw.org/.] to create a window, so we need to store a handle to the window and monitor used.

#+name: window
#+begin_src cpp :noweb no-export
class window
{
  public:
    GLFWwindow* window_handle;
    GLFWmonitor* monitor_handle;

    <<Titled constructor>>
    <<Destructor>>

    const std::string& title() const {return title_;}
    unsigned int width() const {return width_;}
    unsigned int height() const {return height_;}

  private:
    std::string title_;
    unsigned int width_, height_;
};
#+end_src
#+depends:window :cpp glad/glad.h GLFW/glfw3.h stdexcept

** Titled constructor

#+name: Titled constructor
#+begin_src C++ :noweb no-export
window(std::string title, unsigned int width, unsigned int height):
    title_(title), width_(width), height_(height),
    window_handle(nullptr), monitor_handle(nullptr)
{
    glfwInit();
    <<Create window>>
    <<OpenGL setup>>
}
#+end_src

*** Create window

If =monitor_handle='s value is =nullptr=, this is not a problem because when =glfwCreateWindow= is called this way, it simply creates a window in windowed mode.

The last parameter of =glfwCreateWindow= is for context sharing, which we will not use.
 
#+name: Create window
#+begin_src C++
window_handle = glfwCreateWindow(width_, height_, title.c_str(), monitor_handle, nullptr);
if(window_handle == nullptr){
    glfwTerminate();
    throw std::runtime_error("Failed to create glfw window");
}
#+end_src

*** OpenGL setup

The OpenGL context holds the state of the current OpenGL instance.
A process can make several OpenGL contexts.
The call to =glfwCreateWindow= in the section above spawned an OpenGL context[fn:: See https://www.glfw.org/docs/latest/context_guide.html].
Before doing any OpenGL work, the OpenGL context associated to the =window_handle= is made current via =glfwMakeContextCurrent=.

#+name: OpenGL setup
#+begin_src C++
glfwMakeContextCurrent(window_handle);
if(!gladLoadGLLoader((GLADloadproc) glfwGetProcAddress)){
    glfwDestroyWindow(window_handle);
    glfwTerminate();
    throw std::runtime_error("Failed to create OpenGL context with glad");
}

int fb_width, fb_height;
glfwGetFramebufferSize(window_handle, &fb_width, &fb_height);
glViewport(0, 0, fb_width, fb_height);
#+end_src

** Destructor

We only have to tell glfw to liberate the resources it has allocated.
#+name: Destructor
#+begin_src C++
~window()
{
    glfwDestroyWindow(window_handle);
    glfwTerminate();
}
#+end_src

** Empty window test

#+begin_src cpp :noweb no-export :eval yes :flags -I include -ldl -lGL -lglfw src/glad.c
<<include(noweb="window")>>

void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods){
    if(key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
        glfwSetWindowShouldClose(window, GLFW_TRUE);
}

int main(){
    window empty_window("Empty window", 640u, 480u);
    glfwSetKeyCallback(empty_window.window_handle, key_callback);
    glClearColor(0.4, 0.007843137, 0.235294118, 0); //tyrian purple
    while(!glfwWindowShouldClose(empty_window.window_handle)){
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glfwPollEvents();
        glfwSwapBuffers(empty_window.window_handle);
    }
    return 0;
}
#+end_src

#+RESULTS:
:results:
:end:

** Not implemented

This section contains some notes about features that could be needed at some point but that I didn't bother to implement yet.

*** Resizing

To support resizing on the fly a callback must be set with =glfwSetFramebufferSizeCallback=.
To start, see the =Viewport= section of =https://learnopengl.com/Getting-started/Hello-Window=.
