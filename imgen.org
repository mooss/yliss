#+title: Image generation tools

#+property: header-args:cpp :flags -std=c++20 -I include -lGL -lOSMesa src/glad.c :eval never :main no :exports both :noweb no-export
#+property: header-args:bash :noweb no-export :prologue "exec 2>&1" :epilogue "true"

* Prelude

** Inclusion

The following script uses LitLib's =include.pl= to fetch code blocks defined in =Yliss= and =LitLib=, along with their dependencies.
Most of the work to generate images is defined in in those other documents, the current document merely assembles a few primitives.

#+name: include
#+begin_src sh :var args="" :results output :wrap src cpp :eval no-export
./litlib/include.pl 'window.org litlib/cpp.org graphics.org imgen.org' "$args"
#+end_src


* Image specification (=imgspec=)

Gathers all the information needed to generate an image, with reasonable defaults for the vertex and fragment shaders.

#+name: imgspec
#+begin_src cpp
struct imgspec {
    const char *vs =
        "#version 330 core\n"
        "layout (location = 0) in vec2 position;\n"
        "layout (location = 1) in vec3 color_in;\n"
        "out vec3 color_fs;\n"
        "\n"
        "uniform mat4 model;\n"
        "uniform mat4 view;\n"
        "uniform mat4 projection;\n"
        "\n"
        "void main() {\n"
        "    gl_Position = projection * view * model * vec4(position, 0.0f, 1.0f);\n"
        "    color_fs = color_in;\n"
        "}\n";
    const char *fs =
        "#version 330 core\n"
        "out vec4 color_out;\n"
        "in vec3 color_fs;\n"
        "\n"
        "void main() {\n"
        "    color_out = vec4(color_fs, 1.);\n"
        "}\n";
    const std::vector<float>& vtx;
    const std::vector<unsigned int>& layout;
    const std::vector<unsigned int>& idx;
    orthographic_projection proj{.left = 0, .right = 1, .bottom = 0, .top = 1};
    mandatory<unsigned int> width;
    mandatory<unsigned int> height;

    <<imgspec/public>>
};
#+end_src
#+depends:imgspec :noweb mandatory moviort gl_context shader_program VAO vertices indexes transform gl_screen_one image/format/deduce :cpp vector string_view

The =gen= method can generate an image under the given path by creating an OpenGL context and rendering one frame using the information contained in the =imgspec=.

#+begin_src cpp :eval no-export :exports both :noweb-ref imgspec/public
void gen(std::string_view destination) {
    gl_context offscreen(*width, *height);
    glClearColor(.5f, .5f, .5f, 0.0f);
    shader_program shader{vertex_shader(vs), fragment_shader(fs)};
    VAO vao{};
    vertices<GLfloat> vtxobj(vtx, layout);
    indexes idxobj(idx);
    moviort viper(
        transform(),
        transform().translate({0, 0, -1}), // Move the view otherwise it would get clipped by the near value.
        proj,
        shader
    );

    auto render = [&]{
        shader.use();
        vao.bind();
        idxobj.draw();
    };
    using writer = image::format::deduce<90>::writer<identity>;
    gl_screen_one(offscreen, destination, writer(), render);
}
#+end_src

** Usage

#+begin_src cpp :eval no-export :exports both
<<include(":noweb imgspec")>>

int main() {
    imgspec{
        .vtx = { // Positions // Colors
                    1, 1,        1, 1, 0,  // Top right,    yellow.
                    0, 1,        1, 0, 1,  // Top left,     magenta.
                    1, 0,        0, 1, 1,  // Bottom right, cyan.
                    0, 0,        0, 0, 0}, // Bottom left,  black.
        .layout = { 2, 3 },
        .idx = { 0, 1, 2,
                 1, 2, 3 },
        .width = 64, .height = 64
    }.gen("images/imgen/usage.png");
    return 0;
}
#+end_src

#+RESULTS:
:results:
[[file:images/imgen/usage.png]]
:end:

** Command-line tool

The goal is to write a tool able to read this kind of image specification format:
#+begin_src txt :tangle tangle/usage.imgspec
1 1 1 1 0
0 1 1 0 1
1 0 0 1 1
0 0 0 0 0

2 3

0 1 2
1 2 3

64 64
#+end_src

This format is composed of 4 section separated by empty lines:
 1. The vertices.
 2. The layout.
 3. The indexes.
 4. The size of the generated image.

*** Implementation

#+name: imgen-cli
#+begin_src cpp
bool is_space(char c) {
    return c == ' ' || c == '\n';
}

sub next_spaces(const std::string_view s) {
    for(std::size_t begin = 0; begin < s.size(); ++begin) {
        if(is_space(s[begin])) {
            auto end = begin;
            while(++end < s.size() && is_space(s[end]));
            return sub{.pos=begin, .len=end-begin};
        }
    }
    return sub{};
}

bool not_spaces(const std::string_view str) {
    for(auto c: str)
        if(!is_space(c)) return true;
    return false;
}

sterr conv_error(const std::string message, const std::string_view str) {
    return sterr{message + std::string(str)};
}

// TODO: utility to add more context to maybe error messages.
maybe<float> to_float(const std::string_view str) {
    double res = std::atof(str.data()); // The fact that str might not be null-terminated is problematic.
    if(res == 0 && str != "0" && str != "0.0" && str != ".0") {
        return conv_error("failed to parse value as float: ", str);
    }
    return float(res);
}

maybe<unsigned int> to_uint(const std::string_view str) {
    long res = std::atol(str.data());
    if(res < 0) {
        return conv_error("expected an unsigned int: ", str);
    }
    if(res == 0 && str != "0") {
        return conv_error("failed to parse value as unsigned int: ", str);
    }
    return (unsigned int) res;
}

int main(int argc, char *argv[]) {
    if(argc != 3) {
        panic("expected 2 arguments, got " + std::to_string(argc-1));
    }
    auto spec = argv[1];
    auto dest = argv[2];

    auto cleansplit = [](const auto& range, auto splitter) {
        auto res = split(range, splitter);
        keepin(not_spaces, res);
        return res;
    };

    auto raw = slurp(spec); // TODO: ensure it exists.
    auto splitted = cleansplit(raw, "\n\n");

    if(splitted.size() != 4) {
        std::string err = "expected 4 sections to imgspec file but got ";
        panic(err + std::to_string(splitted.size()));
    }

    auto parse = [&](auto i, auto convert) {
        return mapassert(convert, cleansplit(splitted[i], next_spaces));
    };

    auto vertices = parse(0, to_float);
    auto layout = parse(1, to_uint);
    auto indexes = parse(2, to_uint);
    auto imsize = parse(3, to_uint);

    if(imsize.size() != 2) {
        panic(std::string("expected image size section to be 2 uint, got") + std::to_string(imsize.size()));
    }

    imgspec{
        .vtx = vertices,
        .layout = layout,
        .idx = indexes,
        .width = imsize[0],
        .height = imsize[1],
    }.gen(dest);

    return 0;
}
#+end_src
#+depends:imgen-cli :noweb slurp split/sv keepin panic maybe mapassert imgspec :cpp string string_view cstdlib

*** Compilation

This compiles =imgen= into =./bin=:
#+begin_src bash :wrap src compilation
mkdir -p bin
tangled=tangle/imgen.cpp
./litlib/include.pl 'window.org litlib/cpp.org graphics.org imgen.org' ':noweb imgen-cli' > $tangled
g++ -Wall -std=c++20 -O2 -I include -lGL -lOSMesa src/glad.c $tangled -o bin/imgen
du -sh bin/imgen
wc -l $tangled
rm $tangled
#+end_src

#+RESULTS:
#+begin_src compilation
tangle/imgen.cpp: In constructor ‘gl_context::gl_context(int, int)’:
tangle/imgen.cpp:379:9: warning: ‘gl_context::height_’ will be initialized after [-Wreorder]
  379 |     int height_;
      |         ^~~~~~~
tangle/imgen.cpp:347:26: warning:   ‘std::vector<unsigned char> gl_context::buffer’ [-Wreorder]
  347 |     std::vector<GLubyte> buffer;
      |                          ^~~~~~
tangle/imgen.cpp:348:5: warning:   when initialized here [-Wreorder]
  348 |     gl_context(int width, int height):
      |     ^~~~~~~~~~
In file included from tangle/imgen.cpp:582:
include/stb/stb_image_write.h: In function ‘void stbiw__write1(stbi__write_context*, unsigned char)’:
include/stb/stb_image_write.h:400:24: warning: comparison of integer expressions of different signedness: ‘int’ and ‘long unsigned int’ [-Wsign-compare]
  400 |    if (s->buf_used + 1 > sizeof(s->buffer))
      |        ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~
include/stb/stb_image_write.h: In function ‘void stbiw__write3(stbi__write_context*, unsigned char, unsigned char, unsigned char)’:
include/stb/stb_image_write.h:408:24: warning: comparison of integer expressions of different signedness: ‘int’ and ‘long unsigned int’ [-Wsign-compare]
  408 |    if (s->buf_used + 3 > sizeof(s->buffer))
      |        ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~
200K	bin/imgen
835 tangle/imgen.cpp
#+end_src

*** Code block

#+name: imgen
#+begin_src bash :var spec="" dest=""
[[ -f "$spec" ]] || { echo "Specification file \`$spec\` does not exist."; exit; }
destdir=$(dirname "$dest")
[[ -d "$destdir" ]] || mkdir -p "$destdir"
./bin/imgen "$spec" "$dest"
#+end_src

#+call: imgen("tangle/usage.imgspec", "images/imgen/usage.png")

#+RESULTS:
:results:
[[file:images/imgen/usage.png]]
:end:
