#+title: C++ OpenGL graphics utilities
#+author: mooss

# No :wrap for this file because I can't disable it when I need to (uniform generation).
# `:exports both` does not work with pandoc when set at this level, it must be set manually in the code block header-args.
#+property: header-args :eval never :main no :exports both :noweb no-export
#+property: header-args:cpp+ :flags -std=c++20 -I include -ldl -lGL -lglfw src/glad.c

* Prelude

** Inclusion

General include script:
#+name: include
#+begin_src sh :var args="" :results output :wrap "src cpp" :eval no-export
./litlib/include.pl "window.org litlib/cpp.org graphics.org" "$args"
#+end_src

Specialised block for shaders (makes things slightly more readable):
#+name: shader
#+begin_src bash :var noweb="" :results output :wrap "src text" :eval no-export
./litlib/include.pl "graphics.org" ":noweb $noweb :c-string"
#+end_src


** Log the output of OpenGL commands :noexport:

With the help of some pretty awesome black magic, =sed= can be used to replace OpenGL calls with a logging call via =LOG_AND_CALL=.

First, the following code block (from https://stackoverflow.com/a/66090390) must be executed:
#+begin_src emacs-lisp :eval no-export :results silent
(defun shell-command-on-buffer (command)
  ;; (interactive)
  (let ((line (line-number-at-pos)))
    ;; replace buffer with output of shell command
    (shell-command-on-region (point-min) (point-max) command nil t)
    ;; restore cursor position
    (goto-line line)
    (recenter-top-bottom)))
#+end_src

Then execute the following elisp command via =C-x C-e=:
(shell-command-on-buffer "sed -r 's| (gl[a-ln-zA-Z]+[^(]+)\\(| LOG_AND_CALL(\\1, |'")
There is a space at the beginning of the regex to avoid matching initialisation lists.
=m= is excluded from the match to avoid glm functions.

Regex to transform logging calls back to plain opengl calls:
(shell-command-on-buffer "sed -r 's|LOG_AND_CALL\\((gl[a-zA-Z]+[^,]+), |\\1(|'")

I had to resort to sed because I'm not a fan of  Emacs' regexes.
To adapt the regexes above, remember that backslashes must be escaped because they are in an elisp string.

It should be possible to make the logging calls work for initialisation lists by adding a templated =log_and_call= function.


** Design guidelines

To talk about design principles here would be a bit too much since I really don't have enough experience in graphics programming.

*** Early action

Perform any relevant OpenGL action in the constructor of its wrapper.
For example, when applied to a shader, this guideline advises to trigger its immediate compilation on construction.

I'm not sure this is a very good idea because there are probably tons of situations in which those actions should be deffered, but this is very handy to avoid noisy =.use()=, =.bind()=, =.send()= so I want to see if I can make it work.

*** Early failure

Fail immediately when an error occurs.


* OpenGL primitives

In this section are defined various OpenGL-related objects that let us draw things.
The building blocks defined here are relying on each other to do their work, this means that there is no obvious way to show their usefulness independantly.
Therefore, usage examples are gathered in the next section, after all has been defined.

I'm a bit lax with the dependencies declaration here because technically the blocks defined in this section are using OpenGL functions but they are not supposed to include those functions themselves.
What's implied here is that the user of the code blocks below knows what to expect and is using them in the proper context, that is to say after =window= or any other kind of OpenGL including mechanism has been included.

I tried to make as many things =const= as possible for those OpenGL primitives, this way once the objects are constructed, they are set in stone and annoying mistakes can be avoided.
Of course, those things will be "unconsted" when needed.

** Shader

The design guidelines of early action and early failure manifest themselves in =shader_base= with the immediate compilation of the shader in the constructor followed by a call to =ensure_success= that will throw should a compilation error have occured.

Apparently, shaders are supposed to be deleted once they are linked, hence the custom desctuctor.
This means that =shader_base= objects should only be used as temporary objects, that's why they are not copyable or movable.
They probably should not be objects at all then, but I'll think about this another day.

# Using explicit =delete instead of waiting for the ability of include.pl to execute code blocks, since it will not happen anytime soon.

#+name: shader_base
#+begin_src cpp
class shader_base {
  public:
    const GLuint id;

    ~shader_base() {
        glDeleteShader(id);
    }

  protected:
    shader_base(const char* source, int type):
        id(glCreateShader(type))
    {
        // Early action.
        glShaderSource(id, 1, &source, nullptr);
        glCompileShader(id);
        // Early failure.
        ensure_success();
    }

    shader_base(shader_base&&)=delete;
    shader_base& operator=(shader_base&&)=delete;
    shader_base(const shader_base&)=delete;
    shader_base& operator=(const shader_base&)=delete;
    shader_base()=delete;

  private:
    bool compiled() const {
        int success;
        glGetShaderiv(id, GL_COMPILE_STATUS, &success);
        return success;
    }

    std::string info_log() const {
        char buffer[512];
        glGetShaderInfoLog(id, 512, nullptr, buffer);
        return std::string(buffer, 512);
    }

    void ensure_success() {
        if(!compiled()) {
            throw std::runtime_error(info_log());
        }
    }
};
#+end_src
#+depends:shader_base :cpp string stdexcept

*** Vertex shader

#+name: vertex_shader
#+begin_src cpp
struct vertex_shader: public shader_base {
    vertex_shader(const char* source): shader_base(source, GL_VERTEX_SHADER) {}
};
#+end_src
#+depends:vertex_shader :noweb shader_base

*** Fragment shader

#+name: fragment_shader
#+begin_src cpp
struct fragment_shader: public shader_base {
    fragment_shader(const char* source): shader_base(source, GL_FRAGMENT_SHADER) {}
};
#+end_src
#+depends:fragment_shader :noweb shader_base

*** Shader program

A shader program links together a vertex shader and a fragment shader.
The build immediately, fail early principle is used here once again, this time for the linking step.

Rvalue references are used for the =vertex_shader= and =fragment_shader= parameters to enforce the idea that those are only temporary objects that should be destroyed as soon as they are used.
In fact the only reason to use those parameter types and not =const char*= is to make it impossible to invert them.

#+name: shader_program
#+begin_src cpp
class shader_program {
  public:
    shader_program(const vertex_shader&& vs, const fragment_shader&& fs):
        id(glCreateProgram())
    {
        glAttachShader(id, vs.id);
        glAttachShader(id, fs.id);
        glLinkProgram(id);
        ensure_success();
        use();
    }

    void use() const {
        glUseProgram(id);
    }

    const GLuint id;

  private:
    bool linked() const {
        int success;
        glGetProgramiv(id, GL_LINK_STATUS, &success);
        return success;
    }

    std::string info_log() const {
        char buffer[512];
        glGetProgramInfoLog(id, 512, nullptr, buffer);
        return std::string(buffer, 512);
    }

    void ensure_success() const {
        if(!linked()) {
            throw std::runtime_error(info_log());
        }
    }
};
#+end_src
#+depends:shader_program :noweb fragment_shader vertex_shader :cpp stdexcept


** Buffers

=opengl_buffer= establishes a link with the GPU to send data to it.

The documentation of [[http://docs.gl/gl3/glDeleteBuffers][=glDeleteBuffers=]] states that deleting a buffer whose name is 0 does nothing and that calling this function with a defined name reverts said name to 0.
This property and RAII are used to manage the ownership of the link.

#+name: opengl_buffer
#+begin_src cpp
template<class TargetPolicy>
class opengl_buffer {
  protected:
    template<typename T>
    void send(const std::span<const T> data) const {
        // A new binding will simply replace the previous one.
        glBindBuffer(TargetPolicy::target(), name_);
        glBufferData(TargetPolicy::target(), data.size() * sizeof(T), data.data(), GL_STATIC_DRAW);
    }

    opengl_buffer() {glGenBuffers(1, &name_);}
    ~opengl_buffer() {glDeleteBuffers(1, &name_);}
    // This class is move-only to preserve link ownership.
    opengl_buffer(const opengl_buffer&)=delete;
    opengl_buffer& operator=(const opengl_buffer&)=delete;
    opengl_buffer(opengl_buffer&& other) {
        name_ = other.name_;
        other.name_ = 0;
    }
    opengl_buffer& operator=(opengl_buffer&& other) {
        glDeleteBuffers(1, &name_); // The previous buffer can now be deleted.
        name_ = other.name_;
        other.name_ = 0;
        return *this;
    }

  private:
    GLuint name_;
};
#+end_src
#+depends:opengl_buffer :cpp span

*** VBO (Vertex Buffer Object)

VBOs are what is used to send vertices to the GPU.
#+name: VBO
#+begin_src cpp
struct __details_VBO_target {static GLenum target() {return GL_ARRAY_BUFFER;}};
class VBO: public opengl_buffer<__details_VBO_target> {
  public:
    VBO(): opengl_buffer() {}
    void send(const std::span<const GLfloat> data) const {
        opengl_buffer::send<GLfloat>(data);
    }
};
#+end_src
#+depends:VBO :noweb opengl_buffer

*** EBO (Element Buffer Object)

EBOs are used to store indexes referring to vertices stored inside VBOs.
This way, vertices shared by several triangles can be send only once and used multiple times.

#+name: EBO
#+begin_src cpp
struct __details_EBO_target {static GLenum target() {return GL_ELEMENT_ARRAY_BUFFER;}};
class EBO: public opengl_buffer<__details_EBO_target> {
  public:
    EBO(): opengl_buffer() {}
    void send(const std::span<const GLuint> data) const {
        opengl_buffer::send<GLuint>(data);
    }
};
#+end_src
#+depends:EBO :noweb opengl_buffer


** VAO (Vertex Array Object)

VAOs function is to remember various calls made on data held by VBOs.
Once a VAO is bound, it remembers state changes caused by various subsequent OpenGL calls.
Those states changes can be enacted again later by simply bounding the VAO, acting like a sort of shortcut.

Since [[http://docs.gl/gl3/glDeleteVertexArrays][=glDeleteVertexArrays=]] behaves in the same way as =glDeleteBuffers=, the ownership logic from =opengl_buffer= is reused here.

#+name: VAO
#+begin_src cpp
class VAO {
  public:
    void bind() const {
        glBindVertexArray(name_);
    }

    VAO() {
        glGenVertexArrays(1, &name_);
        bind();
    }
    ~VAO() {glDeleteVertexArrays(1, &name_);}

    VAO(const VAO&)=delete;
    VAO& operator=(const VAO&)=delete;
    VAO(VAO&& other) {
        name_ = other.name_;
        other.name_ = 0;
    }
    VAO& operator=(VAO&& other) {
        glDeleteVertexArrays(1, &name_);
        name_ = other.name_;
        other.name_ = 0;
        return *this;
    }

  private:
    GLuint name_;
};
#+end_src


** Vertices and indexes

The =vertices= and =indexes= classes are a wrapper around respectively =VBO= and =EBO=, adding a =draw= method.

Utilities common to =vertices= and =indexes=:
#+name: vertindex_common
#+begin_src cpp
namespace details {
void assert_multiple(unsigned int n, unsigned int divisor, const char* error_keyword) {
    if(n % divisor != 0) {
        // throw std::runtime_error(std::format(
        //     "Invalid number of {}, expected a multiple of {} but got {} % {} = {}.",
        //     error_keyword, divisor, n, divisor, n % divisor
        // ));
        // C++20's <format> header is not supported for now.
        throw std::runtime_error( std::string("Invalid number of ") + std::string(error_keyword)
                                  + std::string(": ") + std::to_string(n) );
    }
}
}
#+end_src
#+depends:vertindex_common :cpp string stdexcept

*** Vertices and their layout

=vertices= handles both the vertex data and its layout.
Vertices are sent straightaway to the GPU because I don't need anything else right now.

The layout is specified as a sequence of the sizes of the sub-vertices in the order of their apparition.
For example, if we want to send vertices composed of 8 floats, the first three being the position, the next two being some magic data and the last 3 being the color, the corresponding layout will be ={3, 2, 3}=.

#+name: vertices
#+begin_src cpp :noweb no-export
namespace details {
template<class T> struct glenum;
template<> struct glenum<GLfloat> { static const GLenum v = GL_FLOAT; };
}

template<typename T>
class vertices {
  public:
    vertices(std::span<const T> content, std::span<const unsigned int> layout):
        stride_(sum(layout)), count_(content.size() / stride_)
    {
        if(layout.size() == 0)
            throw std::runtime_error("Empty vertex layouts are illegal.");
        details::assert_multiple(content.size(), stride_, "vertices for the given layout");
        vbo_.send(content);
        <<Process vertices layout>>
    }

    void draw() const { // Strictly VBO-based, no EBOs here.
        glDrawArrays(GL_TRIANGLES, 0, count_);
    }

  private:
    const GLsizei stride_;
    const GLsizei count_;
    const VBO vbo_;
};
#+end_src
#+depends:vertices :noweb VBO vertindex_common sum :cpp span

Vertex attributes are used to specify the layout of the data sent to the GPU.
The =layout= parameter is used to deduce the required values of each vertex attribute, with a caveat being that it is more restrictive than manually calling =glVertexAttribPointer=.

In particular, by virtue of how =layout= is constructed, the sub-vertices must have the same order in the layout as in the shader.
Going back to the previous example, it would not be possible to swap the position and the color without also inverting their order in the shader.

As promised, the layout is defined following the order of =layout=:
#+name: Process vertices layout
#+begin_src cpp
std::size_t offset = 0;
for(std::size_t i = 0; i < layout.size(); ++i) {
    glVertexAttribPointer(
        i, layout[i], details::glenum<T>::v, GL_FALSE,
        stride_ * sizeof(T), (void*) offset
    );
    offset += sizeof(T) * layout[i];
    glEnableVertexAttribArray(i);
}
#+end_src

The following helper function constructs =vertices= with both vertices and layout data being held inside a =std::vector=.
Using this allows to create the vectors in place with a braced syntax.

#+name: vec_vertices
#+begin_src cpp
template<typename T>
vertices<T> vec_vertices(const std::vector<T>& content, const std::vector<unsigned int>& layout) {
    return vertices<T>(content, layout);
}
#+end_src
#+depends:vec_vertices :noweb vertices :cpp vector

This is the same thing but using a =std::span= for the data:
#+name: spanvec_vertices
#+begin_src cpp
template<typename T>
vertices<T> spanvec_vertices(std::span<const T> content, const std::vector<unsigned int>& layout) {
    return vertices<T>(content, layout);
}
#+end_src
#+depends:spanvec_vertices :noweb vertices :cpp span vector

*** Indexes

#+name: indexes
#+begin_src cpp
class indexes {
  public:
    indexes(std::span<const GLuint> content):
        count_(content.size())
    {
        // Hardcoded 3 because only triangles are supported.
        details::assert_multiple(content.size(), 3, "indexes");
        ebo_.send(content);
    }

    void draw() const {
        glDrawElements(GL_TRIANGLES, count_, GL_UNSIGNED_INT, 0);
    }

  private:
    EBO ebo_;
    GLsizei count_;
};
#+end_src
#+depends:indexes :noweb EBO vertindex_common :cpp span

Similar to =vec_vertices=, =vec_indexes= allow to create indexes on the fly, with a vector:
#+name: vec_indexes
#+begin_src cpp
indexes vec_indexes(const std::vector<GLuint>& content) {
    return indexes(content);
}
#+end_src
#+depends:vec_indexes :noweb indexes :cpp vector


** Uniform

Uniforms can be used to share data between the CPU and shader programs.
Lots of different data types can be shared this way, via =glUniform*= functions.
For example, =glUniform4f= can be used to send a vector of 4 floats.

The code block below uses LitLib's Pycgen and Pyogen to generate the necessary uniform variants.
It is a big code block but I think it's pretty easy to understand once the following bases are covered:
 - A =Pycgen= instance in the variable =cpp= stores the indentation level which can be increased when =cpp= is used as a context manager (via Python's =with= keyword).
   Once the context is exited (after the =with= block), the indentation level is automatically decreased and curly braces opened via =cpp.par= or =cpp.struct= are automatically closed.
 - Calling =cpp= prints its arguments with the current indentation level.
 - A simple coding scheme is used to encode the nature of the struct to generate.
   For example, the code =m4f= represents a matrix of $4 \times 4$ floats.
   Incidentally, this code is also used to name the generated struct.

#+begin_src python :eval no-export :results output raw :exports both
<<include(":noweb Pycgen Pyogen")>>

cpp = Pycgen()

type_dispatcher = {
    'f': 'GLfloat',
    'i': 'Glint',
    'ui': 'Gluint'
}

def varnames(cardinality):
    return ['x', 'y', 'z', 'w'][:cardinality]

def arglist(cardinality, typename):
    return '(' + ', '.join(
        type_dispatcher[typename] + ' ' + el
        for el in varnames(cardinality)
    ) + ')'

def decode(code):
    cardinality = int(code[0]); assert 0 < cardinality <= 4,\
        'Code `{}` has an invalid cardinality.'.format(code)
    typename = code[1:]; assert typename in type_dispatcher,\
        'Code `{}` has an invalid typename.'.format(code)
    return cardinality, typename

def location_ctor(name):
    cpp(
        'const GLint location;',
        name + '(const GLchar* name, const shader_program& program):',
        '    location(glGetUniformLocation(program.id, name))',
        '{}'
    )

def vec_uniform(code):
    cardinality, typename = decode(code)
    name='uniform_' + code
    with Pyogen('src cpp', name=name, depends=':noweb shader_program'):
        with cpp.struct(name):
            location_ctor(name)
            with cpp.par('void send' + arglist(cardinality, typename) + ' const'):
                cpp('glUniform' + code + '(location, ' + ', '.join(varnames(cardinality)) + ');')

def mat_uniform(code):
    assert code[0] == 'm'
    cardinality, typename = decode(code[1:])
    name = 'uniform_' + code
    with Pyogen('src cpp', name=name, depends=':noweb shader_program :cpp span'):
        with cpp.struct(name):
            location_ctor(name)
            with cpp.par('void send(std::span<const GLfloat, ' + str(cardinality * cardinality) + '> content) const'):
                cpp('glUniformMatrix' + code[1:] + 'v(location, 1, GL_FALSE, content.data());')

def uniform(code):
    if code[0] == 'm':
        mat_uniform(code)
    else:
        vec_uniform(code)
    print()

print('*** Generated uniforms')
uniform('3f')
uniform('4f')
uniform('m3f')
uniform('m4f')
#+end_src

#+RESULTS:
*** Generated uniforms
#+name: uniform_3f
#+begin_src cpp
struct uniform_3f {
    const GLint location;
    uniform_3f(const GLchar* name, const shader_program& program):
        location(glGetUniformLocation(program.id, name))
    {}
    void send(GLfloat x, GLfloat y, GLfloat z) const {
        glUniform3f(location, x, y, z);
    }
};
#+end_src
#+depends:uniform_3f :noweb shader_program

#+name: uniform_4f
#+begin_src cpp
struct uniform_4f {
    const GLint location;
    uniform_4f(const GLchar* name, const shader_program& program):
        location(glGetUniformLocation(program.id, name))
    {}
    void send(GLfloat x, GLfloat y, GLfloat z, GLfloat w) const {
        glUniform4f(location, x, y, z, w);
    }
};
#+end_src
#+depends:uniform_4f :noweb shader_program

#+name: uniform_m3f
#+begin_src cpp
struct uniform_m3f {
    const GLint location;
    uniform_m3f(const GLchar* name, const shader_program& program):
        location(glGetUniformLocation(program.id, name))
    {}
    void send(std::span<const GLfloat, 9> content) const {
        glUniformMatrix3fv(location, 1, GL_FALSE, content.data());
    }
};
#+end_src
#+depends:uniform_m3f :noweb shader_program :cpp span

#+name: uniform_m4f
#+begin_src cpp
struct uniform_m4f {
    const GLint location;
    uniform_m4f(const GLchar* name, const shader_program& program):
        location(glGetUniformLocation(program.id, name))
    {}
    void send(std::span<const GLfloat, 16> content) const {
        glUniformMatrix4fv(location, 1, GL_FALSE, content.data());
    }
};
#+end_src
#+depends:uniform_m4f :noweb shader_program :cpp span

*** Reminder

A minor reminder concerning uniforms, they must be sent to the shader *after* the shader's first usage, so it's
#+begin_src cpp
program.use();
uniform.send(4, 8, 15, 16, 23, 42);
#+end_src
And not the other way around.


* OpenGL primitives examples

All the examples below are adapted from the excellent OpenGL tutorial at =learnopengl.com=.
Screenshots of the scenes can be saved as a 720p png with the help of this code block (and =gl_screen_first=):
#+name: png720p
#+begin_src cpp
image::format::png::writer<image::resize> png720p(image::resize{1280, 720});
#+end_src
#+depends:png720p :noweb image/format/png image/resize

** Drawing plain figures

The examples in the next two subsections are coming from the Hello-Triangle section of =learnopengl.com= (https://learnopengl.com/Getting-started/Hello-Triangle).
They are about using barebones fragment and vertex shaders to draw simple figures on the screen.

The next two code blocks are respectively the vertex and fragment shaders that will be used in this section.

#+name: basic_vs
#+begin_src glsl
#version 330 core
layout (location = 0) in vec3 position;

void main() {
    gl_Position = vec4(position.x, position.y, position.z, 1.0);
}
#+end_src

#+name: red_fs
#+begin_src glsl
#version 330 core
out vec4 color;

void main() {
    color = vec4(1.0f, 0.2f, 0.1f, 1.0f);
}
#+end_src

*** Drawing a triangle with =vertices=

There is not much to say here, this is the most minimalistic way I have to draw something.
It still requires some setup but it is as easy and convenient as I could make it.
The screen-capturing game loop function of [[window.org]] is put to good use to:
 - Save the capture.
 - Print the capture's filename as an org link.
 - Setup a game loop using the given lambda.

# Red triangle example.
#+begin_src cpp :eval no-export :exports both
<<include(":noweb print lazy_window gl_screen_first VAO shader_program vec_vertices png720p")>>

int main(){
    const char *vs_str =
        <<shader("basic_vs")>>
        ;
    const char *fs_str =
        <<shader("red_fs")>>
        ;

    lazy_window lazy("Red triangle", 640u, 480u);
    shader_program basic_shader{vertex_shader(vs_str), fragment_shader(fs_str)};
    VAO triangle_vao{};
    auto triangle = vec_vertices<GLfloat>({
        -0.5, -0.5, 0.0,
         0.5, -0.5, 0.0,
         0.0,  0.5, 0.0
    }, {3});

    gl_screen_first(lazy, "images/screencaps/triangle_vertices.png", png720p, [&]{
        basic_shader.use();
        triangle_vao.bind();
        triangle.draw();
    });
    return 0;
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/triangle_vertices.png]]
:end:

*** Drawing a rectangle with =indexes=

Same thing as above, except we use =indexes= (and therefore =EBO=) as well as =vertices= to draw the two triangles forming a rectangle.

#+begin_src cpp :eval no-export :exports both
<<include(":noweb lazy_window gl_screen_first VAO shader_program vec_vertices vec_indexes png720p")>>

int main(){
    const char *vs_str =
        <<shader("basic_vs")>>
        ;
    const char *fs_str =
        <<shader("red_fs")>>
        ;

    lazy_window lazy("Red rectangle", 640u, 480u);
    shader_program basic_shader{vertex_shader(vs_str), fragment_shader(fs_str)};
    VAO rectangle_vao{};
    auto rectangle_vertices = vec_vertices<GLfloat>({
            0.5,  0.5, 0.0, // Top right.
            0.5, -0.5, 0.0, // Bottom right.
           -0.5, -0.5, 0.0, // Bottom left.
           -0.5,  0.5, 0.0  // Top left.
    }, {3});
    auto rectangle_indexes = vec_indexes({
            0, 1, 3, // First triangle.
            1, 2, 3  // Second triangle.
    });

    gl_screen_first(lazy, "images/screencaps/rectangle_indexes.png", png720p, [&]{
        basic_shader.use();
        rectangle_vao.bind();
        rectangle_indexes.draw();
    });
    return 0;
  }
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/rectangle_indexes.png]]
:end:


** Uniform and sub-vertices

The next examples are adapted from the Shaders section (https://learnopengl.com/Getting-started/Shaders).

*** Drawing a color-shifting triangle with =uniform=

The following shader colors pixels according to the content of the uniform =color_cpu=:

#+name: color_shifting_fs
#+begin_src glsl
#version 330 core
out vec4 color_out;
uniform vec4 color_cpu;

void main() {
    color_out = color_cpu;
}
#+end_src

The OpenGL program below is based on the =vertices= drawing program above and uses a =uniform_4f= to update the value of =color_cpu= every time a frame is drawn.

#+begin_src cpp :eval no-export :exports both 
<<include(":noweb lazy_window gl_screen_first VAO shader_program vec_vertices uniform_4f png720p :cpp cmath")>>

int main(){
    const char *vs_str =
        <<shader("basic_vs")>>
        ;
    const char *fs_str =
        <<shader("color_shifting_fs")>>
        ;

    lazy_window lazy("Triangle with shifting color", 640u, 480u);
    shader_program shifting_shader{vertex_shader(vs_str), fragment_shader(fs_str)};
    uniform_4f color_cpu("color_cpu", shifting_shader);
    VAO triangle_vao{};
    auto triangle = vec_vertices<GLfloat>({
        -0.5, -0.5, 0.0,
         0.5, -0.5, 0.0,
         0.0,  0.5, 0.0
    }, {3});

    gl_screen_first(lazy, "images/screencaps/shifting_color.png", png720p, [&]{
        float green = sin(glfwGetTime() * 3) * .07f + .75f;
        shifting_shader.use();
        color_cpu.send(.1, green, .8, 1.);
        triangle_vao.bind();
        triangle.draw();
    });
    return 0;
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/shifting_color.png]]
:end:

The screen capture is not very interesting here because it does not show the shifting colors but I still included it for good mesure.

*** Sending colors as sub-vertices

In this example, the colors of each vertex are sent to the GPU alongside their position.

Below are the dedicated vertex and fragment shaders.
Not much is done in them, it's mainly a question of receiving the position and color in the right location in the vertex shader and of transmitting it to the fragment shader.

#+name: color_as_attribute_vs
#+begin_src glsl
#version 330 core
layout (location = 0) in vec3 position;
layout (location = 1) in vec3 color_in;
out vec3 color_fs;

void main() {
    gl_Position = vec4(position, 1.);
    color_fs = color_in;
}
#+end_src

#+name: color_as_attribute_fs
#+begin_src glsl
#version 330 core
out vec4 color_out;
in vec3 color_fs;

void main() {
    color_out = vec4(color_fs, 1.);
}
#+end_src


The main difference with previous examples is that, to send the positions and the colors to their respective location, a vertex layout with two sub-vertices is used (={3, 3}=).
This means that two vertex attributes composed of 3 elements are defined next to each other.
The first one at location 0 is handled as the position in the vertex shader, whereas the second one at location 1 is handled as the color.

#+begin_src cpp :eval no-export :exports both
<<include(":noweb lazy_window gl_screen_first VAO shader_program vec_vertices png720p")>>

int main(){
    const char *vs_str =
        <<shader("color_as_attribute_vs")>>
        ;
    const char *fs_str =
        <<shader("color_as_attribute_fs")>>
        ;

    lazy_window lazy("Triangle with color attributes", 640u, 480u);
    shader_program basic_shader{vertex_shader(vs_str), fragment_shader(fs_str)};
    VAO triangle_vao{};
    auto triangle = vec_vertices<GLfloat>(
        // Vertices:
        // Positions         // Colors
        {  0.5f, -0.5f, 0.0f,   1.0f, 0.0f, 0.0f,    // Bottom right.
          -0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,    // Bottom left.
           0.0f,  0.5f, 0.0f,   0.0f, 0.0f, 1.0f  }, // Top.
        // Vertices layout:
        {  3 /* Positions */,   3 /* Colors   */  }
    );

    gl_screen_first(lazy, "images/screencaps/color_as_attribute.png", png720p, [&]{
        basic_shader.use();
        triangle_vao.bind();
        triangle.draw();
    });
    return 0;
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/color_as_attribute.png]]
:end:


* Transformations

This section will tackle more involved OpenGL subjects, linked to the theme of transformations.
The first subsection will be about matrix transformation proper, that is to say the usage of matrix multiplication properties to transform (i.e. scale, rotate and translate) 3d objects.
The subsequent sections will build upon this foundation to introduce the model, view and projection matrices as well as cameras.
Once again, this section is based on the tutorial at [[https://learnopengl.com][learnopengl.com]], more specifically on the [[https://learnopengl.com/Getting-started/Transformations][Transformations]], [[https://learnopengl.com/Getting-started/Coordinate-Systems][Coordinate Systems]] and [[https://learnopengl.com/Getting-started/Camera][Camera]] chapters.

But first, in an attempt to normalise and disencumber the examples, the next code block prepares what is needed to draw a colorful cube.
This was adapted from some old code lying around so the order of indexes and vertices doesn't correspond to anything and perhaps doesn't make much sense.
Four colors are used for the cube vertices, with every opposite pair of vertices sharing the same color.

I seem to remember that there is some kind of convention in OpenGL about the order of vertices meaning something about the orientation of the normal but I can't be bother to find out so I'll come back to it later if I feel like it.
Anyway the cube renders in a colorful manner kind of reminiscent of the PS1 boot logo, as will be seen in the first example that uses it.

#+name: colorful-example
#+begin_src cpp
lazy_window lazy("Yliss colorful example", 640u, 480u);
shader_program colorful_shader{vertex_shader(vs_str), fragment_shader(fs_str)};
VAO colorful_vao{};
auto colorful_vertices = vec_vertices<GLfloat>({
     // Positions    // Colors
        .5,  .5,  .5,   1, 1, 0, // Yellow.
       -.5,  .5,  .5,   1, 0, 1, // Magenta.
        .5,  .5, -.5,   1, 1, 1, // White.
       -.5,  .5, -.5,   0, 1, 1, // Cyan.
        .5, -.5,  .5,   0, 1, 1, // Cyan.
       -.5, -.5,  .5,   1, 1, 1, // White.
       -.5, -.5, -.5,   1, 1, 0, // Yellow.
        .5, -.5, -.5,   1, 0, 1  // Magenta.
}, {3, 3});
auto colorful_indexes = vec_indexes({
        3, 2, 6,
        2, 6, 7,
        6, 7, 4,
        7, 4, 2,
        4, 2, 0,
        2, 0, 3,
        0, 3, 1,
        3, 1, 6,
        1, 6, 5,
        6, 5, 4,
        5, 4, 1,
        4, 1, 0
});
#+end_src
#+depends:colorful-example :noweb lazy_window shader_program VAO vec_vertices vec_indexes

** Matrix transformations

Matrices have the very useful property of being able to store and combine 3d transformations like scaling, rotating and translating.
GLM provides functions to perform those operations.
The class =transform= is nothing more than convenient syntactic sugar for those functions.

#+name: transform
#+begin_src cpp
class transform {
  public:
    glm::mat4 matrix_{1.f};

    transform& rotate_rad(float angle, const glm::vec3& axis) {
        return rotate_rad_impl(angle, glm::normalize(axis));
    }
    transform& rotate_deg(float angle, const glm::vec3& axis) {
        return rotate_rad_impl(glm::radians(angle), glm::normalize(axis));
    }

    transform& scale(const glm::vec3& magnitude) {
        matrix_ = glm::scale(matrix_, magnitude);
        return *this;
    }
    transform& scale(float factor) {return scale({factor, factor, factor});}

    transform& translate(const glm::vec3& translation) {
        matrix_ = glm::translate(matrix_, translation);
        return *this;
    }

    operator auto() const {
        return to_span(matrix_);
    }

  private:
    transform& rotate_rad_impl(float angle, const glm::vec3& axis) {
        matrix_ = glm::rotate(matrix_, angle, axis);
        return *this;
    }
};
#+end_src
#+depends:transform :noweb to_span/glm :cpp glm/gtc/matrix_transform.hpp

Some remarks about =transform=:
 - The transformation methods return =*this= to make them chainable.
 - Having a public default-initialised =matrix_= makes it possible to manually initialise it to whatever we want, like this for example:
   #+begin_src cpp
glm::mat4 nonsensical_matrix{12.f};
transform nonsensical_transformation{nonsensical_matrix};
   #+end_src
   The trailing underscore is here to signify that even though this is a public field, it should not be modified.
 - Rotation axes are normalised, as recommended by GLM.
 - The conversion operator to =std::span= makes sending a transformation to the gpu a breeze.
 - This class would be an adequate candidate for [[https://en.cppreference.com/w/cpp/language/member_functions#ref-qualified_member_functions][ref-qualifiers]], to avoid unnecessary copies of the matrix.
   It's not worth the effort right now.

*** Transform uniform

The struct =transform_uniform= is a shortcut for a transformation matrix with its associated uniform.
#+name: transform_uniform
#+begin_src cpp
struct transform_uniform {
    transform transformation;
    uniform_m4f uniform;

    template<typename Transform>
    transform_uniform(Transform&& t, const std::string& name, const shader_program& shader):
        transformation(std::forward<Transform>(t)), uniform(name.c_str(), shader)
    {send();}

    void send() const {
        uniform.send(transformation);
    }

    transform* operator->() {return &transformation;}
};
#+end_src
#+depends:transform_uniform :noweb transform uniform_m4f shader_program :cpp string

*** Usage

To experiment with transformations, this vertex shader transmits the input color it received to the fragment shader and applies a given transformation matrix to its original position:
#+name: colorattr_transform_vs
#+begin_src glsl :minipage
#version 330 core
layout (location = 0) in vec3 position;
layout (location = 1) in vec3 color_in;
out vec3 color_fs;
uniform mat4 transformation;

void main() {
    gl_Position = transformation * vec4(position, 1.0f);
    color_fs = color_in;
}
#+end_src

This sends a custom transformation to the shader using a =transform_uniform=:
#+begin_src cpp :eval no-export :exports both
const char *vs_str =
    <<shader("colorattr_transform_vs")>>
    ;
const char *fs_str =
    <<shader("color_as_attribute_fs")>>
    ;
<<include(":noweb colorful-example transform transform_uniform gl_screen_first png720p")>>

int main() {
    colorful_shader.use();
    transform_uniform cube_transformation(
        transform().translate({-.3, 0, 0})
                   .scale({.5, .5, 1})
                   .rotate_deg(45, {0, 0, 1}),
        "transformation", colorful_shader
    );

    gl_screen_first(lazy, "images/screencaps/cube_transformation.png", png720p, [&]{
        colorful_shader.use();
        colorful_vao.bind();
        colorful_indexes.draw();
        // Keep rotating a bit every frame.
        cube_transformation->rotate_rad(.015, {1, 1, 0});
        cube_transformation.send();
    });
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/cube_transformation.png]]
:end:

Note that the image above really is a cube.
I choosed to pick an angle where only a side was visible because it was pretty.
For an image with more of a 3d feeling, see the next usage example.


** Model, view and projection matrices

The model, view and projection matrices are transformation matrices each doing their own step to go from an isolated model to something ready to be drawn:
 - Model transforms local space (where the model is defined in isolation with the other assets) to world space (where all the assets are gathered).
   In other words, it places the model in the world.
 - View transforms world space to view space (where the scene is located, where the camera is looking at).
 - Projection transforms view space to clip space (where only what must be rendered is located, the rest being clipped off).
# TODO: Verify the above with other sources, I don't think I understood everything I needed.

The three matrices are abstracted away in =movipr= (=mvp= was too short and =model_view_projection= was too long), whose basic outline can be seen below.
Note that no matrices are directly stored within =movipr=, the three =uniform_m4f= only represent the link with uniforms in the shaders.
#+name: movipr
#+begin_src cpp
namespace movipr_details {
<<movipr_details/public>>
} // namespace movipr_details
struct movipr {
    uniform_m4f model;
    uniform_m4f view;
    uniform_m4f projection;
    <<movipr/public>>
};
#+end_src
#+depends:movipr :noweb uniform_m4f shader_program mandatory to_span/glm :cpp string glm/ext/matrix_clip_space.hpp glm/trigonometric.hpp

*** Construction parameters

In an attempt to make =movipr= easy to use and concise (for the user), the designated keywords arguments pattern is used.
It is justified by the fact that reasonable default values can be defined for most parameters.
The keyword arguments are separated in two groups.

The first parameter group is dedicated to the projection parameter (only perspective projection is supported).
The only parameter without reasonably defined default values is the =aspect= ratio, hence it is marked as =mandatory=.
#+begin_src cpp :noweb-ref movipr/public
struct perspective_projection {
    mandatory<float> aspect;
    float fov{45};
    float near{1};
    float far{100};
    auto make() const {
        return glm::perspective(glm::radians(fov), *aspect, near, far);
    }
};
perspective_projection projection_parameters; // Mandatory to be able to refresh the projection.
#+end_src

An instance of perspective projection can be constructed like shown below, and a construction attempt without a value for =aspect= will not compile.
#+begin_src cpp
perspective_projection params{.aspect=4./3., .fov=80};
#+end_src

The second parameter group contains the variable names for the model, view and projection uniforms.
#+begin_src cpp :noweb-ref movipr_details/public
struct variables {
    std::string model{"model"};
    std::string view{"view"};
    std::string projection{"projection"};
};
#+end_src

=variables= is defined outside of =movipr=, otherwise it cannot be used to generate a default value in the constructor (GCC fails with =default member initializer for ‘movipr::variables::model’ required before the end of its enclosing class= and similar messages for =view= and =projection=).
For ease of use, an alias is declared in =movipr=:
#+begin_src cpp :noweb-ref movipr/public
using variables = movipr_details::variables;
#+end_src

*** Constructors

The perfect forwarding used for =model= will be useful to define transformations in place using =transform='s translation, scaling and rotation methods.
Because those methods return references to =transform= but transformations matrices should be moved in other cases.
#+begin_src cpp :noweb-ref movipr/public
movipr(
    std::span<const GLfloat, 16> model_data, std::span<const GLfloat, 16> view_data,
    const perspective_projection& proj, const shader_program& shader,
    const variables& names=variables{}
): model(names.model.c_str(), shader),
   view(names.view.c_str(), shader),
   projection(names.projection.c_str(), shader),
   projection_parameters(proj)
{
    model.send(model_data);
    view.send(view_data);
    refresh_projection();
}
#+end_src

*** Update

The projection matrix can be updated with =refresh_projection= after the projection parameters have been changed.
#+begin_src cpp :noweb-ref movipr/public
void refresh_projection() {
    projection.send(to_span(projection_parameters.make()));
}
#+end_src

*** Usage

The following vertex shader receives the model, view and projection matrices and applies them to the position:
#+name: model_view_projection_vs
#+begin_src glsl
#version 330 core
layout (location = 0) in vec3 position;
layout (location = 1) in vec3 color_in;
out vec3 color_fs;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main() {
    gl_Position = projection * view * model * vec4(position, 1.0f);
    color_fs = color_in;
}
#+end_src

The =colorful-example= used previously is expanded below with =movipr=, to send the appropriate values of the =model=, =view= and =projection= uniforms to the shader.
A window size observer is also setup to update the projection's aspect ratio when the window is resized.

#+name: colorful-viper-example
#+begin_src cpp
glm::vec3 cube_location{-.5, 0, 0};
auto cube_transformation = transform().translate(cube_location)
                                    .scale(          {.5, .5, .5})
                                    .rotate_deg(45,  { 0,  0,  1})
                                    .rotate_deg(270, { 0,  1,  0})
                                    .rotate_deg(90,  { 1,  0,  1});
movipr viper(
    cube_transformation,
    transform().translate({0, 0, -2}),
    {.aspect = lazy.aspect()},
    colorful_shader
);

auto size_sub = lazy.observe_size([](auto const& size) {
    viper.projection_parameters.aspect = size.aspect();
    viper.refresh_projection();
});
#+end_src
#+depends:colorful-viper-example :noweb colorful-example movipr transform :cpp glm/vec3.hpp

Only the vertex and fragment shaders, as well as a game loop must be added to produce something that looks less like the squashed lozenge of the previous example and more like a cube viewed from a certain perspective.

#+begin_src cpp :eval no-export :exports both
const char *vs_str =
    <<shader("model_view_projection_vs")>>
    ;
const char *fs_str =
    <<shader("color_as_attribute_fs")>>
    ;
<<include(":noweb colorful-viper-example gl_screen_first png720p")>>

int main() {
    gl_screen_first(lazy, "images/screencaps/cc_model_view_projection.png", png720p, [&]{
        colorful_shader.use();
        colorful_vao.bind();
        colorful_indexes.draw();
        // Keep rotating a bit every frame.
        cube_transformation.rotate_rad(-.015, {1, 0, 1});
        viper.model.send(cube_transformation);
    });
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/cc_model_view_projection.png]]
:end:


** Cameras

Conceptually, a camera is nothing more than a way to generate a view matrix.
Here all the work is done by GLM's =lookAt=, transforming the position of the camera, the direction where it is looking (=front=) and the =up= vector into a view matrix.

#+name: camera
#+begin_src cpp
class camera {
  public:
    template<class Vec3>
    camera(Vec3&& position, Vec3&& front, Vec3&& up):
        position_(std::forward<Vec3>(position)),
        front_(std::forward<Vec3>(front)),
        up_(std::forward<Vec3>(up))
    {}

    camera()=delete;

    glm::mat4 view() const {
        return glm::lookAt(position_, position_ + front_, up_);
    }

    const glm::vec3& position() const {return position_;}

  protected:
    glm::vec3 position_, front_, up_;
};
#+end_src
#+depends:camera :cpp glm/ext/matrix_transform.hpp glm/vec3.hpp glm/mat4x4.hpp

*** Orbital camera

An orbital camera is focused on a point (the =focal_point=), at a given distance (the =radius=).
It is based on longitudinal and latitudinal angles, hence the name.
An =up= vector is also necessary to initialise the base camera.

I forgot the details on how this works and this is mostly copy-pasted from Godefarig, the ancestor of Yliss.
I'm bemused by the fact that the =up= vector is not modified in any operation of this orbital camera but the previous sentence explains this.

#+name: orbital_camera
#+begin_src cpp
class orbital_camera: public camera {
  public:
    orbital_camera(
        glm::vec3 focal_point, float radius, float longitude, float latitude,
        glm::vec3 up={0, 1, 0}
    ): camera({0, 0, 0}, {0, 0, 0}, std::move(up)), focal_point_(std::move(focal_point)),
       radius_(radius), longitude_(longitude), latitude_(latitude)
    {refresh();}

    orbital_camera& orient(float delta_longitude, float delta_latitude) {
        longitude_ += delta_longitude;
        latitude_  += delta_latitude;
        clamp_latitude();
        refresh();
        return *this;
    }

  private:
    glm::vec3 focal_point_;
    float radius_, longitude_, latitude_;
    <<orbital_camera/private>>
};
#+end_src
#+depends:orbital_camera :noweb camera :cpp glm/vec3.hpp glm/trigonometric.hpp glm/geometric.hpp

Below are two necessary support methods:
 - =refresh= is pretty basic trigonometry updating the =position_= and the =front_= values of the camera.
   Though I don't really know how it works.

   Something worrying me is that I did not declare a dependency on =<cmath>=, yet =cos= and =sin= are available for some reason.

 - The latitude clamping method prevents - to pursue the orbital metaphor - the camera from venturing above or below the poles.
   Without it, the camera jumps around from time to time, I assume because of gimbal lock or a related phenomenon.

   Therefore this camera will eventually have to be updated to something better.

#+begin_src cpp :noweb-ref orbital_camera/private :minipage
void refresh() {
    position_.x = cos(glm::radians(longitude_)) * cos(glm::radians(latitude_)) * radius_;
    position_.y = sin(glm::radians(latitude_))  * radius_;
    position_.z = sin(glm::radians(longitude_)) * cos(glm::radians(latitude_)) * radius_;
    front_      = - glm::normalize(position_);
    position_  += focal_point_;
}

void clamp_latitude() {
    if(latitude_ > 89.0f)
        latitude_ = 89.0f;
    else if(latitude_ < -89.0f)
        latitude_ = -89.0f;
}
#+end_src

*** Usage

No screen capture is included because what is visible here in a screenshot is not really different from what was in the previous section.

#+begin_src cpp :eval no-export :exports code :results silent
const char *vs_str =
    <<shader("model_view_projection_vs")>>
    ;
const char *fs_str =
    <<shader("color_as_attribute_fs")>>
    ;
<<include(":noweb colorful-viper-example orbital_camera to_span/glm")>>

int main() {
    orbital_camera director(cube_location, 2, 0, 0);
    viper.view.send(to_span(director.view()));

    lazy.game_loop([&]{
        colorful_shader.use();
        colorful_vao.bind();
        colorful_indexes.draw();

        // Rotate the model.
        cube_transformation.rotate_rad(-.015, {1, 0, 1});
        viper.model.send(cube_transformation);

        // And the camera.
        viper.view.send(to_span(director.orient(2, 0).view()));
    });
}
#+end_src


* Higher level OpenGL tools

** Minor utilities

*** =vertindex=
=vertindex= is simply a combination of =vertices= with =indexes=, with a =draw= method.

#+name: vertindex
#+begin_src cpp
template<class VertexT>
struct vertindex {
    vertices<VertexT> vert;
    indexes index;
    void draw() const {index.draw();}
};
#+end_src
#+depends:vertindex :noweb vertices indexes

# This Drawable concept is shelved for now but I want to keep it around, if only to have the example at hands.
# #+name: Drawable
# #+begin_src cpp
# template<class T>
# concept Drawable = requires(T t) {t.draw();};
# #+end_src

*** =mesh_data=

=mesh_data= is here to carry vertices and indexes data around without sending them to the GPU.
It is necessary for two reasons:
 1. The =vertices= and =indexes= instances in =vertindex= automatically sends data to the GPU on creation.
 2. Those instances do not store anything in the first place anyway.

Note that it does not actually stores anything since it only uses const references.
This is more of an exchange struct.

#+name: mesh_data
#+begin_src cpp
// template<class VertexT>
template<class ContentT>
struct mesh_data {
    // const std::vector<VertexT>& content;
    const ContentT& content;
    const std::vector<unsigned int>& layout;
    const std::vector<unsigned int>& indexes;
    auto instantiate() const {
        return vertindex<typename ContentT::value_type>{
            {content, layout},
            {indexes}
        };
    }
};
#+end_src
#+depends:mesh_data :noweb vertindex :cpp vector

*** =shader_sources=

=shader_sources= can help disambiguate the shader sources, the caller can set them as designated keyword arguments, line ={.vertex=vs, .fragment=fs}=.
#+name: shader_sources
#+begin_src cpp
struct shader_sources {
    mandatory<const char*> vertex;
    mandatory<const char*> fragment;
};
#+end_src
#+depends:shader_sources :noweb mandatory


** Shader unit

A shader unit gathers everything needed to draw something, i.e. a shader, a VAO, OpenGL buffers and the model, view and projection matrices.

Some assumptions are being made, namely that indexes are used to draw the model, that the shader requires model, view and projection uniforms and that one and only one model is needed per shader.
Those assumptions will certainly prove to be some combination of stupid and short-sighted but I can't make progress and learn new things without taking poor decisions.

#+name: shader_unit
#+begin_src cpp
template<class VerticesT = std::vector<float>>
class shader_unit {
  public:
    using VertexT = VerticesT::value_type;
    shader_unit(
        const shader_sources& sources, const transform& model,
        std::span<const GLfloat, 16> view, const movipr::perspective_projection& projection,
        const mesh_data<VerticesT>& data, const movipr::variables& names=movipr::variables{}
    ): shader_(vertex_shader(*sources.vertex), fragment_shader(*sources.fragment)),
       vao_(), drawable_(data.instantiate()), model_(model),
       viper(model, view, projection, shader_, names)
    {}

    void draw() const {
        shader_.use();
        vao_.bind();
        drawable_.draw();
    }

    <<shader_unit/public>>

  private:
    shader_program shader_;
    VAO vao_;
    vertindex<VertexT> drawable_;
    transform model_;

  public:
    movipr viper;
  private:
    <<shader_unit/private>>
};
#+end_src
#+depends:shader_unit :noweb shader_sources transform movipr mesh_data shader_program VAO uniform_m3f to_span/glm :cpp span glm/glm.hpp

*** Uniform manipulation

Send new data to the view uniform:
#+begin_src cpp :noweb-ref shader_unit/public
void send_view(std::span<const GLfloat, 16> view_data) const {
    viper.view.send(view_data);
}
#+end_src

Send any kind of uniform to the shader:
#+begin_src cpp :noweb-ref shader_unit/public
template<class UniformT, typename... Args>
void send(const GLchar* name, Args... args) const {
    UniformT(name, shader_).send(args...);
}
#+end_src

Send a normal model matrix to the shader and keep it up to date with the model matrix:
#+begin_src cpp :noweb-ref shader_unit/public
void send_normal_model() {
    send_normal_model_ = true;
    send<uniform_m3f>("normal_model", to_span(glm::transpose(glm::inverse(glm::mat3(model_.matrix_)))));
}
#+end_src
#+begin_src cpp :noweb-ref shader_unit/private
bool send_normal_model_ = false;
#+end_src

Modify the model matrix and refresh its value in the shader:
#+begin_src cpp :noweb-ref shader_unit/public
template<class Lambda>
void with_model(Lambda fun) {
    fun(model_);
    viper.model.send(model_);
    if(send_normal_model_)
        send_normal_model();
}
#+end_src

*** External utilities

The following utility function ties a =window='s aspect ratio with a =shader_unit='s projection matrix:
#+name: sync_window_size
#+begin_src cpp
template<class ShaderUnit>
auto sync_window_size(ShaderUnit& unit, window& win) {
    return win.observe_size([&](auto const& size) {
        unit.viper.projection_parameters.aspect = size.aspect();
        unit.viper.refresh_projection();
    });
}
#+end_src
#+depends:sync_window_size :noweb shader_unit window

This one can be used to refresh a view directly from a camera:
#+name: refresh_view
#+begin_src cpp
template<class ShaderUnit>
void refresh_view(const ShaderUnit& unit, const camera& cam) {
    unit.send_view(to_span(cam.view()));
}
#+end_src
#+depends:refresh_view :noweb shader_unit camera to_span/glm

*** Usage

#+begin_src cpp :eval no-export :exports both :results silent
<<include(":noweb print lazy_window orbital_camera shader_unit transform to_span/glm sync_window_size")>>

int main() {
    lazy_window lazy("Shader unit example");

    glm::vec3 cube_location{-.5, 0, 0};
    orbital_camera director(cube_location, 2, 0, 0);
    auto colorful_cube = shader_unit(
        {.vertex =
         <<shader("model_view_projection_vs")>>,
         .fragment =
         <<shader("color_as_attribute_fs")>>}, // Shader sources.
        transform().translate(cube_location)
                   .scale({.5, .5, .5})
                   .rotate_deg(45, {0, 0, 1}), // Model.
        to_span(director.view()),              // View.
        {.aspect=lazy.aspect()},               // Projection.
        {.content={                            // Model data.
            // Positions    // Colors
            .5,  .5,  .5,   1, 1, 0, // Yellow.
           -.5,  .5,  .5,   1, 0, 1, // Magenta.
            .5,  .5, -.5,   1, 1, 1, // White.
           -.5,  .5, -.5,   0, 1, 1, // Cyan.
            .5, -.5,  .5,   0, 1, 1, // Cyan.
           -.5, -.5,  .5,   1, 1, 1, // White.
           -.5, -.5, -.5,   1, 1, 0, // Yellow.
            .5, -.5, -.5,   1, 0, 1  // Magenta.
        }, .layout={3, 3}, .indexes={
            3, 2, 6,   2, 6, 7,   6, 7, 4,
            7, 4, 2,   4, 2, 0,   2, 0, 3,
            0, 3, 1,   3, 1, 6,   1, 6, 5,
            6, 5, 4,   5, 4, 1,   4, 1, 0
        }}
    );

    auto sync_anchor = sync_window_size(colorful_cube, lazy);

    lazy.game_loop([&]{
        colorful_cube.draw();
        colorful_cube.with_model([](auto& model){
            model.rotate_rad(-.015, {1, 0, 1});
        });
    });
}
#+end_src


* GLM utils

** Conversion

This next code block converts GLM matrices and vectors to =std::span=.

I'm a bit confused about const qualifiers.
In particular I wonder if an additional set of =to_span= functions is needed to handle specifically =const span<const T>= and =span<const T>= or if this is already handled by the two functions below or if this is not even relevant.

#+name: to_span/glm
#+begin_src cpp
template<glm::length_t Col, glm::length_t Row, typename T, glm::qualifier Q>
auto to_span(const glm::mat<Col, Row, T, Q>& container) {
    return std::span<const T, Col * Row>(glm::value_ptr(container), Col * Row);
}

template<glm::length_t Length, typename T, glm::qualifier Q>
auto to_span(const glm::vec<Length, T, Q>& container) {
    return std::span<const T, Length>(glm::value_ptr(container), Length);
}

// Same thing, without the const qualifiers.
template<glm::length_t Col, glm::length_t Row, typename T, glm::qualifier Q>
auto to_span(glm::mat<Col, Row, T, Q>& container) {
    return std::span<T, Col * Row>(glm::value_ptr(container), Col * Row);
}

template<glm::length_t Length, typename T, glm::qualifier Q>
auto to_span(glm::vec<Length, T, Q>& container) {
    return std::span<T, Length>(glm::value_ptr(container), Length);
}
#+end_src
#+depends:to_span/glm :cpp span glm/gtc/type_ptr.hpp

Usage
#+begin_src cpp :eval no-export :flags -Wall -std=c++20 :noweb no-export
<<include(":noweb to_span/glm <<span print")>>
int main() {
    glm::mat4 identity(1.0f);
    glm::vec2 lo{4, 8};
    glm::vec4 st{15, 16, 23, 42};
    print{"Identity 4x4 matrix:", to_span(identity)};
    print{"lo st:", to_span(lo), to_span(st)};
}
#+end_src

#+RESULTS:
:results:
Identity 4x4 matrix: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
lo st: [4, 8] [15, 16, 23, 42]
:end:



** Printing

*** Matrices
The operator overload below can be used to print a GLM matrix.
It is built based on the knowledge that GLM matrices are column-major and that in such a representation, for a matrix with $C$ columns and $R$ rows, the element at column $c$ and row $r$ is located at the offset $R \times c + r$.
The rest is just formatting details to ensure that the separators are well placed.

#+name: <<glm/mat
#+begin_src cpp
template<glm::length_t Col, glm::length_t Row, typename T, glm::qualifier Q>
std::ostream& operator<<(std::ostream& os, const glm::mat<Col, Row, T, Q>& container) {
    size_t size = Col * Row;
    os << "[";
    if(size > 0) {
        auto data = glm::value_ptr(container);
        size_t row = 0;
        for(; row < Row - 1; ++row) {
            for(size_t column = 0; column < Col; ++column) {
                os << " " << *(data + Row * column + row) << ",";
            }
            os << "\n ";
        }

        // The last row is a special case since it does not end with a ",".
        row = Row - 1;
        for(size_t column = 0; column < Col -1; ++column) {
            os << " " << *(data + Row * column + row) << ",";
        }
        os << " " << *(data + size - 1) << " ";
    }
    os << "]";
    return os;
}
#+end_src
#+depends:<<glm/mat :cpp ostream glm/gtc/type_ptr.hpp

As can be seen in the usage example below, values are not aligned prettily but this will do for now.
#+begin_src cpp :eval no-export :flags -Wall -std=c++11 :noweb no-export :exports both :wrap "src text :minipage"
<<include(":noweb <<glm/mat :cpp iostream")>>
int main() {
    glm::mat4 identity(1.0f);
    std::cout << "Identity transformation:\n" << identity << "\n\n";
    auto downscale_half = glm::scale(identity, glm::vec3(0.5, 0.5, 0.5));
    std::cout << "Downscale half:\n" << downscale_half << "\n";
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Identity transformation:
[ 1, 0, 0, 0,
  0, 1, 0, 0,
  0, 0, 1, 0,
  0, 0, 0, 1 ]

Downscale half:
[ 0.5, 0, 0, 0,
  0, 0.5, 0, 0,
  0, 0, 0.5, 0,
  0, 0, 0, 1 ]
#+end_src

*** Vectors

Thankfully, printing vectors is much easier since the =ostream::<<= operator defined for span can be reused.

#+name: <<glm/vec
#+begin_src cpp
template<glm::length_t Length, typename T, glm::qualifier Q>
std::ostream& operator<<(std::ostream& os, const glm::vec<Length, T, Q>& container) {
    os << to_span(container);
    return os;
}
#+end_src
#+depends:<<glm/vec :noweb <<span to_span/glm :cpp ostream

Usage:
#+begin_src cpp :eval no-export :flags -Wall -std=c++20 :noweb no-export :exports both :wrap "src text"
<<include(":noweb <<glm/vec print")>>
int main() {
    glm::vec3 xy{1, 1, 0};
    print{"Raw:", xy};
    print{"Normalised:", glm::normalize(xy)};
    glm::vec2 lo{4, 8}; glm::vec4 st{15, 16, 23, 42};
    print{lo, st};
}
#+end_src

#+RESULTS:
#+begin_src text
Raw: [1, 1, 0]
Normalised: [0.707107, 0.707107, 0]
[4, 8] [15, 16, 23, 42]
#+end_src
