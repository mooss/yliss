#+title: Octasierp-based planet generation
#+author: mooss

#+property: header-args:bash :eval never
#+property: header-args:cpp :flags -std=c++20 -Wall -I include -ldl -lGL -lglfw src/glad.c :eval never :main no :noweb no-export
#+property: header-args:glsl :noweb no-export
#+options: ^:nil

* Prelude

Where the file =octasierp.org= defined a set of primitives to manipulate octasierps, this file takes over by using those low-level primitives to render various stages of octasierp-based planets.
o craft higher-level policies that will define the shape and rendering of an octasierp.

** Inclusion

The following code block includes desired code blocks along with their dependencies.
=graphics.org= and =window.org= are systematically included because this file is dedicated to renders.

#+name: include
#+begin_src sh :var args="" :results output :wrap "src cpp" :eval no-export :minipage
./litlib/include.pl 'planet.org litlib/cpp.org octasierp.org graphics.org window.org' "$args"
#+end_src

Specialised include for =graphics.org=:
#+name: graphics
#+begin_src sh :var args="" :results output :eval no-export :minipage
./litlib/include.pl 'graphics.org' "$args"
#+end_src

Specialised include for this file:
#+name: self
#+begin_src sh :var args="" :results output :eval no-export :minipage
./litlib/include.pl 'planet.org' "$args"
#+end_src


* About octasierp policies

The notion of octasierp policy will be used to separate most of the planet-building process in three orthogonal entities:
 - Elevation policy :: Associates an elevation to each point of the octasierp.
 - Coloration policy :: Associates a color to each point of the octasierp.
 - Repartition policy :: Transforms elevations into 3d positions.

The rest of this section will not define the policies themselves but rather design tools with the following goals:
 1. Combining the policies to form an OpenGL-drawable object.
 2. Draw said object.

The first goal will be accomplished by a *growth function* and the second by a *draw function*.

** Octaform and planet properties

An =octaform= is the OpenGL-drawable object that was talked about above.
Drawing it will mainly be done via a =.vertices= and a =.indexes= properties but it will also acts as a data buffer and an exchange interface between the octasierp policies.

This type lives inside its own namespace:
#+name: octaform
#+begin_src cpp :minipage
namespace octaform_impl {
<<octaform/impl>>
}
#+end_src

*** Planet properties

Planet properties are the part of an =octaform= that will be defined at the call site of the growth function, so they are a sort of global properties that are lightweight are susceptible to be useful in different policies.

The actual content will be defined later, as needed.
#+begin_src cpp :noweb-ref octaform/impl :minipage
struct planet_properties {
    <<planet_properties/public>>
};
#+end_src

*** Base implementation

The octaform implementation is split into the base and the proper implementation.
This split was necessary because the proper implementation must store the height getter and it turns out that this height getter is produced by the elevation policy that needs the octaform in the first place in order to produce it.

To resolve this circular dependency, the height getter is produced with the base implementation, and the base's data will simply be copied over to the proper implementation.

Here is the base:
#+begin_src cpp :noweb-ref octaform/impl :minipage
class octaform_base: public pointless_octasierp {
  public:
    const planet_properties& properties;

    octaform_base(
        std::size_t degree,
        const planet_properties& _properties
    ): pointless_octasierp(degree), properties(_properties)
    {}
};
#+end_src

*** Proper implementation

The proper implementation requires a vertex size that is included in =planet_properties=.
Being in this place will allow it to be tweaked at the call site to cram more information into a vertex.
#+begin_src cpp :noweb-ref planet_properties/public :minipage
std::size_t vertex_size = 6;
#+end_src

Below is the outline of the actual implementation.
The =HeightGetter= is deliberately moved because it can amount to a wrapped vector of heights, which would be costly to copy.
#+begin_src cpp :noweb-ref octaform/impl :minipage
template<class HeightGetter>
class octaform: public octaform_base {
    HeightGetter height_;
  public:
    using height_type = typename HeightGetter::value_type;
    height_type height(auto index) const {return height_(index);}

    octaform(
        const octaform_base& base,
        HeightGetter&& height
    ): octaform_base(base),
       height_(std::move(height))
    {
        <<octaform/ctor>>
    }

    std::vector<float> vertices;
    std::vector<unsigned int> indexes;

    <<octaform/public>>
};
#+end_src
#+depends:octaform :noweb pointless_octasierp :cpp vector span utility

*** Sub-vertices getters

The methods ending with =ptr= and =span= serve to access the sub-vertices, with position and color being hardcoded as the first two sub-vertices:
#+begin_src cpp :noweb-ref octaform/public
// Static ptr and span getters.
template<std::size_t Offset>
auto offset_ptr(auto index) {
    return &vertices[properties.vertex_size * index + Offset];
}

template<std::size_t SpanSize, std::size_t Offset>
auto offset_span(auto index) {
    return std::span<float, SpanSize>(offset_ptr<Offset>(index), SpanSize);
}

auto position_ptr(auto index) {return offset_ptr<0>(index);}
auto color_ptr(auto index)    {return offset_ptr<3>(index);}
auto position_span(auto index) {return offset_span<3, 0>(index);}
auto color_span(auto index)    {return offset_span<3, 3>(index);}

// Dynamic ptr and span getters.
auto offset_ptr(auto index, auto offset) {
    return offset_ptr<0>(index) + offset;
}

template<std::size_t SpanSize>
auto offset_span(auto index, auto offset) {
    return std::span<float, SpanSize>(offset_ptr(index, offset), SpanSize);
}
#+end_src

*** Height statistics

A few statistics about heights are stored in the =octaform=:
#+begin_src cpp :noweb-ref octaform/public :minipage
struct height_stats_t {
    height_type min_height;
    height_type max_height;
    height_type sea_height;
    height_type diff_height() const {return max_height - min_height;}
};
height_stats_t stats;
#+end_src

The stats are computed upon construction.
They are not always needed, as some combinations of policies will not use them at all, and furthermore the computations could be more efficient if they were done in the height policy itself because it knows more about its own nature than the =octaform= does.
But given the time computing height statistics takes when compared to the other operations performed by the policies, implementing a mechanism to compute them efficiently and store them only as needed would be a severe case of overengineering.
#+begin_src cpp :noweb-ref octaform/ctor :minipage
stats.min_height = height(0); stats.max_height = stats.min_height;
auto end_index = point_cardinality();
for(std::size_t i = 1; i < end_index; ++i) {
    float height_i = height(i);
    if(height_i < stats.min_height) stats.min_height = height_i;
    if(height_i > stats.max_height) stats.max_height = height_i;
}
stats.sea_height = stats.min_height + stats.diff_height() * properties.sea_level;
#+end_src

*** Recapitulation

To summarise the role of =octaform=, here is a short list of what it will make available to the octasierp policies:
 - All the interface of =pointless_octasierp= (via inheritance).
 - Whatever is inside =planet_properties= (via =.properties=).
 - The height associated with a given point (via =.height=).
 - A pointer and a span to a given sub-vertex (via the =*_ptr= and =*_span= methods).
 - Some statistics (via =.stats=).

The only exception to this is, as stated above, the elevation policy that only gets access to what is in the base implementation (that is to say the first two points).

Also note that while technically policies can directly access vertices and indexes, they are not supposed to.
I'm not a fan of using encapsulation when it would make both the implementation and the usage inconvenient so I prefer to leave those attributes public.


** Octasierp growth function

=grow_octasierp= combines an elevation policy, a coloration policy and a repartition policy to generate an =octaform=.

#+name: grow_octasierp
#+begin_src cpp :minipage
namespace octaform_impl {
template<class Elevation, class Coloration, class Repartition>
auto grow_octasierp(
    std::size_t degree, Elevation elevation,
    Coloration coloration, Repartition repartition,
    const planet_properties& properties=planet_properties{}
) {
    octaform_base base(degree, properties);
    octaform ofo(base, elevation(base));

    ofo.vertices.resize(repartition.size(ofo) * properties.vertex_size, -999999.f);
    coloration.fill_colors(ofo);
    repartition.fill_positions(ofo);
    ofo.indexes = repartition.compute_indexes(ofo);
    return ofo;
}
} // namespace octaform_impl
using octaform_impl::grow_octasierp;
#+end_src
#+depends:grow_octasierp :noweb octaform :cpp utility

This implementation de-facto defines the interfaces of the elevation, coloration and repartition policies.


** Octasierp rendering function

This function's goal is to centralise octasierp rendering boilerplate while still being generic and tweakable enough to be useful for most cases.
The parameters =prerender= and =render= can be used to tweak the octasierp's state just before the first frame is rendered and at each frame.

#+name: render_octasierp
#+begin_src cpp
namespace render_octasierp_impl {
struct other_args {
    mandatory<const std::vector<float>&> vertices;
    std::vector<unsigned int> layout = {3, 3};
    mandatory<const std::vector<unsigned int>&> indexes;
    float scale=1; float camdist=3; float camlong=0; float camlat=0;
    glm::vec3 up={0, 0, 1};
    const char* screenshot=nullptr;
    const char* title="Octasierp rendering";
};

struct render_state {
    shader_unit<std::vector<float>> unit;
    orbital_camera camera;
};

template<class LambdaPreRender, class LambdaRender>
void render_octasierp(
    const shader_sources& sources, const other_args& args,
    LambdaPreRender prerender, LambdaRender render
) {
    using namespace compose;
    using namespace image;
    using namespace image::format;

    lazy_window lazy(args.title);
    orbital_camera tmp_cam(
        {0, 0, 0}, args.camdist,
        args.camlong, args.camlat, args.up
    );
    render_state state{
        shader_unit<std::vector<float>>(
            sources,
            transform().scale(args.scale),
            to_span(tmp_cam.view()),
            {.aspect=lazy.aspect()},
            {.content=*args.vertices,
             .layout=args.layout,
             .indexes=*args.indexes}
        ),
        std::move(tmp_cam)
    };
    auto sync_anchor = sync_window_size(state.unit, lazy);

    prerender(state);
    auto wrapped_render = [&]{render(state);};
    if(args.screenshot == nullptr)
        lazy.game_loop(wrapped_render);
    else {
        auto image_writer = deduce<90>::writer(square_crop{} | resize{720, 720});
        gl_screen_first(lazy, args.screenshot, image_writer, wrapped_render);
    }
}
} // namespace render_octasierp_impl
using render_octasierp_impl::render_octasierp;
#+end_src
#+depends:render_octasierp :noweb orbital_camera lazy_window shader_unit transform to_span/glm sync_window_size gl_screen_first compose image/square_crop image/resize image/format/deduce :cpp vector glm/glm.hpp

The screenshot format is deduced from the extension because while I prefer to save space with jpeg, some images have very visible jpeg artefacts.
Those are saved as png.

*** Baseline pre-render and render functions 

The lambda below can be used as a prerender that will render meshes as thick lines:
#+name: thick_lines
#+begin_src cpp :minipage
auto thick_lines = [](auto& ignore) {
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    glLineWidth(8);
};
#+end_src

This functor can be used to draw the model and make it spin every iteration at the specified angle along the specified axis:
#+name: drawspin
#+begin_src cpp :minipage
struct drawspin {
    float angle = .01;
    glm::vec3 axis = {0, 0, 1};
    void operator()(auto& state) {
        state.unit.draw();
        state.unit.with_model([this](auto& model) {
            model.rotate_rad(angle, axis);
        });
    }
};
#+end_src


* Geometric renderings

** Colored squarenet

This section will define one policy of each type with the goal of rendering a squarenet in 3d, whose coloration will illustrate the storage order of points.

*** Constant elevation

An elevation policy takes the shape of a consumer of =octaform= returning a consumer of =std::size_t= (indexes).
With a constant elevation, those parameters can be safely ignored:
#+name: constant_elevation
#+begin_src cpp :minipage
template<typename T=float>
struct constant_elevation {
    constexpr bool is_uniform() const {return true;}
    const T elevation;

    struct result_type {
        using value_type = T;
        const T elevation;
        T operator()(const auto& ignored) const {return elevation;}
    };
    auto operator()(const auto& ignored) const {
        return result_type{elevation};
    }
};
#+end_src

*** RM5CY_BNWS coloration


This coloration policy consists of using a red to magenta to cyan (5 times) to yellow gradient to color the vertices in their order of storage.
The north and south pole are respectively colored in black and white to make them stand out.
This slightly convoluted color scheme was chosen because a simpler one looks like a swastika when rendered with a squarenet repartition.

#+name: rm5cy_bnws_coloration
#+begin_src cpp :minipage
struct rm5cy_bnws_coloration {
    template<class Octaform>
    void fill_colors(Octaform& ofo) {
        rgb_interpolation<segarray, 8> gradient{
            1, 0, 0, // Red.
            1, 0, 1, // Magenta.
            0, 1, 1, // Cyan.
            0, 1, 1, // Cyan.
            0, 1, 1, // Cyan.
            0, 1, 1, // Cyan.
            0, 1, 1, // Cyan.
            1, 1, 0, // Yellow.
        };

        auto end = ofo.point_cardinality();
        for(std::size_t i = 0; i < end; ++i)
            gradient.fill(ofo.color_span(i), i, end);

        auto pole = ofo.color_span(0); pole[0] = 0; pole[1] = 0; pole[2] = 0;
        pole      = ofo.color_span(1); pole[0] = 1; pole[1] = 1; pole[2] = 1;
    }
};
#+end_src
#+depends:rm5cy_bnws_coloration :noweb rgb_interpolation segarray


*** Squarenet repartition

This repartition policy computes the positions for a 3d squarenet, with the height being used as the z component.

#+name: squarenet_repartition
#+begin_src cpp :minipage
class squarenet_repartition {
  public:
    static std::size_t side(std::size_t degree) {
        return (1 << (degree + 1)) + 1;
    }

    template<class Octaform>
    std::size_t size(const Octaform& ofo) const {
        std::size_t squarenet_side = side(ofo.degree);
        return squarenet_side * squarenet_side;
    }

    template<class Octaform> void fill_positions(Octaform& ofo) {
        <<squarenet_repartition/fill_positions>>
    }

    template<class Octaform>
    std::vector<unsigned int> compute_indexes(const Octaform& ofo) const {
        <<squarenet_repartition/compute_indexes>>
    }

  private:
    std::unordered_map<std::pair<int, int>, std::size_t> redundant_indexes_;
};
#+end_src
#+depends:squarenet_repartition :noweb hash/pair pointless_octasierp apply_foreach ForeveryCoordinates ForeachTriangle :cpp utility vector unordered_map algorithm

The difficulty in filling positions comes from the need to handle non canonical (aka redundant) coordinates.
The indexes of those coordinates are kept around in =redundant_indexes_=, because they will be needed in the next step (indexes generation).

#+name: squarenet_repartition/fill_positions
#+begin_src cpp :minipage
auto next_mirrored = ofo.point_cardinality();
float side_ = side(ofo.degree);
apply<ForeveryCoordinates>(ofo.degree, [&](auto coords) {
    std::size_t index = ofo.index_of(coords);
    if(coords.is_mirrored_canonical(ofo.degree)) { // Redundant point.
        auto canonical = ofo.position_ptr(index);
        auto dest = ofo.position_ptr(next_mirrored);
        coords.unmirror();
        redundant_indexes_[{coords.x, coords.y}] = next_mirrored++;

        // x and y can be used as is.
        dest[0] = coords.x / side_; dest[1] = coords.y / side_;
        // Height and color data must be copied over from the canonical point.
        std::copy(canonical + 2, canonical + 6, dest + 2);
    } else { // Canonical point.
        auto dest = ofo.position_ptr(index);
        dest[0] = coords.x / side_; dest[1] = coords.y / side_;
        dest[2] = ofo.height(index);
    }
});
#+end_src

Since OpenGL indexes correspond to triangles, =ForeachTriangle= is used to generate them.
As mentioned before, the map =redundant_indexes_= associates a given redundant point to its index.

#+name: squarenet_repartition/compute_indexes
#+begin_src cpp :minipage
std::vector<unsigned int> result;
result.reserve(ofo.triangle_cardinality() * 3);

apply<ForeachTriangle>(ofo.degree, [&](auto a, auto b, auto c) {
    for(auto coords: {a, b, c}) {
        std::size_t index;
        if(coords.is_mirrored_canonical(ofo.degree)) {
            coords.unmirror();
            index = redundant_indexes_.at({coords.x, coords.y});
        } else {
            index = ofo.index_of(coords);
        }
        result.push_back(index);
    }
});

return result;
#+end_src

To avoid crashes, =computes_index= depends on =fill_positions= being called before, because is needs =redundant_indexes_= to be properly constructed.
This was in fact the main inspiration for =grow_octasierp= since using it guarantees that those methods are called in the correct order.

*** Rendering

No custom shaders are needed for rendering, =graphics.org= already defines a vertex shader that applies a model, view and projection matrix to its position, as well as a fragment shader that uses a color passed as an attribute.

Constructing a mesh is now simply a matter of calling =grow_octasierp= with the desired policies:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb grow_octasierp constant_elevation rm5cy_bnws_coloration squarenet_repartition render_octasierp thick_lines drawspin")>>

int main(){
    std::size_t degree = 3;
    auto mesh = grow_octasierp(
        degree,
        constant_elevation{0},
        rm5cy_bnws_coloration{},
        squarenet_repartition{}
    );

    render_octasierp(
        {.vertex =
         <<graphics(":noweb model_view_projection_vs :c-string")>>,
         .fragment =
         <<graphics(":noweb color_as_attribute_fs :c-string")>>},
        {.vertices=mesh.vertices, .indexes=mesh.indexes,
        .camdist=1.62, .camlong=90, .camlat=0, .up={0, 1, 0},
        .screenshot="images/screencaps/gradient_squarenet.png",
        .title="Colored octanet"},
        thick_lines, drawspin{.axis={0, 1, 0}}
    );
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/gradient_squarenet.png]]
:end:

At first I wanted to use a neat multicolor gradient with two colors per quarter but because of the mirrored points, it was impossible to make it not look like a swastika.
That is why I settled on this color gradient with one red, one magenta, five cyan and one yellow.

It doesn't have this unfortunate look but still illustrates the point ordering and mirroring for quarter 0 with:
 - The six original points (and a few more) showing in red.
 - The canonical points of quarter 0 transitioning from red to magenta to cyan.
 - The orthodox points of the right border being a mirrored version of the yellow points from the end of quarter 3.


** Colored octasierp

The policies implemented in this section will allow us to render an octasierp in three dimensions, as if the render from the previous section was folded in 3d.

*** Generic index computation

For fully 3d repartition policies, indexes computation will not change as it will simply consist of using the indexes of triangles.
The function below can be used to perform this exact computation.

#+name: compute_octasierp_indexes
#+begin_src cpp :minipage
auto compute_octasierp_indexes(const pointless_octasierp& octa) {
    std::vector<unsigned int> result;
    result.reserve(octa.triangle_cardinality() * 3);
    apply<ForeachTriangle>(octa.degree, [&](auto a, auto b, auto c) {
        result.push_back(octa.index_of(a));
        result.push_back(octa.index_of(b));
        result.push_back(octa.index_of(c));
    });
    return result;
}
#+end_src
#+depends:compute_octasierp_indexes :noweb pointless_octasierp ForeachTriangle apply_foreach :cpp vector

A concise repartition policy can be made by inheriting from the following class:
#+name: octasierp_triangle_indexer
#+begin_src cpp
struct octasierp_triangle_indexer {
    template<class Octaform>
    std::size_t size(const Octaform& ofo) const {
        return ofo.point_cardinality();
    }

    template<class Octaform>
    auto compute_indexes(const Octaform& ofo) const {
        return compute_octasierp_indexes(ofo);
    }
};
#+end_src
#+depends:octasierp_triangle_indexer :noweb compute_octasierp_indexes

*** Octahedral repartition

#+name: octahedral_repartition
#+begin_src cpp :minipage
struct octahedral_repartition: public octasierp_triangle_indexer {
    template<class Octaform> void fill_positions(Octaform& ofo) {
        <<octahedral_repartition/fill_positions>>
    }
};
#+end_src
#+depends:octahedral_repartition :noweb octasierp_triangle_indexer apply_foreach ForeverySubdivision fill_midpoint/span :cpp array span

Computing positions for octahedral repartition is separated in two phases.
In the first phase, the desired height is ignored and the mesh is given a perfectly octahedral shape:
#+begin_src cpp :noweb-ref octahedral_repartition/fill_positions :minipage
auto dest = ofo.position_ptr(0); dest[0] =  0; dest[1] =  0; dest[2] =  1; // North pole.
dest      = ofo.position_ptr(1); dest[0] =  0; dest[1] =  0; dest[2] = -1; // South pole.
dest      = ofo.position_ptr(2); dest[0] =  1; dest[1] =  0; dest[2] =  0; // Corner 0.
dest      = ofo.position_ptr(3); dest[0] =  0; dest[1] =  1; dest[2] =  0; // Corner 1.
dest      = ofo.position_ptr(4); dest[0] = -1; dest[1] =  0; dest[2] =  0; // Corner 2.
dest      = ofo.position_ptr(5); dest[0] =  0; dest[1] = -1; dest[2] =  0; // Corner 3.

auto spanindex = [&](const auto& coords) {
    return ofo.position_span(ofo.index_of(coords));
};
apply<ForeverySubdivision>(ofo.degree, [&spanindex](auto& midpoint, const auto& a, const auto& b) {
    auto smid = spanindex(midpoint);
    auto sa = spanindex(a); auto sb = spanindex(b);
    fill_midpoint(smid, sa, sb);
});
#+end_src

In the second phase, the actual heights are applied to the octahedral shape.
#+begin_src cpp :noweb-ref octahedral_repartition/fill_positions :minipage
auto end = size(ofo);
for(std::size_t i = 0; i < end; ++i) {
    dest = ofo.position_ptr(i);
    auto height = ofo.height(i);
    dest[0] *= height; dest[1] *= height; dest[2] *= height;
}
#+end_src

*** Rendering

#+begin_src cpp :eval no-export :exports both :flags -std=c++20 -Wall -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb grow_octasierp constant_elevation rm5cy_bnws_coloration octahedral_repartition render_octasierp thick_lines drawspin")>>

int main() {
    std::size_t degree = 3;
    auto mesh = grow_octasierp(
        degree,
        constant_elevation{1},
        rm5cy_bnws_coloration{},
        octahedral_repartition{}
    );

    render_octasierp(
        {.vertex =
         <<graphics(":noweb model_view_projection_vs :c-string")>>,
         .fragment =
         <<graphics(":noweb color_as_attribute_fs :c-string")>>},
        {.vertices=mesh.vertices, .indexes=mesh.indexes,
         .camlong=6, .camlat=6,
         .screenshot="images/screencaps/3d_octasierp.png",
         .title="Colored octasierp"},
        thick_lines, drawspin{}
    );
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/3d_octasierp.png]]
:end:


** Pseudo-sphere

The properties of the squarenet coordinates system can be abused to first transform squarenet coordinates into spherical coordinates and then into cartesian coordinates.
By doing so, an octasierp can be inflated into a pseudo-sphere.

*** Spherical converter

The following outline of =spherical_converter= handles the easy parts of the spherical conversion, that is to say:
 1. Computing the index of interesting slices of the octasierp.
    A slice is a plan that is both orthogonal to the north-south axis and passes through points defined at the current degree.
    Slices are numbered from the northermost to the southermost, starting at 0.
    This makes the =mid_slice= correspond to the equator and the =max_slice= to the south pole.
 2. Transforming spherical coordinates to cartesian coordinates (not that I understand what is actually going on, it is easy in the sense of being the application of a magical formula).
    See https://en.wikipedia.org/wiki/Spherical_coordinate_system.
 3. Setting a few useful constants.

The more tricky part will be to convert from octasierp coordinates to spherical coordinates.

#+name: spherical_converter
#+begin_src cpp
class spherical_converter {
  public:
    const int max_slice;
    const int mid_slice;

    spherical_converter(const pointless_octasierp& octa):
        max_slice(octa.extreme_index * 2),
        mid_slice(octa.extreme_index)
    {}

    struct cartesian_coordinates {
        float x;
        float y;
        float z;
    };

    struct spherical_coordinates {
        float polar;
        float azimuth;
        auto to_cartesian(float radius) {
            return cartesian_coordinates{
                .x=radius * cosf(azimuth) * sinf(polar),
                .y=radius * sinf(azimuth) * sinf(polar),
                .z=radius * cosf(polar)
            };
        }
    };

    <<spherical_converter/public>>

  private:
    static constexpr float pi = std::numbers::pi_v<float>;
    static constexpr float half_pi = pi / 2;
    <<spherical_converter/private>>
}; // class spherical_converter
#+end_src
#+depends:spherical_converter :noweb pointless_octasierp qoords :cpp numbers cmath

=convert_raw_quarter0= converts octasierp coordinates to spherical coordinates for quarter 0 only.

The distance from the north pole corresponds to the slice number (lines parallel to the equator), which can be converted to the =polar= coordinate using the principle that the first slice corresponds to a polar value of $0\ rad$ and the last slice to a polar value of $\pi\ rad$.

In a similar way, the azimuth corresponds to the angle from the north pole, with the following angles:
 - $0\ rad$ to corner 0.
 - $\frac{\pi}{2}\ rad$ to corner 1.
 - $\pi\ rad$ to corner 2.
 - $\frac{3 \pi}{2}\ rad$ to corner 3.
The azimuth value is a bit more difficult to compute but it essentially boils down to answering the question "how far on its slice is this point located?".

The =polar= and =azimuth= values will be multiplied by $\pi$ and $\frac{\pi}{2}$ later because it is easier this way.

#+begin_src cpp :noweb-ref spherical_converter/private
spherical_coordinates convert_raw_quarter0(int abs_x, int abs_y) const {
    // Expects both coordinates to be absolute values, since this is quarter 0.
    spherical_coordinates result;
    int slice = abs_x + abs_y;
    result.polar = float(slice) / max_slice;

    if(slice > mid_slice) { // Replace southern hemisphere with northern hemisphere equivalent.
        abs_x = mid_slice - abs_x;
        abs_y = mid_slice - abs_y;
        std::swap(abs_x, abs_y);
        slice = max_slice - slice;
    }

    if(abs_x >= abs_y) {
        if(abs_x == 0)
            result.azimuth = 0;
        else
            result.azimuth = float(abs_y) / slice;
    } else
        result.azimuth = 1 - float(abs_x) / slice;

    return result;
}
#+end_src

The user-facing method below uses the fact that quarter 1, 2 and 3 are left rotations of quarter 0 to compute the correct azimuth.

#+begin_src cpp :noweb-ref spherical_converter/public :minipage
template<int Quarter>
spherical_coordinates convert(qoords<Quarter>& coords) const {
    auto coords_q0 = qoords<0>::from<Quarter>(coords.x, coords.y);
    spherical_coordinates result = convert_raw_quarter0(coords_q0.x, coords_q0.y);
    result.azimuth += Quarter; // Quarter is the number of left rotations from quarter 0.
    result.azimuth *= half_pi;
    result.polar *= pi;
    return result;
}
#+end_src

Redirection operator:
#+name: <<spherical_coordinates
#+begin_src cpp :minipage
std::ostream& operator<<(
    std::ostream& os, const spherical_converter::spherical_coordinates& c
) {
    return os << "(polar=" << c.polar << ", azimuth=" << c.azimuth << ")";
}
#+end_src
#+depends:<<spherical_coordinates :noweb spherical_converter :cpp iostream

*** Spherical repartition

With its brutal use of lambdas and =reinterpret_cast=, =spherical_repartition= can fill pseudo-spherical coordinates for a whole octasierp.
The addresses returned by =get_dest= must point to three continuous floats whose ordering corresponds to x, y and z coordinates.

#+name: spherical_repartition
#+begin_src cpp :minipage
struct spherical_repartition: public octasierp_triangle_indexer {
    template<class Octaform> void fill_positions(Octaform& ofo) {
        using sphc = spherical_converter::cartesian_coordinates;
        spherical_converter to_spherical(ofo);
        apply<ForeachCoordinates>(ofo.degree, [&](auto coords) {
            auto index = ofo.index_of(coords);
            *reinterpret_cast<sphc*>(ofo.position_ptr(index)) = to_spherical.convert(coords).to_cartesian(ofo.height(index));
        });
    }
};
#+end_src
#+depends:spherical_repartition :noweb octasierp_triangle_indexer spherical_converter ForeachCoordinates

*** Rendering

#+begin_src cpp :eval no-export :exports both :flags -std=c++20 -Wall -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb grow_octasierp constant_elevation rm5cy_bnws_coloration spherical_repartition render_octasierp thick_lines drawspin")>>

int main() {
    std::size_t degree = 3;
    auto mesh = grow_octasierp(
        degree,
        constant_elevation{1},
        rm5cy_bnws_coloration{},
        spherical_repartition{}
    );

    render_octasierp(
        {.vertex =
         <<graphics(":noweb model_view_projection_vs :c-string")>>,
         .fragment =
         <<graphics(":noweb color_as_attribute_fs :c-string")>>},
        {.vertices=mesh.vertices, .indexes=mesh.indexes,
         .camlong=6, .camlat=6,
         .screenshot="images/screencaps/spherical_octasierp.png",
         .title="Pseudo-spherical octasierp"},
         thick_lines, drawspin{}
    );
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/spherical_octasierp.png]]
:end:


* Midpoint displacement and height coloration

** Accidented landscape with midpoint displacement

The general principle of midpoint displacement consist of computing heights by starting from a few origin points.
Then the heights of a midpoint (a new point between some of those origin points) can be calculated by averaging the heights of its origins and adding a random (but controlled) amount.
This processus can generate an accidented landscape, reminding of mountaineous terrain.

*** Midpoint displacement adapted to octasierps

When adapted to an octasierp, the midpoint displacement algorithm gives better results with an additional initialisation phase, during which all height computations are independant, i.e. no midpoints are used.

This initialisation phase is represented by the parameter =init_degree=, the last degree whose height is independant of its surroundings, this parameter should be smaller or equal to the actual degree of the octasierp.
The =seed= parameter is used to initialise the random number generator, =average= is the initial height and =range= corresponds to the greatest variation of height possible.
With the default values, this means that the height will vary between 0.965 and 1.035.

#+name: midpoint_displacement_octasierp
#+begin_src cpp :minipage
namespace midpoint_octasierp_impl {
struct kwargs {
    mandatory<std::size_t> init_degree;
    unsigned int seed=162342;
    float average=1; float range=.07;
};
auto midpoint_displacement_octasierp(const pointless_octasierp& octa, const kwargs& args) {
    auto init_degree = *args.init_degree;
    if(init_degree > octa.degree) // Avoid overflows in the initialisation phase.
        init_degree = octa.degree;

    std::vector<float> result(octa.point_cardinality(), -999999);
    <<midpoint_displacement_octasierp/impl>>
    return result;
}
}
using midpoint_octasierp_impl::midpoint_displacement_octasierp;
#+end_src
#+depends:midpoint_displacement_octasierp :noweb mandatory pointless_octasierp ForeachSpontaneous ForeachSubdivision apply_foreach degree_shifter :cpp random
\\
To keep some coherence in the generated heights, the further the algorithm progresses, the smaller the random element must be.
Another way to formulate this is the closer the points are, the smaller their average height difference must be, otherwise the heights might as well be fully randomised.
The approach adopted here is analogous to dividing the range by two:
#+begin_src cpp :noweb-ref midpoint_displacement_octasierp/impl :minipage
auto make_distribution = [&args](std::size_t shift) {
    auto delta = args.range / (2 << shift);
    return std::uniform_real_distribution<float>(-delta, delta);
};
#+end_src
\\
As mentioned before, during the initialisation phase, the points heights are kept independant:
#+begin_src cpp :noweb-ref midpoint_displacement_octasierp/impl :minipage
std::mt19937_64 engine(args.seed);
auto distrib = make_distribution(0);
for(std::size_t current = 0; current <= init_degree; ++current) {
    apply<ForeachSpontaneous>(
        current,
        degree_shifter(octa.degree - current, [&](auto coords) {
            result[octa.index_of(coords)] = args.average + distrib(engine);
        })
    );
}
#+end_src
\\
The proper midpoint displacement occurs here, using =ForeachSubdivision=, with the random height displacement getting smaller each new degree.
#+begin_src cpp :noweb-ref midpoint_displacement_octasierp/impl :minipage
auto middisp_algorithm = [&](auto midpoint, auto a, auto b) {
    result[octa.index_of(midpoint)] =
        (result[octa.index_of(a)] + result[octa.index_of(b)]) / 2 + distrib(engine);
};
for(std::size_t parent = init_degree; parent < octa.degree; ++parent) {
    distrib = make_distribution(parent - init_degree + 1);
    apply<ForeachSubdivision>(
        parent,
        degree_shifter(octa.degree - parent - 1, middisp_algorithm)
    );
}
#+end_src

*** Midpoint elevation (policy)

Here is an implementation of the elevation policy relying on the midpoint displacement function shown above.

#+name: midpoint_elevation
#+begin_src cpp
struct midpoint_elevation {
    constexpr bool is_uniform() const {return false;}
    const midpoint_octasierp_impl::kwargs& args;

    struct result_type {
        using value_type = float;
        const std::vector<float> storage;
        float operator()(const auto index) const {
            return storage[index];
        }
    };

    template<class Octaform>
    auto operator()(const Octaform& ofo) const {
        return result_type{midpoint_displacement_octasierp(ofo, args)};
    }
};
#+end_src
#+depends:midpoint_elevation :noweb midpoint_displacement_octasierp :cpp vector

*** Rendering

#+begin_src cpp :eval no-export :exports both :flags -std=c++20 -Wall -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb grow_octasierp midpoint_elevation rm5cy_bnws_coloration spherical_repartition render_octasierp thick_lines drawspin")>>

int main() {
    std::size_t degree = 3;
    auto mesh = grow_octasierp(
        degree,
        midpoint_elevation{{.init_degree=0, .range=.3}},
        rm5cy_bnws_coloration{},
        spherical_repartition{}
    );

    render_octasierp(
        {.vertex =
         <<graphics(":noweb model_view_projection_vs :c-string")>>,
         .fragment =
         <<graphics(":noweb color_as_attribute_fs :c-string")>>},
        {.vertices=mesh.vertices, .indexes=mesh.indexes,
         .camlong=6, .camlat=6,
         .screenshot="images/screencaps/spherical_midpoint_octasierp.png",
         .title="Midpoint-displaced pseudo-spherical octasierp"},
         thick_lines, drawspin{}
    );
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/spherical_midpoint_octasierp.png]]
:end:


** Height coloration

*** Scale translation

Because adjusting the sea level is a feature of this project, a planetary color scheme must be separated in two, a color scheme for the terrain above the sea and another for the terrain below:
#+name: planetary_color_scheme
#+begin_src cpp
struct planetary_color_scheme {
    rgb_scaled_interpolation<float> below_sea;
    rgb_scaled_interpolation<float> above_sea;
};
#+end_src
#+depends:planetary_color_scheme :noweb rgb_scaled_interpolation

The hard work of height coloration is done by =rgb_scaled_interpolation=, aka the color scheme.
The function below only does a small adaptation of each color scheme and checks the actual height to see whether one or the other shoud be applied to a given index.

#+name: height_coloration_octasierp
#+begin_src cpp :minipage
template<class Octaform>
void height_coloration_octasierp(
    Octaform& ofo, const planetary_color_scheme& color_scheme
) {
    auto below = color_scheme.below_sea;
    auto above = color_scheme.above_sea;
    transform_scaled_interpolation(below, ofo.stats.min_height, ofo.stats.sea_height);
    transform_scaled_interpolation(above, ofo.stats.sea_height, ofo.stats.max_height);
    auto end_index = ofo.point_cardinality();

    for(std::size_t i = 0; i < end_index; ++i) {
        auto height = ofo.height(i);
        if(height <= ofo.stats.sea_height)
            below.fill(ofo.color_span(i), height);
        else
            above.fill(ofo.color_span(i), height);
    }
}
#+end_src
#+depends:height_coloration_octasierp :noweb pointless_octasierp planetary_color_scheme transform_scaled_interpolation

Note that the function above depends on the =sea_level= property that must be added to =planet_properties=:

#+begin_src cpp :noweb-ref planet_properties/public :minipage
float sea_level = .5;
#+end_src

*** GFG Color scheme

The color scheme below was adapted from godefarig, my previous procedural planet generator.
#+name: gfg_color_scheme
#+begin_src cpp :minipage
planetary_color_scheme gfg_color_scheme{
    .below_sea = {{
        {0, {0, 0, 0}},     // black
        {15, {0, 0, .07}},  // abyss
        {73, {0, .05, .3}}, // deep waters
        {90, {0, .6, .9}}   // surface waters
    }}, .above_sea = {{
        {0, {0, .6, .9}},      // continuation of surface waters
        {8, {.05, .28, .05}},  // light green
        {12, {.05, .28, .05}}, // light green
        {16, {.1, .23, .1}},   // dark green
        {20, {.06, .2, .05}},  // darker green
        {28, {.02, .1, 0}},    // darkest green
        {34, {.28, .12, .08}}, // mountain (light dirt)
        {38, {.2, .1, .05}},   // mountain (dirt)
        {50, {.2, .2, .2}},    // mountain (rock)
        {90, {1, 1, 1}}        // snow
    }}
};
#+end_src
#+depends:gfg_color_scheme :noweb planetary_color_scheme

*** Policy

#+name: height_coloration
#+begin_src cpp
struct height_coloration {
    const planetary_color_scheme& color_scheme;

    template<class Octaform>
    void fill_colors(Octaform& ofo) {
        height_coloration_octasierp(ofo, color_scheme);
    }
};
#+end_src
#+depends:height_coloration :noweb planetary_color_scheme height_coloration_octasierp :cpp array

*** Rendering

This first rendering uses the same parameter as the previous ones, but with height coloration.
#+begin_src cpp :eval no-export :exports both :flags -std=c++20 -Wall -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb grow_octasierp midpoint_elevation height_coloration gfg_color_scheme spherical_repartition render_octasierp thick_lines nothing drawspin")>>

int main() {
    std::size_t degree = 3;
    auto mesh = grow_octasierp(
        degree,
        midpoint_elevation{{.init_degree=0, .range=.3}},
        height_coloration{gfg_color_scheme},
        spherical_repartition{}
    );

    render_octasierp(
        {.vertex =
         <<graphics(":noweb model_view_projection_vs :c-string")>>,
         .fragment =
         <<graphics(":noweb color_as_attribute_fs :c-string")>>},
        {.vertices=mesh.vertices, .indexes=mesh.indexes,
         .camlong=6, .camlat=6,
         .screenshot="images/screencaps/gfgocta_deg3_wireframe.png",
         .title="Midpoint-displaced height-colored pseudo-spherical octasierp"},
         thick_lines, drawspin{}
    );
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/gfgocta_deg3_wireframe.png]]
:end:


Since height coloration at degree 3 is not very impressive, the code below renders at degree 8, with triangles instead of wireframe and with better midpoint displacement parameters:
#+begin_src cpp :eval no-export :exports both :flags -std=c++20 -Wall -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb grow_octasierp midpoint_elevation height_coloration gfg_color_scheme spherical_repartition render_octasierp nothing drawspin")>>

int main() {
    std::size_t degree = 8;
    auto mesh = grow_octasierp(
        degree,
        midpoint_elevation{{.init_degree=3}},
        height_coloration{gfg_color_scheme},
        spherical_repartition{},
        {.sea_level=.6}
    );

    render_octasierp(
        {.vertex =
         <<graphics(":noweb model_view_projection_vs :c-string")>>,
         .fragment =
         <<graphics(":noweb color_as_attribute_fs :c-string")>>},
        {.vertices=mesh.vertices, .indexes=mesh.indexes,
         .camlong=6, .camlat=6,
         .screenshot="images/screencaps/gfgocta_deg8_triangles.jpg",
         .title="Midpoint-displaced height-colored pseudo-spherical octasierp"},
        nothing, drawspin{.angle=.005, .axis={0, 1, 1}}
    );
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/gfgocta_deg8_triangles.jpg]]
:end:


* Refinements

** Phong shading

Phong shading is a way to approximate lighting via 3 components, ambient, diffuse and specular.
An mandatory prerequisite of Phong shading is vertices normals, they must therefore be computed and send to a new shader program implementing Phong shading.

The shaders implemented here were adapted from the basic lightning page of =learnopengl.com= (https://learnopengl.com/Lighting/Basic-Lighting).

*** Computation of normals

The normals will be directly written to the octaform via =fill_octasierp_normals=.

#+name: fill_octasierp_normals
#+begin_src cpp
namespace yls_normal_computation {
<<yls_normal_computation/scope>>

template<class Octaform>
void fill_octasierp_normals(Octaform& ofo, std::size_t normal_offset) {
    <<fill_octasierp_normals/scope>>
}
} // namespace yls_normal_computation
using yls_normal_computation::fill_octasierp_normals;
#+end_src
#+depends:fill_octasierp_normals :cpp array vector glm/glm.hpp

To compute the vertices normals, the first step will be to compute the triangles normals and, for each vertex to record which triangles it is a part of, in an instance of =neighbouring_normals=:
#+begin_src cpp :noweb-ref yls_normal_computation/scope
struct neighbouring_normals {
    std::array<int, 6> indexes = {-1, -1, -1, -1, -1, -1};
    char next = 0;
    void push(auto index) {
        indexes[next++] = index;
    }
};
#+end_src

Triangle normals are computed via a cross product of two of its edges:
#+begin_src cpp :noweb-ref fill_octasierp_normals/scope
std::vector<neighbouring_normals> adjacent(ofo.point_cardinality());

auto position_as_vec3 = [&ofo](auto index) {
    return *reinterpret_cast<glm::vec3*>(ofo.position_ptr(index));
};

auto tricard = ofo.triangle_cardinality();
std::vector<glm::vec3> triangle_normals(tricard);
for(std::size_t i = 0; i < tricard; ++i) {
    auto i3 = 3 * i;
    auto a = ofo.indexes[i3]; auto b = ofo.indexes[i3 + 1]; auto c = ofo.indexes[i3 + 2];
    adjacent[a].push(i); adjacent[b].push(i); adjacent[c].push(i);
    triangle_normals[i] = glm::cross(
        position_as_vec3(b) - position_as_vec3(a),
        position_as_vec3(c) - position_as_vec3(a)
    );
}
#+end_src

The normal of a vertex is implemented here as the normalised sum of the normals of neighbouring triangles:
#+begin_src cpp :noweb-ref fill_octasierp_normals/scope
for(std::size_t i = 0; i < adjacent.size(); ++i) {
    auto dest_ptr = reinterpret_cast<glm::vec3*>(ofo.offset_ptr(i, normal_offset));
    auto neighbours = adjacent[i];
    auto normal = [&](auto index) {return triangle_normals[neighbours.indexes[index]];};
    if(neighbours.indexes[4] == -1) // Initial point (poles and corners).
        *dest_ptr = glm::normalize(normal(0) + normal(1) + normal(2) + normal(3));
    else // 6-neighbours point.
        *dest_ptr = glm::normalize(
            normal(0) + normal(1) + normal(2) +
            normal(3) + normal(4) + normal(5)
        );
}
#+end_src

*** Vertex shader

#+name: phong_vs
#+begin_src glsl
#version 330 core
layout (location = 0) in vec3 position;
layout (location = 1) in vec3 color;
layout (location = 2) in vec3 normal;

out vec3 position_fs;
out vec3 color_fs;
out vec3 normal_fs;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform mat3 normal_model;

void main() {
    gl_Position = projection * view * model * vec4(position, 1.0f);
    position_fs = vec3(model * vec4(position, 1));
    color_fs = color;
    normal_fs = normal_model * normal;
}
#+end_src

*** Fragment shader

Since this fragment shader uses a lot of global state and needs to share calculations via more global variables, a literate programming style is kinda unwieldy, but I will still try.

The global variables in question are =normal= and =surface_to_light=:
#+name: gl-normal
#+begin_src glsl
vec3 normal = normalize(normal_fs);
#+end_src

#+name: gl-surface_to_light
#+begin_src glsl
vec3 surface_to_light = normalize(light_position - position_fs);
#+end_src

The ambient, diffuse and specular components are defined as functions:
#+name: gl-ambient
#+begin_src glsl
float ambient() {
    return ambient_strength;
}
#+end_src

#+name: gl-diffuse
#+begin_src glsl
float diffuse() {
    return max(dot(normal, surface_to_light), 0);
}
#+end_src
#+depends:gl-diffuse :noweb gl-normal gl-surface_to_light

#+name: gl-specular
#+begin_src glsl
float specular() {
    vec3 surface_to_camera = normalize(camera_position - position_fs);
    vec3 reflection_dir = reflect(-surface_to_light, normal);
    float specular_coeff = pow(max(dot(surface_to_camera, reflection_dir), 0), specular_exponent);
    return specular_strength * specular_coeff;
}
#+end_src
#+depends:gl-specular :noweb gl-surface_to_light gl-normal

It bothers me that, when summed, the ambient and diffuse brightness can go above 1 (when $diffuse > 1 - ambient\_strength$).
Even though this is not a concern I have seen elsewhere, I've made the =amfuse= function to combine diffuse and ambient in a way that cannot go above 1.
#+name: gl-amfuse
#+begin_src cpp
float amfuse() {
    return ambient_strength + (1 - ambient_strength) * diffuse();
}
#+end_src
#+depends:gl-amfuse :noweb gl-diffuse

To work properly, the final fragment shader must define all the necessary global variables:
#+name: phong_fs
#+begin_src glsl
#version 330 core
out vec4 color_out;
in vec3 position_fs;
in vec3 color_fs;
in vec3 normal_fs;

uniform vec3 light_color = vec3(1, 1, 1);
uniform vec3 light_position = vec3(6, 5, -2);
uniform vec3 camera_position;
uniform float ambient_strength = .07;
uniform float specular_strength = .5;
uniform float specular_exponent = 64;

<<include(":noweb gl-amfuse gl-specular")>>

void main() {
    color_out = vec4((amfuse() + specular()) * color_fs * light_color, 1);
}
#+end_src

*** Prerender function

Phong lighting needs both the camera position and the normal model matrix to be sent to the shaders.
The normal model matrix will be automatically kept up to date with the model matrix by =shader_unit=.
The camera position will not be kept up to date, but that is not a problem right now because the camera is static.

#+name: prerender_phong
#+begin_src cpp
auto prerender_phong = [](auto& state) {
    auto position = state.camera.position();
    state.unit.template send<uniform_3f>("camera_position", position.x, position.y, position.z);
    state.unit.send_normal_model();
};
#+end_src

*** Rendering

The specular component is much too strong and makes the planet looks like it is made of plastic but I love the shinyness of this effect (it's made more obvious by the rotation so it's not as shocking in the capture below).

#+begin_src cpp :eval no-export :exports both :flags -std=c++20 -Wall -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb grow_octasierp midpoint_elevation height_coloration gfg_color_scheme spherical_repartition fill_octasierp_normals uniform_3f render_octasierp prerender_phong drawspin")>>

int main() {
    std::size_t degree = 8;
    auto mesh = grow_octasierp(
        degree,
        midpoint_elevation{{.init_degree=3}},
        height_coloration{gfg_color_scheme},
        spherical_repartition{},
        {.vertex_size=9, .sea_level=.6}
    );

    fill_octasierp_normals(mesh, 6);

    render_octasierp(
        {.vertex =
         <<self(":noweb phong_vs :c-string")>>,
         .fragment =
         <<self(":noweb phong_fs :c-string")>>},
        {.vertices=mesh.vertices, .layout={3, 3, 3}, .indexes=mesh.indexes,
         .camlong=6, .camlat=6,
         .screenshot="images/screencaps/gfgocta_phong.jpg",
         .title="Midpoint-displaced height-colored pseudo-spherical Phong-shaded octasierp"},
        prerender_phong, drawspin{.angle=.005, .axis={0, 1, 1}}
    );
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/gfgocta_phong.jpg]]
:end:


** Surface waters

The goal of this section is to make the octasierp look more like a planet by keeping the coloration intact but rendering the water at the surface level rather than at their actual depth, as if there were oceans and seas covering the planet.

*** Repartition policy wrapper

The trick used to implement surface waters is to change the behaviour of a given type by inheriting from it and highjacking the method encoding said behaviour.

First, =regular= highjacks the original =octaform= so that its height method never returns less than the sea level:
#+begin_src cpp :noweb-ref surface_waters_impl/scope
template<class Octaform>
struct regular: public Octaform {
    using height_type = typename Octaform::height_type;
    height_type height(auto index) const {
        height_type result = Octaform::height(index);
        if(result < Octaform::stats.sea_height)
            return Octaform::stats.sea_height;
        return result;
    }
};
#+end_src

Then, =surface_waters= highjacks the repartition policy so that its =fill_position= consumes the =octaform= wrapped by =regular=:
#+begin_src cpp :noweb-ref surface_waters_impl/scope
template<class Repartition, template <class> class Wrapper=regular>
struct surface_waters: public Repartition {
    surface_waters(const Repartition& rep):
        Repartition(rep)
    {}

    template<class Octaform> void fill_positions(Octaform& ofo) {
        Repartition::fill_positions(*reinterpret_cast<Wrapper<Octaform>*>(&ofo));
    }
};
#+end_src

By implementing surface waters this way, only the repartition policy is affected, therefore having no influence on the coloration policy and the colors it produces, which would not be the case if the elevation policy was directly modified.

Only =surface_waters= is made available to the global namespace:
#+name: surface_waters
#+begin_src cpp
namespace surface_waters_impl {
<<surface_waters_impl/scope>>
} // namespace surface_waters_impl
using surface_waters_impl::surface_waters;
#+end_src

*** Rendering

Applying =surface_waters= to the spherical repartition policy makes the rendering look a bit more like a planet:
#+begin_src cpp :eval no-export :exports both :flags -std=c++20 -Wall -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb grow_octasierp midpoint_elevation height_coloration gfg_color_scheme surface_waters spherical_repartition fill_octasierp_normals uniform_3f render_octasierp prerender_phong drawspin")>>

int main() {
    std::size_t degree = 8;
    auto mesh = grow_octasierp(
        degree,
        midpoint_elevation{{.init_degree=3}},
        height_coloration{gfg_color_scheme},
        surface_waters(spherical_repartition{}),
        {.vertex_size=9, .sea_level=.6}
    );

    fill_octasierp_normals(mesh, 6);

    render_octasierp(
        {.vertex =
         <<self(":noweb phong_vs :c-string")>>,
         .fragment =
         <<self(":noweb phong_fs :c-string")>>},
        {.vertices=mesh.vertices, .layout={3, 3, 3}, .indexes=mesh.indexes,
         .camlong=6, .camlat=6,
         .screenshot="images/screencaps/gfgocta_phong_surface-waters_spherical.jpg",
         .title="Midpoint-displaced height-colored pseudo-spherical surface-watered Phong-shaded octasierp"},
        prerender_phong, drawspin{.angle=.005, .axis={0, 1, 1}}
    );
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/gfgocta_phong_surface-waters_spherical.jpg]]
:end:

It also works for octahedral repartition:
#+begin_src cpp :eval no-export :exports both :flags -std=c++20 -Wall -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb grow_octasierp midpoint_elevation height_coloration gfg_color_scheme surface_waters octahedral_repartition fill_octasierp_normals uniform_3f render_octasierp prerender_phong drawspin")>>

int main() {
    std::size_t degree = 8;
    auto mesh = grow_octasierp(
        degree,
        midpoint_elevation{{.init_degree=3, .range=.14}},
        height_coloration{gfg_color_scheme},
        surface_waters(octahedral_repartition{}),
        {.vertex_size=9, .sea_level=.6}
    );

    fill_octasierp_normals(mesh, 6);

    render_octasierp(
        {.vertex =
         <<self(":noweb phong_vs :c-string")>>,
         .fragment =
         <<self(":noweb phong_fs :c-string")>>},
        {.vertices=mesh.vertices, .layout={3, 3, 3}, .indexes=mesh.indexes,
         .camdist=2.8, .camlong=6, .camlat=6,
         .screenshot="images/screencaps/gfgocta_phong_surface-waters_octahedral.jpg",
         .title="Midpoint-displaced height-colored octahedral surface-watered Phong-shaded octasierp"},
        prerender_phong, drawspin{.angle=.005, .axis={0, 1, 1}}
    );
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/gfgocta_phong_surface-waters_octahedral.jpg]]
:end:


** Cel shading

This is an attempt at cel-shaded rendering of a planet.
Outlines are not implemented yet.

*** Water surface perturbation

When the water is perfectly at the surface level, the specularity component is much too regular and visible, ruining the image.
The solution to this is to keep some roughness in the water surface, rather than making it completely spherical.

The precise implementation trick used here is to divide by a constant factor the height difference a given point has with the sea height, rather than simply returning the sea height.

#+name: bumpy_surface_waters
#+begin_src cpp
namespace bumpy_surface_waters_impl {
template<int Divider>
struct divider {
    template<class Octaform>
    struct bumpy: public Octaform {
        using height_type = typename Octaform::height_type;
        height_type height(auto index) const {
            height_type result = Octaform::height(index);
            if(result < Octaform::stats.sea_height) {
                return Octaform::stats.sea_height + (Octaform::stats.sea_height - result) / Divider;
            }
            return result;
        }
    };
};
}
template<int Divider>
struct bumpy {
    template<class Repartition>
    using surface_waters = surface_waters<Repartition, bumpy_surface_waters_impl::divider<Divider>::template bumpy>;
};
#+end_src
#+depends:bumpy_surface_waters :noweb surface_waters

*** Brightness step

Part of the cartoon effect of cel shading is achieved by using stepped levels of brightness.
This is handled here by two functions, one for the diffuse component, the other for the specular component.

#+name: gl-cel_step_diffuse
#+begin_src glsl
float cel_step_diffuse(float brightness) {
    if(brightness < .6) {
        if(brightness < .3)    brightness = ambient_strength;
        else                   brightness = .4;
    } else if(brightness < .9) brightness = .75;
    else                       brightness = 1;
    return brightness;
}
#+end_src

The step function for the specular component is not continuous for the most luminous values.
This is not much different but I like it this way.

#+name: gl-cel_step_specular
#+begin_src glsl
float cel_step_specular(float brightness) {
    if(brightness < .3)      brightness = 0;
    else if(brightness < .7) brightness = .4;
    return brightness;
}
#+end_src

*** Fragment shader

The specular component renders much better when just ignoring the color of the fragment.

The ambient component, though not present explicitely, is represented by virtue of =ambient_strength= being the absolute minimal value of =cel_step_diffuse=.

#+name: cel_fs
#+begin_src glsl
#version 330 core
out vec4 color_out;
in vec3 position_fs;
in vec3 color_fs;
in vec3 normal_fs;

uniform vec3 light_color = vec3(1, 1, 1);
uniform vec3 light_position = vec3(6, 5, -2);
uniform float ambient_strength = .1;

// For specular only.
uniform vec3 camera_position;
uniform float specular_strength = .8;
uniform float specular_exponent = 128;

<<include(":noweb gl-diffuse gl-specular gl-cel_step_diffuse gl-cel_step_specular")>>

void main() {
    color_out = vec4(cel_step_diffuse(diffuse()) * color_fs * light_color
                     + cel_step_specular(specular()) * light_color, 1);
}
#+end_src

*** Rendering

#+begin_src cpp :eval no-export :exports both :flags -std=c++20 -Wall -I include -ldl -lGL -lglfw src/glad.c :tangle cel.cpp
<<include(":noweb print grow_octasierp midpoint_elevation height_coloration gfg_color_scheme bumpy_surface_waters spherical_repartition fill_octasierp_normals uniform_3f render_octasierp prerender_phong drawspin")>>

int main() {
    std::size_t degree = 8;
    auto mesh = grow_octasierp(
        degree,
        midpoint_elevation{{.init_degree=3}},
        height_coloration{gfg_color_scheme},
        bumpy<6>::surface_waters(spherical_repartition{}),
        {.vertex_size=9, .sea_level=.6}
    );

    fill_octasierp_normals(mesh, 6);

    render_octasierp(
        {.vertex =
         <<self(":noweb phong_vs :c-string")>>,
         .fragment =
         <<self(":noweb cel_fs :c-string")>>},
        {.vertices=mesh.vertices, .layout={3, 3, 3}, .indexes=mesh.indexes,
         // camlong is less than usual to focus the specular component on a more interesting spot.
         .camlong=-6, .camlat=6,
         .screenshot="images/screencaps/gfgocta_cel_without_outlines.jpg",
         .title="Cel shading without outlines"},
        prerender_phong, drawspin{.angle=.003, .axis={0, 1, 1}}
    );
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/gfgocta_cel_without_outlines.jpg]]
:end:
