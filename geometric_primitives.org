#+title: C++ OpenGL geometric primitives
#+author: mooss

# No :wrap for this file because I can't disable it when I need to (uniform generation).
# :exports both does not work with pandoc when set at this level, it must be set manually in the code block header-args.
#+property: header-args :eval never :main no :exports both :noweb no-export
#+property: header-args:cpp+ :flags -std=c++20 -I include -ldl -lGL -lglfw src/glad.c

* Prelude :noexport:

** Inclusion

#+name: include
#+begin_src sh :var args="" :results output :wrap "src cpp" :eval no-export
./litlib/include.pl "window.org litlib/cpp.org geometric_primitives.org" "$args"
#+end_src

Specialised block for shaders (makes things slightly more readable):

#+name: shader
#+begin_src bash :var noweb="" :results output :wrap "src text" :eval no-export
./litlib/include.pl "geometric_primitives.org" ":noweb $noweb :c-string"
#+end_src

** Log the output of OpenGL commands

With the help of some pretty awesome black magic, =sed= can be used to replace OpenGL calls with a logging call via =LOG_AND_CALL=.

First, the following code block (from https://stackoverflow.com/a/66090390) must be executed:
#+begin_src emacs-lisp :eval no-export :results silent
(defun shell-command-on-buffer (command)
  ;; (interactive)
  (let ((line (line-number-at-pos)))
    ;; replace buffer with output of shell command
    (shell-command-on-region (point-min) (point-max) command nil t)
    ;; restore cursor position
    (goto-line line)
    (recenter-top-bottom)))
#+end_src

Then execute the following elisp command via =C-x C-e=:
(shell-command-on-buffer "sed -r 's| (gl[a-zA-Z]+[^(]+)\\(| LOG_AND_CALL(\\1, |'")
There is a space at the beginning of the regex to avoid matching initialisation lists.

Regex to transform logging calls back to plain opengl calls:
(shell-command-on-buffer "sed -r 's|LOG_AND_CALL\\((gl[a-zA-Z]+[^,]+), |\\1(|'")

I had to resort to sed because I'm not a fan of  Emacs' regexes.
To adapt the regexes above, remember that backslashes must be escaped because they are in an elisp string.

It should be possible to make the logging calls work for initialisation lists by adding a templated =log_and_call= function.


* OpenGL objects

Here are defined various OpenGL objects that let us draw things.
I'm a bit lax with the dependencies declaration here because technically the blocks here are using OpenGL functions but they are not supposed to include those functions themselves.

What's implied here is that the user of the code blocks below knows what to expect and is using them in the proper context, that is to say after window has been included.

I tried to make as many things =const= as possible for those OpenGL primitives, this way once the objects are constructed, they are set in stone and annoying mistakes can be avoided.
Of course, those things will be "unconsted" when needed.

** Shader

Apparently, shaders are supposed to be deleted once they are linked, hence the custom desctuctor.

#+name: shader_base
#+begin_src cpp
class shader {
  public:
    const GLuint id;

    ~shader() {
        glDeleteShader(id);
    }

  protected:
    shader(const char* source, int type):
        id(glCreateShader(type))
    {
        glShaderSource(id, 1, &source, nullptr);
        glCompileShader(id);
        ensure_success();
    }

    bool compiled() const {
        int success;
        glGetShaderiv(id, GL_COMPILE_STATUS, &success);
        return success;
    }

    std::string info_log() const {
        char buffer[512];
        glGetShaderInfoLog(id, 512, nullptr, buffer);
        return std::string(buffer, 512);
    }

    void ensure_success() {
        if(!compiled()) {
            throw std::runtime_error(info_log());
        }
    }
};
#+end_src
#+depends:shader_base :cpp string stdexcept

*** Vertex shader

#+name: vertex_shader
#+begin_src cpp
struct vertex_shader: public shader {
    vertex_shader(const char* source): shader(source, GL_VERTEX_SHADER) {}
};
#+end_src
#+depends:vertex_shader :noweb shader_base

*** Fragment shader

#+name: fragment_shader
#+begin_src cpp
struct fragment_shader: public shader {
    fragment_shader(const char* source): shader(source, GL_FRAGMENT_SHADER) {}
};
#+end_src
#+depends:fragment_shader :noweb shader_base

*** Shader program

#+name: shader_program
#+begin_src cpp
class shader_program {
  public:
    shader_program(const vertex_shader& vs, const fragment_shader& fs):
        id(glCreateProgram())
    {
        glAttachShader(id, vs.id);
        glAttachShader(id, fs.id);
        glLinkProgram(id);
        ensure_success();
    }

    void use() const {
        glUseProgram(id);
    }

    const GLuint id;

  private:
    bool linked() const {
        int success;
        glGetProgramiv(id, GL_LINK_STATUS, &success);
        return success;
    }

    std::string info_log() const {
        char buffer[512];
        glGetProgramInfoLog(id, 512, nullptr, buffer);
        return std::string(buffer, 512);
    }

    void ensure_success() {
        if(!linked()) {
            throw std::runtime_error(info_log());
        }
    }
};
#+end_src
#+depends:shader_program :noweb fragment_shader vertex_shader :cpp stdexcept


** Buffers

#+name: opengl_buffer
#+begin_src cpp
class opengl_buffer {
  protected:
    template<typename T>
    void send(const std::span<const T> data) const {
        glBindBuffer(target(), id_);
        glBufferData(target(), data.size() * sizeof(T), data.data(), GL_STATIC_DRAW);
    }

    opengl_buffer() : id_(generate()) {}

    virtual GLenum target() const=0;

  private:
    const GLuint id_;
    static GLuint generate() {
        GLuint id;
        glGenBuffers(1, &id);
        return id;
    }
};
#+end_src
#+depends:opengl_buffer :cpp span

*** VBO (Vertex Buffer Object)

VBOs are what is used to send vertices to the GPU.
#+name: VBO
#+begin_src cpp
class VBO: public opengl_buffer {
  public:
    VBO(): opengl_buffer() {}
    void send(const std::span<const GLfloat> data) const {
        opengl_buffer::send<GLfloat>(data);
    }

  protected:
    GLenum target() const override { return GL_ARRAY_BUFFER; }
};
#+end_src
#+depends:VBO :noweb opengl_buffer

*** EBO (Element Buffer Object)

EBOs are used to store indexes referring to vertices stored inside VBOs.
This way, vertices shared by several triangles can be send only once and used multiple times.

#+name: EBO
#+begin_src cpp
class EBO: public opengl_buffer {
  public:
    EBO(): opengl_buffer() {}
    void send(const std::span<const GLuint> data) const {
        opengl_buffer::send<GLuint>(data);
    }

  protected:
    GLenum target() const override { return GL_ELEMENT_ARRAY_BUFFER; }
};
#+end_src
#+depends:EBO :noweb opengl_buffer


** VAO (Vertex Array Object)

VAOs function is to remember various calls made on data held by VBOs.
Once a VAO is bound, it remembers that state changes caused by various subsequent OpenGL calls.
Those states changes can be enacted again later by simply bounding the VAO, acting like a sort of shortcut.

#+name: VAO
#+begin_src cpp
class VAO {
  public:
    VAO(): id_(generate())
    {
        bind(); // For now.
    }

    void bind() const {
        glBindVertexArray(id_);
    }

  private:
    const GLuint id_;
    static GLuint generate() {
        GLuint id;
        glGenVertexArrays(1, &id);
        return id;
    }
};
#+end_src


** Vertices and indexes

The =vertices= and =indexes= classes are a wrapper around respectively =VBO= and =EBO= adding a =draw= method.
=vertices= is more complex because it also handles vertex attributes and because I tried to make it generic under the assumption that I might eventually need to send other things than =std::vector<GLfloat>=.
In retrospect, this might be an overkill.

Utilities common to =vertices= and =indexes=:
#+name: vertindex_common
#+begin_src cpp
namespace details {
void assert_multiple(unsigned int n, unsigned int divisor, const char* error_keyword) {
    if(n % divisor != 0) {
        // throw std::runtime_error(std::format(
        //     "Invalid number of {}, expected a multiple of {} but got {} % {} = {}.",
        //     error_keyword, divisor, n, divisor, n % divisor
        // ));
        // C++20's <format> header is not supported for now.
        throw std::runtime_error( std::string("Invalid number of ") + std::string(error_keyword)
                                  + std::string(": ") + std::to_string(n) );
    }
}
}
#+end_src
#+depends:vertindex_common :cpp string stdexcept

*** Vertices and their layout

=vertices= handles both the vertex data and its layout.
Vertices are sent straightaway to the GPU because I don't need anything else right now.

The layout is specified as a sequence of the sizes of the sub-vertices in the order of their apparition.
For example, if we want to send vertices composed of 8 floats, the first three being the position, the next two being some magic data and the last 3 being the color, the corresponding layout will be ={3, 2, 3}=.

#+name: vertices
#+begin_src cpp :noweb no-export
namespace details {
template<class T> struct glenum;
template<> struct glenum<GLfloat> { static const GLenum v = GL_FLOAT; };
}

template<typename T>
class vertices {
  public:
    vertices(const std::span<const T> content, const std::span<const std::size_t> layout):
        stride_(lit::sum(layout)), count_(content.size() / stride_)
    {
        if(layout.size() == 0)
            throw std::runtime_error("Empty vertex layouts are illegal.");
        details::assert_multiple(content.size(), stride_, "vertices for the given layout");
        VBO vbo{}; vbo.send(content);
        <<Process vertices layout>>
    }

    // TODO: Think about glDeleteBuffers for this and also indexes, as well as glDeleteVertexArray for VAO.
    // Would probaly require move-only VAO and opengl_buffer to avoid multiple deletions of opengl resources.

    void draw() const { // Strictly VBO-based, no EBOs here.
        glDrawArrays(GL_TRIANGLES, 0, count_);
    }

  private:
    const GLsizei stride_;
    const GLsizei count_;
};
#+end_src
#+depends:vertices :noweb VBO vertindex_common sum

Vertex attributes are used to specify the layout of the data sent to the GPU.
The =layout= parameter is used to deduce the required values of each vertex attribute, with a caveat being that it is more restrictive than manually calling =glVertexAttribPointer=.

In particular, by virtue of how =layout= is constructed, the sub-vertices must have the same order in the layout as in the shader.
Going back to the previous example, it would not be possible to swap the position and the color without also inverting their order in the shader.

#+name: Process vertices layout
#+begin_src cpp
std::size_t offset = 0;
for(std::size_t i = 0; i < layout.size(); ++i) {
    glVertexAttribPointer(
        i, layout[i], details::glenum<T>::v, GL_FALSE,
        stride_ * sizeof(T), (void*) offset
    );
    offset += sizeof(T) * layout[i];
    glEnableVertexAttribArray(i);
}
#+end_src

The following helper function constructs =vertices= with both vertices and layout data being held inside a =std::vector=.
Using this allows to create the vectors in place with a braced syntax.

#+name: vec_vertices
#+begin_src cpp
template<typename T>
vertices<T> vec_vertices(const std::vector<T>& content, const std::vector<std::size_t>& layout){
    return vertices<T>(content, layout);
}
#+end_src
#+depends:vec_vertices :cpp vector :noweb vertices

*** Indexes

I'm assuming for now that indexes will only be vectors of unsigned int.

#+name: indexes
#+begin_src cpp
class indexes {
  public:
    indexes(const std::vector<GLuint>& content):
        count_(content.size())
    {
        // Hardcoded 3 because only triangles are supported.
        details::assert_multiple(content.size(), 3, "indexes");
        EBO ebo{}; ebo.send(content);
    }

    void draw() {
        glDrawElements(GL_TRIANGLES, count_, GL_UNSIGNED_INT, 0);
    }

  private:
    const GLsizei count_;
};
#+end_src
#+depends:indexes :noweb EBO vertindex_common


** Uniform

Uniform can be used to share data between the CPU and shader programs.
Lots of different data types can be shared this way, via =glUniform*= functions.
For example, =glUniform4f= can be used to send a vector of 4 floats.

The code block below uses LitLib's Pycgen and Pyogen to generate the necessary uniform variants.
It is a big code block but I think it's pretty easy to understand once the following bases are covered:
 - A =Pycgen= instance in the variable =cpp= stores the indentation level when used as a context manager (via Python's =with= keyword).
 - Calling this instance prints its arguments with the current indentation level.
 - A simple coding scheme is used to encode the nature of the struct to generate.
   For example, the code =m4f= represents a matrix of $4 \times 4$ floats.
   Incidentally, this code is also used to name the generated struct.

#+begin_src python :eval no-export :results output raw :exports both
<<include(":noweb Pycgen Pyogen")>>

cpp = Pycgen()

type_dispatcher = {
    'f': 'GLfloat',
    'i': 'Glint',
    'ui': 'Gluint'
}

def varnames(cardinality):
    return ['x', 'y', 'z', 'w'][:cardinality]

def arglist(cardinality, typename):
    return '(' + ', '.join(
        type_dispatcher[typename] + ' ' + el
        for el in varnames(cardinality)
    ) + ')'

def decode(code):
    cardinality = int(code[0]); assert 0 < cardinality <= 4,\
        'Code `{}` has an invalid cardinality.'.format(code)
    typename = code[1:]; assert typename in type_dispatcher,\
        'Code `{}` has an invalid typename.'.format(code)
    return cardinality, typename

def common(name):
    cpp(
        'const GLint location;',
        name + '(const GLchar* name, shader_program const& program):',
        '    location(glGetUniformLocation(program.id, name))',
        '{}'
    )

def vec_uniform(code):
    cardinality, typename = decode(code)
    name='uniform_' + code
    with Pyogen('src cpp', name=name, depends=':noweb shader_program'):
        with cpp.struct(name):
            common(name)
            with cpp.par('void send' + arglist(cardinality, typename)):
                cpp('glUniform4f(location, ' + ', '.join(varnames(cardinality)) + ');')

def mat_uniform(code):
    assert code[0] == 'm'
    cardinality, typename = decode(code[1:])
    name = 'uniform_' + code
    with Pyogen('src cpp', name=name, depends=':noweb shader_program :cpp cassert span'):
        with cpp.struct(name):
            common(name)
            with cpp.par('void send(const std::span<const GLfloat>& content)'):
                cpp('assert(content.size() == ' + str(cardinality * cardinality) + ');')
                cpp('glUniformMatrix' + code[1:] + 'v(location, 1, GL_FALSE, content.data());')

def uniform(code):
    if code[0] == 'm':
        mat_uniform(code)
    else:
        vec_uniform(code)
    print()

print('*** Generated uniforms')
uniform('4f')
uniform('m4f')
#+end_src

#+RESULTS:
*** Generated uniforms
#+name: uniform_4f
#+begin_src cpp
struct uniform_4f {
    const GLint location;
    uniform_4f(const GLchar* name, shader_program const& program):
        location(glGetUniformLocation(program.id, name))
    {}
    void send(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
        glUniform4f(location, x, y, z, w);
    }
};
#+end_src
#+depends:uniform_4f :noweb shader_program

#+name: uniform_m4f
#+begin_src cpp
struct uniform_m4f {
    const GLint location;
    uniform_m4f(const GLchar* name, shader_program const& program):
        location(glGetUniformLocation(program.id, name))
    {}
    void send(const std::span<const GLfloat>& content) {
        assert(content.size() == 16);
        glUniformMatrix4fv(location, 1, GL_FALSE, content.data());
    }
};
#+end_src
#+depends:uniform_m4f :noweb shader_program :cpp cassert span


* Examples

All the examples below are adapted from the excellent OpenGL tutorial at =learnopengl.com=.
A screenshot of the scene is saved and generated with each example to give an idea of what the result looks like.

** Drawing plain figures

The examples in the next two subsection are coming from the Hello-Triangle section of =learnopengl.com= (https://learnopengl.com/Getting-started/Hello-Triangle).
They are about using barebones fragment and vertex shaders to draw simple figures on the screen.

The next two code blocks are respectively the vertex and fragment shaders that will be used in this section.

#+name: basic_vs
#+begin_src glsl
#version 330 core
layout (location = 0) in vec3 position;

void main() {
    gl_Position = vec4(position.x, position.y, position.z, 1.0);
}
#+end_src

#+name: red_fs
#+begin_src glsl
#version 330 core
out vec4 color;

void main() {
    color = vec4(1.0f, 0.2f, 0.1f, 1.0f);
}
#+end_src

*** Drawing a triangle with =vertices=

#+begin_src cpp :eval no-export :exports both
<<include(":noweb lazy_window gl_screen_first VAO shader_program vec_vertices")>>

int main(){
    const char *vs_str =
        <<shader("basic_vs")>>
        ;
    const char *fs_str =
        <<shader("red_fs")>>
        ;

    lazy_window lazy("Triangle", 640u, 480u);
    shader_program basic_shader{vertex_shader(vs_str), fragment_shader(fs_str)};
    VAO triangle_vao{};
    auto triangle = vec_vertices<GLfloat>({
        -0.5, -0.5, 0.0,
         0.5, -0.5, 0.0,
         0.0,  0.5, 0.0
    }, {3});

    gl_screen_first(lazy, "images/screencaps/triangle_vertices.png", [&]{
        basic_shader.use();
        triangle_vao.bind();
        triangle.draw();
    });
    return 0;
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/triangle_vertices.png]]
:end:

*** Drawing a rectangle with =indexes=

Same thing as above, except we use =indexes= (and therefore =EBO=)as well as =vertices= to draw the two triangles forming a rectangle.

#+begin_src cpp :eval no-export :exports both
<<include(":noweb lazy_window gl_screen_first VAO shader_program vec_vertices indexes")>>

int main(){
    const char *vs_str =
        <<shader("basic_vs")>>
        ;
    const char *fs_str =
        <<shader("red_fs")>>
        ;

    lazy_window lazy("Rectangle", 640u, 480u);
    shader_program basic_shader{vertex_shader(vs_str), fragment_shader(fs_str)};
    VAO rectangle_vao{};
    auto rectangle_vertices = vec_vertices<GLfloat>({
            0.5,  0.5, 0.0, // Top right.
            0.5, -0.5, 0.0, // Bottom right.
           -0.5, -0.5, 0.0, // Bottom left.
           -0.5,  0.5, 0.0  // Top left.
    }, {3});
    auto rectangle_indexes = indexes({
            0, 1, 3, // First triangle.
            1, 2, 3  // Second triangle.
    });

    gl_screen_first(lazy, "images/screencaps/rectangle_indexes.png", [&]{
        basic_shader.use();
        rectangle_vao.bind();
        rectangle_indexes.draw();
    });
    return 0;
  }
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/rectangle_indexes.png]]
:end:


** Uniform and sub-vertices

The next examples are adapted from the Shaders section (https://learnopengl.com/Getting-started/Shaders).

*** Drawing a color-shifting triangle with =uniform=

The following shader colors pixels according to the content of the uniform =cpu_color=:

#+name: color_shifting_fs
#+begin_src glsl
#version 330 core
out vec4 color_out;
uniform vec4 color_cpu;

void main() {
    color_out = color_cpu;
}
#+end_src

The OpenGL program below is based on the =vertices= drawing program above and uses a =uniform_4f= to update the value of =cpu_color= every time a frame is drawn.

#+begin_src cpp :eval no-export :exports both 
<<include(":noweb lazy_window gl_screen_nth VAO shader_program vec_vertices uniform_4f :cpp cmath")>>

int main(){
    const char *vs_str =
        <<shader("basic_vs")>>
        ;
    const char *fs_str =
        <<shader("color_shifting_fs")>>
        ;

    lazy_window lazy("Triangle", 640u, 480u);
    shader_program shifting_shader{vertex_shader(vs_str), fragment_shader(fs_str)};
    uniform_4f color_cpu("color_cpu", shifting_shader);
    VAO triangle_vao{};
    auto triangle = vec_vertices<GLfloat>({
        -0.5, -0.5, 0.0,
         0.5, -0.5, 0.0,
         0.0,  0.5, 0.0
    }, {3});

    gl_screen_nth(lazy, "images/screencaps/shifting_color.png", [&]{
        float green = sin(glfwGetTime() * 3) * .07f + .75f;
        color_cpu.send(.1, green, .8, 1.);
        shifting_shader.use();
        triangle_vao.bind();
        triangle.draw();
    }, 10); // The first frame renders black, even though the uniform has been sent before the
            // shader is used and the first frame has been drawn before.
    return 0;
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/shifting_color.png]]
:end:

The screen capture is not very interesting here because it does not show the shifting colors but I still included it for good mesure.

*** Sending colors as sub-vertices

In this example, the colors of each vertex are sent to the GPU alongside their position.

Below are the dedicated vertex and fragment shaders.
Not much is done in them, it's mainly a question of receiving the position and color in the right location in the vertex shader and of transmitting it to the fragment shader.

#+name: color_as_attribute_vs
#+begin_src glsl
#version 330 core
layout (location = 0) in vec3 position;
layout (location = 1) in vec3 color_in;
out vec3 color_fs;

void main() {
    gl_Position = vec4(position, 1.);
    color_fs = color_in;
}
#+end_src

#+name: color_as_attribute_fs
#+begin_src glsl
#version 330 core
out vec4 color_out;
in vec3 color_fs;

void main() {
    color_out = vec4(color_fs, 1.);
}
#+end_src


The main difference with previous examples is that, to send the positions and the colors to their respective location, a vertex layout with two sub-vertices is used (={3, 3}=).
This means that two vertex attributes composed of 3 elements are defined next to each other.
The first one at location 0 is handled as the position in the vertex shader, whereas the second one at location 1 is handled as the color.

#+begin_src cpp :eval no-export :exports both
<<include(":noweb lazy_window gl_screen_first VAO shader_program vec_vertices")>>

int main(){
    const char *vs_str =
        <<shader("color_as_attribute_vs")>>
        ;
    const char *fs_str =
        <<shader("color_as_attribute_fs")>>
        ;

    lazy_window lazy("Triangle", 640u, 480u);
    shader_program basic_shader{vertex_shader(vs_str), fragment_shader(fs_str)};
    VAO triangle_vao{};
    auto triangle = vec_vertices<GLfloat>(
        // Vertices:
        // Positions         // Colors               //
        {  0.5f, -0.5f, 0.0f,   1.0f, 0.0f, 0.0f,    // Bottom right.
          -0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,    // Bottom left.
           0.0f,  0.5f, 0.0f,   0.0f, 0.0f, 1.0f  }, // Top.
        // Vertices layout:
        {  3 /* Positions */,   3 /* Colors   */  }
    );

    gl_screen_first(lazy, "images/screencaps/color_as_attribute.png", [&]{
        basic_shader.use();
        triangle_vao.bind();
        triangle.draw();
    });
    return 0;
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/color_as_attribute.png]]
:end:


* GLM utils

** Printing

The operator overload below can be used to print a GLM matrix.
It is built based on the knowledge that GLM matrices are column-major and that in such a representation, for a matrix with $C$ columns and $R$ rows, the element at column $c$ and row $r$ is located at the offset $R \times c + r$.
The rest is just formatting details to ensure that the separators are well placed.

#+name: <<glm/mat
#+begin_src cpp
template<glm::length_t Col, glm::length_t Row, typename T, glm::qualifier Q>
std::ostream& operator<<(std::ostream& os, const glm::mat<Col, Row, T, Q>& container) {
    size_t size = Col * Row;
    os << "[";
    if(size > 0) {
        auto data = glm::value_ptr(container);
        size_t row = 0;
        for(; row < Row - 1; ++row) {
            for(size_t column = 0; column < Col; ++column) {
                os << " " << *(data + Row * column + row) << ",";
            }
            os << "\n ";
        }

        // The last row is a special case since it does not end with a ",".
        row = Row - 1;
        for(size_t column = 0; column < Col -1; ++column) {
            os << " " << *(data + Row * column + row) << ",";
        }
        os << " " << *(data + size - 1) << " ";
    }
    os << "]";
    return os;
}
#+end_src
#+depends:<<glm/mat :cpp ostream glm/gtc/type_ptr.hpp

As can be seen in the usage example below, values are not aligned prettily but this will do for now.
#+begin_src cpp :eval no-export :flags -Wall -std=c++20 :noweb no-export :exports both :wrap "src text :minipage"
<<include(":noweb <<glm/mat :cpp iostream")>>
int main() {
    glm::mat4 identity(1.0f);
    std::cout << "Identity transformation:\n" << identity << "\n\n";
    auto downscale_half = glm::scale(identity, glm::vec3(0.5, 0.5, 0.5));
    std::cout << "Downscale half:\n" << downscale_half << "\n";
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Identity transformation:
[ 1, 0, 0, 0,
  0, 1, 0, 0,
  0, 0, 1, 0,
  0, 0, 0, 1 ]

Downscale half:
[ 0.5, 0, 0, 0,
  0, 0.5, 0, 0,
  0, 0, 0.5, 0,
  0, 0, 0, 1 ]
#+end_src
