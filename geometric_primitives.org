#+title: C++ OpenGL geometric primitives

#+property: header-args :eval never :main no :exports both :wrap "src text"

* Various TODOs :noexport:
** TODO Add an =#include:= (or something) notation to include.pl to make it possible to recursively include org mode files relatively to the file being processed.
** TODO Syntax to declare that a block is purely destined to be used by org and not by include.pl
#+litlib-ignore
perhaps ?


* Prelude :noexport:

** Inclusion

#+name: include
#+begin_src sh :var args="" :results output :wrap "src cpp" :eval no-export
./litlib/include.pl "window.org litlib/cpp.org geometric_primitives.org" "$args"
#+end_src

Specialised block for shaders (makes things slightly more readable):

#+name: shader
#+begin_src bash :var noweb="" :results output :wrap "src text" :eval no-export
./litlib/include.pl "geometric_primitives.org" ":noweb $noweb :c-string"
#+end_src

** Log the output of OpenGL commands

With the help of some pretty awesome black magic, =sed= can be used to replace OpenGL calls with a logging call via =LOG_AND_CALL=.

First, the following code block (from https://stackoverflow.com/a/66090390) must be executed:
#+begin_src emacs-lisp :eval no-export :results silent
(defun shell-command-on-buffer (command)
  ;; (interactive)
  (let ((line (line-number-at-pos)))
    ;; replace buffer with output of shell command
    (shell-command-on-region (point-min) (point-max) command nil t)
    ;; restore cursor position
    (goto-line line)
    (recenter-top-bottom)))
#+end_src

Then execute the following elisp command via =C-x C-e=:
(shell-command-on-buffer "sed -r 's| (gl[a-zA-Z]+[^(]+)\\(| LOG_AND_CALL(\\1, |'")
There is a space at the beginning of the regex to avoid matching initialisation lists.

Regex to transform logging calls back to plain opengl calls:
(shell-command-on-buffer "sed -r 's|LOG_AND_CALL\\((gl[a-zA-Z]+[^,]+), |\\1(|'")

I had to resort to sed because I'm not a fan of  Emacs' regexes.
To adapt the regexes above, remember that backslashes must be escaped because they are in an elisp string.

It should be possible to make the logging calls work for initialisation lists by adding a templated =log_and_call= function.


* OpenGL objects

Here are defined various OpenGL objects that let us draw things.
I'm a bit lax with the dependencies declaration here because technically the blocks here are using OpenGL functions but they are not supposed to include those functions themselves.

What's implied here is that the user of the code blocks below knows what to expect and is using them in the proper context, that is to say after window has been included.

I tried to make as many things =const= as possible for those OpenGL primitives, this way once the objects are constructed, they are set in stone and annoying mistakes can be avoided.
Of course, those things will be "unconsted" when needed.


** Shader

Apparently, shaders are supposed to be deleted once they are linked, hence the custom desctuctor.

#+name: shader_base
#+begin_src cpp
class shader {
  public:
    const GLuint id;

    ~shader() {
        glDeleteShader(id);
    }

  protected:
    shader(const char* source, int type):
        id(glCreateShader(type))
    {
        glShaderSource(id, 1, &source, nullptr);
        glCompileShader(id);
        ensure_success();
    }

    bool compiled() const {
        int success;
        glGetShaderiv(id, GL_COMPILE_STATUS, &success);
        return success;
    }

    std::string info_log() const {
        char buffer[512];
        glGetShaderInfoLog(id, 512, nullptr, buffer);
        return std::string(buffer, 512);
    }

    void ensure_success() {
        if(!compiled()) {
            throw std::runtime_error(info_log());
        }
    }
};
#+end_src
#+depends:shader_base :cpp string stdexcept

*** Vertex shader

#+name: vertex_shader
#+begin_src cpp
struct vertex_shader: public shader {
    vertex_shader(const char* source): shader(source, GL_VERTEX_SHADER) {}
};
#+end_src
#+depends:vertex_shader :noweb shader_base

*** Fragment shader

#+name: fragment_shader
#+begin_src cpp
struct fragment_shader: public shader {
    fragment_shader(const char* source): shader(source, GL_FRAGMENT_SHADER) {}
};
#+end_src
#+depends:fragment_shader :noweb shader_base

*** Shader program

#+name: shader_program
#+begin_src cpp
class shader_program {
  public:
    shader_program(const vertex_shader& vs, const fragment_shader& fs):
        id_(glCreateProgram())
    {
        glAttachShader(id_, vs.id);
        glAttachShader(id_, fs.id);
        glLinkProgram(id_);
        ensure_success();
    }

    void use() const {
        glUseProgram(id_);
    }

  private:
    const GLuint id_;

    bool linked() const {
        int success;
        glGetProgramiv(id_, GL_LINK_STATUS, &success);
        return success;
    }

    std::string info_log() const {
        char buffer[512];
        glGetProgramInfoLog(id_, 512, nullptr, buffer);
        return std::string(buffer, 512);
    }

    void ensure_success() {
        if(!linked()) {
            throw std::runtime_error(info_log());
        }
    }
};
#+end_src
#+depends:shader_program :noweb fragment_shader vertex_shader :cpp stdexcept


** Buffers

#+name: opengl_buffer
#+begin_src cpp
class opengl_buffer {
  protected:
    template<typename T>
    void send(const std::span<const T> data) const {
        glBindBuffer(target(), id_);
        glBufferData(target(), data.size() * sizeof(T), data.data(), GL_STATIC_DRAW);
    }

    opengl_buffer() : id_(generate()) {}

    virtual GLenum target() const=0;

  private:
    const GLuint id_;
    static GLuint generate() {
        GLuint id;
        glGenBuffers(1, &id);
        return id;
    }
};
#+end_src
#+depends:opengl_buffer :cpp span

*** VBO (Vertex Buffer Object)

VBOs are what is used to send vertices to the GPU.
#+name: VBO
#+begin_src cpp
class VBO: public opengl_buffer {
  public:
    VBO(): opengl_buffer() {}
    void send(const std::span<const GLfloat> data) const {
        opengl_buffer::send<GLfloat>(data);
    }

  protected:
    GLenum target() const override { return GL_ARRAY_BUFFER; }
};
#+end_src
#+depends:VBO :noweb opengl_buffer

*** EBO (Element Buffer Object)

EBOs are used to store indexes referring to vertices stored inside VBOs.
This way, vertices shared by several triangles can be send only once and used multiple times.

#+name: EBO
#+begin_src cpp
class EBO: public opengl_buffer {
  public:
    EBO(): opengl_buffer() {}
    void send(const std::span<const GLuint> data) const {
        opengl_buffer::send<GLuint>(data);
    }

  protected:
    GLenum target() const override { return GL_ELEMENT_ARRAY_BUFFER; }
};
#+end_src
#+depends:EBO :noweb opengl_buffer


** VAO (Vertex Array Object)

VAOs function is to remember various calls made on data held by VBOs.
Once a VAO is bound, it remembers that state changes caused by various subsequent OpenGL calls.
Those states changes can be enacted again later by simply bounding the VAO, acting like a sort of shortcut.

#+name: VAO
#+begin_src cpp
class VAO {
  public:
    VAO(): id_(generate())
    {
        bind(); // For now.
    }

    void bind() const {
        glBindVertexArray(id_);
    }

  private:
    const GLuint id_;
    static GLuint generate() {
        GLuint id;
        glGenVertexArrays(1, &id);
        return id;
    }
};
#+end_src


** Vertices and indexes

The =vertices= and =indexes= classes are a wrapper around respectively =VBO= and =EBO= adding a =draw= method.
=vertices= is more complex because it also handles vertex attributes and because I tried to make it generic under the assumption that I might eventually need to send other things than =std::vector<GLfloat>=.
In retrospect, this might be an overkill.

Utilities common to =vertices= and =indexes=:
#+name: vertindex_common
#+begin_src cpp
namespace details {
void assert_multiple(unsigned int n, unsigned int divisor, const char* error_keyword) {
    if(n % divisor != 0) {
        // throw std::runtime_error(std::format(
        //     "Invalid number of {}, expected a multiple of {} but got {} % {} = {}.",
        //     error_keyword, divisor, n, divisor, n % divisor
        // ));
        // C++20's <format> header is not supported for now.
        throw std::runtime_error( std::string("Invalid number of ") + std::string(error_keyword)
                                  + std::string(": ") + std::to_string(n) );
    }
}
}
#+end_src
#+depends:vertindex_common :cpp string stdexcept

*** Vertices and their layout

=vertices= handles both the vertex data and its layout.

Vertices are sent straightaway to the GPU because I don't need anything else right now.
Vertex attributes are used to specify the layout of the data sent to the GPU.

#+name: vertices
#+begin_src cpp
namespace details {
template<class T> struct glenum;
template<> struct glenum<GLfloat> { static const GLenum v = GL_FLOAT; };
}

template< template<typename> class Container, typename Inner>
class vertices {
  public:
    // TODO: put Container.size inside some kind of template helper, a bit like glenum.
    vertices(GLuint index, GLint vertex_size, const Container<Inner>& content):
        count_(content.size() / vertex_size)
    {
        details::assert_multiple(content.size(), vertex_size, "vertices");
        VBO vbo{}; vbo.send(content);
        glVertexAttribPointer(
            index, vertex_size, details::glenum<Inner>::v, GL_FALSE,
            vertex_size * sizeof(Inner), (void*) 0
        );
        glEnableVertexAttribArray(index);
    }

    // TODO: Think about glDeleteBuffers for this and also indexes, as well as glDeleteVertexArray for VAO.
    // Would probaly require move-only VAO and opengl_buffer to avoid multiple deletions of opengl resources.

    void draw() const { // Strictly VBO-based, no EBOs here.
        glDrawArrays(GL_TRIANGLES, 0, count_);
    }

  private:
    const GLsizei count_;
};
#+end_src
#+depends:vertices :noweb VBO vertindex_common

Helper function to construct =vertices= with the data being held inside a =std::vector=.

#+name: vertices_vector
#+begin_src cpp
// Not sure if && is supposed to be the way to do this, I'm confused at this point.
template<typename T>
vertices<std::vector, T> vertices_vector(GLuint _index, GLint _vertex_size, const std::vector<T>& _content){
    return vertices(_index, _vertex_size, _content);
}
#+end_src
#+depends:vertices_vector :cpp vector :noweb vertices

*** Indexes

I'm assuming for now that indexes will only be vectors of unsigned int.

#+name: indexes
#+begin_src cpp
class indexes {
  public:
    indexes(const std::vector<GLuint>& content):
        count_(content.size())
    {
        // Hardcoded 3 because only triangles are supported.
        details::assert_multiple(content.size(), 3, "indexes");
        EBO ebo{}; ebo.send(content);
    }

    void draw() {
        glDrawElements(GL_TRIANGLES, count_, GL_UNSIGNED_INT, 0);
    }

  private:
    const GLsizei count_;
};
#+end_src
#+depends:indexes :noweb EBO vertindex_common


* Examples

Using barebones fragment and vertex shaders to draw simple figures on the screen.
Those examples are coming from the Hello-Triangle section or =learnopengl.com= (https://learnopengl.com/Getting-started/Hello-Triangle).

#+name: basic_vs
#+begin_src glsl
#version 330 core
layout (location = 0) in vec3 aPos;

void main()
{
    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}
#+end_src

#+name: basic_fs
#+begin_src glsl
#version 330 core
out vec4 FragColor;

void main()
{
    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
}
#+end_src

** Drawing a triangle with VBOs

#+begin_src cpp :noweb no-export :eval no-export :flags -std=c++20 -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb lazy_window VAO shader_program vertices_vector")>>

int main(){
    const char *vs_str =
        <<shader("basic_vs")>>
        ;
    const char *fs_str =
        <<shader("basic_fs")>>
        ;

    lazy_window lazy("Triangle", 640u, 480u);
    shader_program basic_shader{vertex_shader(vs_str), fragment_shader(fs_str)};

    VAO triangle_vao{};
    auto triangle = vertices_vector<GLfloat>(0, 3, {
        -0.5, -0.5, 0.0,
         0.5, -0.5, 0.0,
         0.0,  0.5, 0.0
    });

    lazy.game_loop([&]{
        basic_shader.use();
        triangle_vao.bind();
        triangle.draw();
    });

    return 0;
}
#+end_src

#+RESULTS:
#+begin_src text
#+end_src

** Drawing a rectangle with =indexes=

Same thing as above, except we use =indexes= (and therefore =EBO=)as well as =vertices= to draw the two triangles forming a rectangle.
#+begin_src cpp :noweb no-export :eval no-export :flags -std=c++20 -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb lazy_window VAO shader_program vertices_vector indexes")>>

int main(){
    const char *vs_str =
        <<shader("basic_vs")>>
        ;
    const char *fs_str =
        <<shader("basic_fs")>>
        ;

    lazy_window lazy("Rectangle", 640u, 480u);
    shader_program basic_shader{vertex_shader(vs_str), fragment_shader(fs_str)};

    VAO rectangle_vao{};
    auto rectangle_vertices = vertices_vector<GLfloat>(0, 3, {
             0.5,  0.5, 0.0, // top right
             0.5, -0.5, 0.0, // bottom right
            -0.5, -0.5, 0.0, // bottom left
            -0.5,  0.5, 0.0  // top left 
    });
    auto rectangle_indexes = indexes({
            0, 1, 3, // first triangle
            1, 2, 3  // second triangle
    });

    lazy.game_loop([&]{
        basic_shader.use();
        rectangle_vao.bind();
        rectangle_indexes.draw();
    });

    return 0;
  }
#+end_src

#+RESULTS:
#+begin_src text
#+end_src
