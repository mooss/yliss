#+property: header-args:jupyter-python :session sierp :results silent :tangle no :noweb no-export :eval never
#+property: header-args:bash :eval never

* Development setup :noexport:



* About mathematical rigour

The maths presented here will be hand-wavy most of the time and a lot of it will not be formally proved because I'm a lazy bastard who mostly want to program.
So do not expect much rigour.

* Of octahedrons and Sierpiński triangles

This document is about octasierps, fractal solids destined to be used as the basis for a procedurally generated planet.

An octasierp is the brainchild of a regular octahedron and the Sierpiński triangle, the first is the platonic solid formed of 8 equilateral triangles and the second is a recursive subdivision of an equilateral triangle.
Indeed, since each face of an octahedron is an equilateral triangle, it can be divided into 4 smaller equilateral triangles which can themselves be divided and so on, thus adapting the concept of Sierpiński triangles to the third dimension.

This recursive structure is caracterised by its degree $d \in \mathbb{N}$, which is the number of successive subdivisions necessary to construct it.
The simplest octasierp occurs when $d=0$ and corresponds to an octahedron.

** Goals

This is my second attempt at generating a procedural planet using an octahedron as the starting point.

The main problem I encountered last time was finding a good data structure for my subdivided octahedron as well as implementing the code to get the neighbours of a point.
I ended up using a convoluted approach that I can't even remember now, and thankfully I don't have to since I've collected some observations that will help me to build a much simpler and intuitive data structure than last time.

A good data structure for an octasierp must meet some criteria:
 - A coordinate system, both for mental representation and as a programming primitive.
 - A support for different levels of detail, meaning the possibility to further subdivise the structure without having to reconstruct the whole object.
 - A fast way to request the neighbours of a point.

# Note: those goals are not static, the definition of a good data structure will probably expand when I'll get a better grasp on the problem.

** Geometric visualisation

I think an appropriate first step to find the best underlying representation of an octasierp is to visualise the problem, since the subject of study is a geometric concept.

*** Octahedron net

An octahedron can be represented in two dimensions as a net, a flattened arrangement of the eight sides, ready to be folded back into three dimensions.
For an illustration of both the subdivision process and the net of an octahedron, extended to an octasierp, see figure [[montage_octa_degree_0-3]].

#+name: montage_octa_degree_0-3
#+caption: Octasierp net for degrees 0, 1, 2 and 3
[[file:images/montage_net_octa_degree_0-3.png]]

*** Squarified net

An interesting property of octasierps is that when you inflate the central angle to 90\textdegree{}, they can almost be represented as a square grid with additional diagonal connections as shown in figure [[montage_squa_degree_0-3]].
A strange thing about this representation is that points are neighbouring each other along the sides in a symmetric pattern.
This representation is strongly reminiscent of the Peirce quincuncial projection[fn::See https://en.wikipedia.org/wiki/Peirce_quincuncial_projection.], all the more because the end goal of this project is to generate a planet.

#+name: montage_squa_degree_0-3
#+caption: Octasierp squarified net for degrees 0, 1, 2 and 3
[[file:images/montage_net_squa_degree_0-3.png]]

**** Four quarters

We can divise the squarified net into four quarter, each being a rotated image of the others around the central point.
This means rules devised for one quarter can easily be adapted to the others.

Those quarters are identified by a number ranging from zero to three, with quarter 0 being the top-right one and the others being numerated counter-clockwise.
The counter-clockwise rotation has been chosen to correspond to the sense of trigonometric rotation.

**** Two poles and four corners

To pay hommage to both the planet metaphor and the peirce quincuncial projection, the central point is the north pole, while the four extremes are one and the same, the south pole.

The four midpoints of the sides are actually just random points on the equator but since they also are initial vertices of the octasierp, let's give them a name ; the four corners of the world, with the right one being corner 0 and the others numerated once again counter-clockwise.
I know that the four corners are a bit confusing because from the 2d perspective of the squarified net, the corners of the square are actually the south pole but it will make more sense in 3d and I really like the term, so it stays.

** Coordinate system

Based on the observation of the squarified net, the natural coordinate system for an octasierp is an indexing along the axis between corners 1 and 3 (the x-axis) and the one between corners 2 and 0 (the y-axis).
In this scheme, the point of coordinates $(0, 0)$ is the north pole.

Since an octasierp is a discrete structure, the coordinates will be integer-based.
An unfortunate side effect of integer coordinates is that except for the north pole, points will not keep their coordinates when the degree of subdivision changes.
For example when $degree = 0$, corner 0 is at the coordinates $(1, 0)$ and when $degree = 1$ it is at the coordinates $(2, 0)$.
In the end, the rule is that coordinates only make sense at a given degree.

Another problem is that there is a redundancy in this coordinate system that needs to be resolved (most strikingly, the south pole is present four times).
First we will need to derive the cardinality of a half-axis, that is to say the number of points on it.
Then that property will be used to describe precisely the redundancy problem.
Finally, I will present the solution I opted for to resolve the situation and fix the coordinate system.

*** Half-axis cardinality

To pass from degree $d$ to degree $d + 1$, points are inserted between every adjacent point.
From degree 0 to degree 1, 1 point is added, from degree 1 to 2, 2 points are inserted, then 4, then 8, then $2^4$, then $2^5$, and so on.
Another way to see it is that the number of points added at degree $d + 1$ is the number of segments at degree $d$ ; we start with one segment to subdivise, then two, then four and so on.

Based on what we have deduced so far, we can express this number, with the relation $\vert points_{d+1} \vert = \vert points_d \vert + 2^{d}$ with $d \in \mathbb{N}$.
The problem is that I don't know anymore how to process this kind of recurrence relationships and I can't be bothered to find how so let's just make a hasardous guess from the first five numbers, shown in table [[hasardous_guess]].
A most interesting pattern made evident by this table is that in each line we add $2^d$ to itself, plus one.
Thus we deduce that $\vert points_{d+1} \vert = 2 \times 2^d + 1 \Leftrightarrow \vert points_{d+1} \vert = 2^{d+1} + 1 \Leftrightarrow \vert points_d \vert = 2^{d} + 1$.

#+name: hasardous_guess
#+caption: Small amount of data to support my dubious claim (no mathematicians were hurt in the process (don't quote me on that))
| $d$ | $\vert points_d \vert$ | $2^{d}$ | $\vert points_{d+1} \vert$ |
|-----+------------------------+---------+----------------------------|
|   0 |                      2 |       1 |                          3 |
|   1 |                      3 |       2 |                          5 |
|   2 |                      5 |       4 |                          9 |
|   3 |                      9 |       8 |                         17 |
|   4 |                     17 |      16 |                         33 |

*** Points redundancy

A peculiar caracteristic of the squarified-net-inspired coordinate system is that there is a redundancy at the edges, where the four corners act as a center of symmetry.
For example, the points $(2, -1)$ and $(2, 1)$ at degree 1 are one and the same.
We can deduce a general rule from this example.

First we need to find what are the extreme values of our coordinate system at a given degree.
The extreme value we are looking for here will be the number of points on an half-axis minus one, since the numerotation starts at 0.
We already know the number of points on a half-axis at degree $d$ to be $\vert points_d \vert = 2^{d} + 1$ so the extreme value we are looking for is $2^d$.

Since the center of symmetry are the four corners we deduce the following rules for the redundant points at degree $d$, centered around:
 - *corner 0*: $\{(2^d, n), (2^d, -n)\}$
 - *corner 1*: $\{(n, 2^d), (-n, 2^d)\}$
 - *corner 2*: $\{(-2^d, n), (-2^d, -n)\}$
 - *corner 3*: $\{(n, -2^d), (-n, -2^d)\}$
With $n \in \mathbb{N}$ and $0 \leq n \leq 2^d$, so technically the centers of symmetry are included (when $n=0$).
Note that a special case arise when $n=2^d$, where the redundant points - for all the corners - are the south pole.

*** Border disputes and canonical quarters

Because there are redundancies in the coordinate system, it will be useful to define the canonical quarter of a redundant point, that is to say the one to which they "officially" belong.
Two cases need to be treated:
 - The poles because they are on every quarter.
 - The borders between quarters (excluding the poles) because they are shared between two quarters.

There is only two poles, so they cannot be distributed equally between the four quarters.
Rather that attributing one pole to, say the quarter 0 and another to the quarter 2, I prefer to give them both to quarter 0 because:
 1. it is more memorable, and
 2. it gets the message across that quarter 0 is the reference quarter, or The canonical quarter, if you will.

Because quarter 1, 2 and 3 are essentially a rotation of quarter 0, we resolve the border dispute between quarters by using this property.
The top and bottom border of quarter 0, i.e. its border with quarter 1 and quarter 3 respectively are attributed to quarter 0.
By rotation, every border has its quarter and every quarter has its border.

Beyond those two cases we just resolved lurks a third one, the corners.
Even though they technically belong to the borders, the rotation mecanism would still make them shared between quarters because there would be two corners per quarter while there is the same number of corners and quarters (4).
To solve this last issue, we'll just say that the bottom right corner belongs to quarter 0 and as always, this rule applies by rotation to the other quarters.

* Diagrams generation

The diagrams are generated in python, using =gizeh= for the geometry and =moviepy= for stiching images together into animations, inspired by this [[http://zulko.github.io/blog/2014/09/20/vector-animations-with-python/][blogpost]].

They can be installed via pip:
#+BEGIN_SRC bash :eval never
pip install --user gizeh moviepy
#+END_SRC


Images are saved in the =images= folder and the scripts are supposed to be executed from the root of the project like so:
#+BEGIN_SRC bash
./scripts/your-favorite-script.sh
#+END_SRC

** Colors

I use a =SimpleNamespace= to store some colors that I want to use (the names are probably innacurate).
The obvious alternative would be to use a =class= but that would be tedious to initialize, or a =dict= but I want to be able to access members through the dot operator.

#+name: Colors
#+BEGIN_SRC jupyter-python
from types import SimpleNamespace
colors = SimpleNamespace(
    canard=(0, .6, .6),
    turquoise=(0, 1, 1),
    orange=(1, .5, 0),
    mandarine=(1, .8, 0),
    purple=(.4, 0, .4),
    violet=(.6, .2, .6),
    black=(0, 0, 0),
    evergrey=(.5, .5, .5),
    white=(1, 1, 1),
    forest=(0, .4, 0),
    grass=(0, .6, .2),
    ocean=(0, .2, .8),
    river=(0, .4, .8),
    air=(0, 0, 0, 0)
)
#+END_SRC

Here are some color palettes:

#+name: Colors
#+BEGIN_SRC jupyter-python
palette_colorful = [
    (colors.canard, colors.turquoise),
    (colors.purple, colors.violet),
    (colors.orange, colors.mandarine),
    (colors.black, colors.white),
    (colors.black, colors.white)
]
palette_gfg = [
    (colors.white, colors.canard),
    (colors.canard, colors.purple),
    (colors.purple, colors.orange),
    (colors.orange, colors.black),
    (colors.black, colors.white)
]
palette_gfgpoints = [
    (colors.air, colors.canard),
    (colors.air, colors.purple),
    (colors.air, colors.orange),
    (colors.air, colors.evergrey),
    (colors.air, colors.air),
    (colors.air, colors.canard)
]
palette_psyche = [
    (colors.canard, colors.white),
    (colors.orange, colors.white),
    (colors.purple, colors.white),
    (colors.black, colors.white),
    (colors.black, colors.white),
]
#+END_SRC

** Geometric primitives

The class =Geometry= is here to provide an abstraction about the way a subdivided object is to be drawn.
For the moment, geometric primitives only have two caracteristics at a given degree of subdivision :
 - their color as a tuple of three or four floats =(r, g, b)= or =(r, g, b, a)=, and
 - their size as a factor by which to multiply a reference size.

Thus, =Geometry= is initialised with:
 - a color palette (a list of colors), and
 - a size policy (a function $f : \mathbb{N} \rightarrow \mathbb{R}^+$).

The geometry parameters for degree $d$ can then simply be obtained with square brackets indexing (like =geometry[d]=), thanks to the method =__getitem__=.

#+name: Geometric primitives
#+BEGIN_SRC jupyter-python
class Geometry(object):
    def __init__(self,
                 degree,
                 color_palette=[(0, 0, 0)],
                 size_policy=None
    ):
        self.color_palette = color_palette
        if size_policy is None:
            self.size_policy = decrease_size_linearly(degree)
        else:
            self.size_policy = size_policy

    def __getitem__(self, current):
        return self.color_palette[current % len(self.color_palette)],\
            self.size_policy(current)
#+END_SRC

*** Decrease size linearly

The default element size policy is to decrease the size of a primitive linearly with the degree of subdivision.
Thus, the aim of this policy is to provide a factor $factor_{current}$ by which to multiply an initial size such that $1 \geq factor_{current} \geq minFactor$, where $current$ is the current degree of subdivision.

We know that $factor_0 = 1$ and $factor_{degree} = minFactor$.
Since we want to decrease the size linearly, we also know that $factor_{current} = a \times current + b$, thus

$\begin{cases}
  a \times 0 + b = 1 & \Leftrightarrow b = 1\\
  a \times degree + b = minFactor & \Leftrightarrow a = \frac{minFactor -1}{degree}
\end{cases}$

We finally obtain the function $factor_{current} = \frac{minFactor - 1}{degree} \times current + 1$.
This function is not defined when $degree = 0$ so this need to be addressed as a special case.

After playing a bit with $minFactor$ value, it looks like .25 is a good value.

#+name: Geometric primitives
#+BEGIN_SRC jupyter-python
def decrease_size_linearly(degree, min_factor=.25):
    def result(current):
        if degree == 0:
            return 1
        return current * (min_factor - 1) / degree + 1
    return result
#+END_SRC

** Triangle
:PROPERTIES:
:header-args:jupyter-python+: :eval never
:END:

A =Triangle= represents one of the triangles of an octasierp net, its properties are:
#+attr_latex: :float left :center nil
| -- =degree=:        | The degree of subdivision.                              |
| -- =initial_width=: | The width of the first element.                         |
| -- =points=:        | =Geometry= object describing how points are to be drawn |
| -- =lines=:         | =Geometry= object describing how lines are to be drawn  |

A =Triangle= has no coordinate of its own because the coordinates of its constituent points will be used in =generate=, whose role is to create a Gizeh object representing the geometry of the triangle, whereas =geometry= does the recursive calculations regarding all the points and lines of the final figure.

#+name: Triangle
#+BEGIN_SRC jupyter-python
import gizeh as gz

<<Geometric primitives>>

class Triangle(object):
    def __init__(self, degree, initial_width, points=None, lines=None):
        self.degree = degree
        self.initial_width = initial_width
        if points is None:
            self.points = Geometry(degree)
        else:
            self.points = points
        if lines is None:
            self.lines = Geometry(degree)
        else:
            self.lines = lines

    def generate(self, a, b, c):
        points, lines = self.geometry(a, b, c)
        return gz.Group(lines + points)

    def geometry(self, a, b, c, current=0):
        <<Initiate triangle geometry>>
        <<Subdivise triangle>>
#+END_SRC

*** Initiate triangle geometry
We use the =Geometry= object instanciated in the constructor to get the color and deduce the line width at the current degree, making sure that it is at least 1.

#+name: Initiate triangle geometry
#+BEGIN_SRC jupyter-python
color, factor = self.lines[current]
width = max(1, self.initial_width * factor)
#+END_SRC

The initial triangle is simply three lines joining the three points, kept in a list that will eventually hold the subsequent triangles.
#+name: Initiate triangle geometry
#+BEGIN_SRC jupyter-python
lines = [gz.polyline(
    [a, b, c, a],
    stroke_width=width,
    stroke=color
)]
#+END_SRC

The same idea is repeated to create an initial point, scaled a bit ($\times 1.2$) because their original use is to hide the corners of lines:
#+name: Initiate triangle geometry
#+BEGIN_SRC jupyter-python
color, factor = self.points[current]
width = max(1, self.initial_width * factor * 1.2)
point = gz.circle(r=width, fill=color)
#+END_SRC

This point was spawned at the default location of (0, 0), we use it to create the vertices of our triangle by translation:
#+name: Initiate triangle geometry
#+BEGIN_SRC jupyter-python
points = list(map(point.translate, (a, b, c)))
#+END_SRC

*** Subdivise triangle

Now that the geometric elements have been dealt with, only the recursive calls - or lack thereof - remains.
The generation is over when the maximal degree has been reached:
#+name: Subdivise triangle
#+BEGIN_SRC jupyter-python
if current == self.degree:
    return points, lines
#+END_SRC

Otherwise, we make recursive calls to =geometry=, using the midpoints of the three original points.
The order of the points and of the lines is important because the graphical elements are drawn in the order of their apparition and we want to make sure that the earliest subdivisions are written over the subsequent ones.
#+name: Subdivise triangle
#+BEGIN_SRC jupyter-python
ab = midpoint(a, b)
ac = midpoint(a, c)
bc = midpoint(b, c)
for sierpinski in [(a, ab, ac), (b, ab, bc), (c, ac, bc), (ab, ac, bc)]:
    recurse_points, recurse_lines = self.geometry(*sierpinski, current + 1)
    lines = recurse_lines + lines # order is important
    points = recurse_points + points
return points, lines
#+END_SRC

With =midpoint= being defined as:
#+name: Triangle
#+BEGIN_SRC jupyter-python
def midpoint(left, right):
    return ((left[0] + right[0]) / 2, (left[1] + right[1]) / 2)
#+END_SRC

** Octasierp net

=Octanet= represent the net of an octasierp through its evolution to a quasi-squaregrid.
=make_surface= is the interface for the external world to generate the gizeh surface containing the desired octanet.

#+name: Octanet
#+BEGIN_SRC jupyter-python
<<Triangle>>
<<Colors>>

import math

class Octanet(object):
    <<Computations independant of progress>>

    <<Net construction according to progress>>

    def make_surface(self, progress=0):
        surface = gz.Surface(**self.surface_parameters)
        self.make_net(progress).draw(surface)
        return surface
#+END_SRC

*** Net construction according to progress

=Octanet='s evolution is tracked through the =progress= parameter of =make_net=:
 - when $progress = 0$, it's octahedron net shaped,
 - when $progress = 1$ it's quasi-squaregrid shaped, and
 - when $0 < progress < 1$ the shape is deduced by interpolating the value of the central angle.
A triangle is then generated at the desired degree of subdivision and rotated to form the first quarter of the figure.
Finally this quarter is cloned and rotated three times to form the complete figure.

#+name: Net construction according to progress
#+BEGIN_SRC jupyter-python
def make_net(self, progress):
    vertical_correction = progress * self.side / 2
    angle = math.pi / 3 + progress * (math.pi / 6)

    y_a = self.y_a - vertical_correction
    y_b = self.y_b - vertical_correction
    a = (self.x_ab, y_a)
    b = (self.x_ab, y_b)

    cosa = math.cos(angle)
    sina = math.sin(angle)

    x_c = -sina * (y_b - y_a) + self.x_ab
    y_c = cosa * (y_b - y_a) + y_a
    c = (x_c, y_c)

    t1 = self.triangles(a, b, c)
    twin_point = ((self.x_ab + x_c) / 2, (y_b + y_c) / 2)
    t2 = t1.rotate(math.pi, twin_point)

    first_quarter = gz.Group([t1, t2])
    second_quarter = first_quarter.rotate(-angle, a)
    third_quarter = first_quarter.rotate(-2 * angle, a)
    fourth_quarter = first_quarter.rotate(angle, a)

    return gz.Group([first_quarter, second_quarter, third_quarter, fourth_quarter])
#+END_SRC

*** Computations independant of progress

Everything that does not depend on =progress= is computed in =__init__=:
#+name: Computations independant of progress
#+BEGIN_SRC jupyter-python
def __init__(
        self, scale, degree=0, points=None, lines=None
):
    self.degree = degree
    self.side = int(50 * scale) # Bugs may arise at very low scale.
    stroke_width = scale
    horizontal_margin = int(5 * scale)
    vertical_margin = int(15 * scale)

    altitude = math.sqrt(3) * (self.side / 2)
    width = int(4 * altitude)
    height = 2 * self.side
    left = horizontal_margin
    right = width + horizontal_margin
    bottom = height + vertical_margin

    self.x_ab = (left + right) /2
    self.y_a = bottom - self.side / 2
    self.y_b = bottom - self.side * 1.5

    self.surface_parameters = {
        'width': width + 2 * horizontal_margin,
        'height': height + 2 * vertical_margin,
        'bg_color': (1, 1, 1)
    }

    triangle = Triangle(degree, stroke_width, points=points, lines=lines)
    self.triangles = triangle.generate
#+END_SRC

** Illustration: degrees 0 through 3

We use the =Octanet= class defined above to create the 8 images corresponding to the degrees 0 through 3 of the octahedron and the quasi-square version:
#+BEGIN_SRC jupyter-python :tangle scripts/octasierp_net_0-3.py
<<Octanet>>

for degree in range(4):
    net = Octanet(scale=10, degree=degree)
    net.make_surface(0).write_to_png('net_octa_degree_{}.png'.format(degree))
    net.make_surface(1).write_to_png('net_squa_degree_{}.png'.format(degree))
#+END_SRC

The code above is then called by a bash script who annotates and stitches the images together with imagemagick's =mogrify= and =montage=:
#+BEGIN_SRC bash :tangle scripts/illustration_0_through_3.sh :shebang "#!/usr/bin/env bash"
python3 scripts/octasierp_net_0-3.py

function make_montage(){
    base=net_${version}_degree_

    for degree in 0 1 2 3
    do
        mogrify -size 600x400 -pointsize 60\
                -annotate +770+$vertical "degree = $degree"\
                $base$degree.png
    done

    montage ${base}{0,1,2,3}.png -geometry 600x400 images/montage_${base}0-3.png
    # -background none
    rm ${base}{0,1,2,3}.png
}

version=octa
vertical=1165
make_montage

version=squa
vertical=1250
make_montage
#+END_SRC

** Animate octahedron net to quasi grid

#+BEGIN_SRC jupyter-python :tangle scripts/animations.py :results silent :eval no-export
<<Octanet>>

degree = 3
animation = Octanet(
    scale=10, degree=degree,
    lines=Geometry(degree, color_palette=[colors.black, colors.canard, colors.purple, colors.orange])
)
animation.make_surface().write_to_png('images/octahedron_net.png')
animation.make_surface(1).write_to_png('images/octahedron_net_as_square.png')

animation_duration = 1.5
freeze_duration = .5
total_duration = animation_duration + freeze_duration
fps = 30
def generate_frame(time):
    return animation.make_surface(time / animation_duration).get_npimage()

from multiprocessing import Pool
pool = Pool()

import numpy as np
frames = list(pool.map(generate_frame, np.linspace(0, animation_duration, int(fps * animation_duration))))
pool.close()
pool.join()

idx = 0
def next_frame(_):
    global idx
    idx += 1
    return frames[idx - 1] if idx <= len(frames) else frames[-1]

from moviepy.editor import VideoClip
clip = VideoClip(next_frame, duration=total_duration)
clip.write_videofile('images/net_to_square_degree{}.mp4'.format(degree), fps=fps)
#+END_SRC

#+name: Octahedron net
[[file:images/octahedron_net.png]]

#+name: Octahedron as quasi square
[[file:images/octahedron_net_as_square.png]]

* References
 - https://en.wikipedia.org/wiki/Find_first_set#CTZ

 - http://old.cescg.org/CESCG97/marak/index.html (erosion, move)

 - https://news.ycombinator.com/item?id=8681899, http://experilous.com/1/blog/post/procedural-planet-generation (planet generation, move)

 - http://jsfiddle.net/rL0qmee9/ (procedural generation bookmarks, move)

 - https://www.w3schools.com/colors/colors_picker.asp (color palettes)
