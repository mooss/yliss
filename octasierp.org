#+property: header-args:jupyter-python :session sierp :results silent :tangle no :noweb no-export

* Development setup                                                :noexport:

** Python packages
Some illustrations and animations are generated with =gizeh= and =moviepy=, inspired by this [[http://zulko.github.io/blog/2014/09/20/vector-animations-with-python/][blogpost]].

They can be installed via pip:
#+BEGIN_SRC bash :eval never
pip install --user gizeh moviepy
#+END_SRC


* About mathematical rigour

The maths presented here will be hand-wavy most of the time and a lot of it will not be formally proved because I'm a lazy bastard who mostly want to program.
So do not expect much rigour.


* Octahedron and Sierpiński triangle

An octasierp is the brainchild of a regular octahedron and the Sierpiński triangle, the first is the platonic solid formed of 8 equilateral triangles and the second is a recursive subdivision of an equilateral triangle.
Each face of an octahedron can be divided into 4 smaller equilateral triangles which can themselves be divided and so on.
The number of subdivision of an octasierp is its degree $d \in \mathbb{N}$, with $d=0$ being the initial octahedron.

An interesting property of octasierp is that they can almost be represented as a square grid.


* Diagrams generation

The diagrams are generated in python, using =gizeh= for the geometry and =moviepy= for stiching images together into animations.

#+BEGIN_SRC jupyter-python :tangle scripts/animations.py
import gizeh as gz
#+END_SRC

Images are saved in the =images= folder:
#+BEGIN_SRC jupyter-python :tangle scripts/animations.py
import os
os.chdir('images')
#+END_SRC

** Colors

I use a =SimpleNamespace= to store some colors that I want to use (the names are probably innacurate).
The obvious alternative would be to use a =class= but that would be tedious to initialize, or a =dict= but I want to be able to access members through the dot operator.

#+name: Colors
#+BEGIN_SRC jupyter-python
from types import SimpleNamespace
colors = SimpleNamespace(
    canard=(0, .6, .6),
    turquoise=(0, 1, 1),
    orange=(1, .5, 0),
    mandarine=(1, .8, 0),
    purple=(.4, 0, .4),
    violet=(.6, .2, .6),
    black=(0, 0, 0),
    evergrey=(.5, .5, .5),
    white=(1, 1, 1),
    forest=(0, .4, 0),
    grass=(0, .6, .2),
    ocean=(0, .2, .8),
    river=(0, .4, .8),
    air=(0, 0, 0, 0)
)
#+END_SRC

Here are some color palettes:

#+name: Colors
#+BEGIN_SRC jupyter-python
palette_colorful = [
    (colors.canard, colors.turquoise),
    (colors.purple, colors.violet),
    (colors.orange, colors.mandarine),
    (colors.black, colors.white),
    (colors.black, colors.white)
]
palette_gfg = [
    (colors.white, colors.canard),
    (colors.canard, colors.purple),
    (colors.purple, colors.orange),
    (colors.orange, colors.black),
    (colors.black, colors.white)
]
palette_gfgpoints = [
    (colors.air, colors.canard),
    (colors.air, colors.purple),
    (colors.air, colors.orange),
    (colors.air, colors.evergrey),
    (colors.air, colors.air),
    (colors.air, colors.canard)
]
palette_psyche = [
    (colors.canard, colors.white),
    (colors.orange, colors.white),
    (colors.purple, colors.white),
    (colors.black, colors.white),
    (colors.black, colors.white),
]
#+END_SRC

** Geometric primitives

The class =Geometry= is here to provide an abstraction about the way a subdivided object is to be drawn.
For the moment, geometric primitives only have two caracteristics at a given degree of subdivision :
 - their color as a tuple of three or four floats =(r, g, b)= or =(r, g, b, a)=, and
 - their size as a factor by which to multiply a reference size.

Thus, =Geometry= is initialised with:
 - a color palette (a list of colors), and
 - a size policy (a function $f : \mathbb{N} \rightarrow \mathbb{R}^+$).

The geometry parameters for degree $d$ can then simply be obtained with square brackets indexing (like =geometry[d]=), thanks to the method =__getitem__=.

#+name: Geometric primitives
#+BEGIN_SRC jupyter-python
class Geometry(object):
    def __init__(self,
                 degree,
                 color_palette=[(0, 0, 0)],
                 size_policy=None
    ):
        self.color_palette = color_palette
        if size_policy is None:
            self.size_policy = decrease_size_linearly(degree)
        else:
            self.size_policy = size_policy

    def __getitem__(self, current):
        return self.color_palette[current % len(self.color_palette)],\
            self.size_policy(current)
#+END_SRC

*** Decrease size linearly

The default element size policy is to decrease the size of a primitive linearly with the degree of subdivision.
Thus, the aim of this policy is to provide a factor $factor_{current}$ by which to multiply an initial size such that $1 \geq factor_{current} \geq minFactor$, where $current$ is the current degree of subdivision.

We know that $factor_0 = 1$ and $factor_{degree} = minFactor$.
Since we want to decrease the size linearly, we also know that $factor_{current} = a \times current + b$, thus
\begin{cases}
  a \times 0 + b = 1 \Leftrightarrow b = 1\\
  a \times degree + b = minFactor \Leftrightarrow a = \frac{minFactor -1}{degree}
\end{cases}

We finally obtain the function $factor_{current} = \frac{minFactor - 1}{degree} \times current + 1$.
This function is not defined when $degree = 0 so this need to be addressed as a special case.

After playing a bit with $minFactor$ value, it looks like .25 is a good value.

#+name: Geometric primitives
#+BEGIN_SRC jupyter-python
def decrease_size_linearly(degree, min_factor=.25):
    def result(current):
        if degree == 0:
            return 1
        return current * (min_factor - 1) / degree + 1
    return result
#+END_SRC

** Triangle
:PROPERTIES:
:header-args:jupyter-python+: :eval never
:END:

A =Triangle= represents one of the triangles of an octasierp net, its properties are:
 - =degree= :: Degree of subdivision.
 - =initial_width= :: Width of the first element.
 - =color_palette= :: Color palette for points and lines.
                   This is a list whose elements describe the colors at a given degree.
                   If the list is too short, the colors are cycled through again.
                   The elements take the form of a 2-uple of colors with first the color for the lines and then the color for the points.
                   For example, the default color code is black for lines and white for points, resulting in the element =((0, 0, 0), (1, 1, 1))=.

A =Triangle= has no coordinate of its own because the coordinates of its constituent points will be used in =generate=, whose role is to create a Gizeh object representing the geometry of the triangle.

#+name: Triangle
#+BEGIN_SRC jupyter-python
<<Geometric primitives>>

class Triangle(object):
    def __init__(self, degree, initial_width, points=None, lines=None):
        self.degree = degree
        self.initial_width = initial_width
        if points is None:
            self.points = Geometry(degree)
        else:
            self.points = points
        if lines is None:
            self.lines = Geometry(degree)
        else:
            self.lines = lines

    def generate(self, a, b, c):
        lines, points = self.geometry(a, b, c)
        return gz.Group(lines + points)

    def geometry(self, a, b, c, current=0):
        <<Initiate triangle geometry>>
        <<Subdivise triangle>>
#+END_SRC

*** Initiate triangle geometry
We use the =Geometry= object instanciated in the constructor to get the color and deduce the line width at the current degree, making sure that it is at least 1.

#+name: Initiate triangle geometry
#+BEGIN_SRC jupyter-python
color, factor = self.lines[current]
width = max(1, self.initial_width * factor)
#+END_SRC

The initial triangle is simply three lines joining the three points, kept in a list that will eventually hold the subsequent triangles.
#+name: Initiate triangle geometry
#+BEGIN_SRC jupyter-python
lines = [gz.polyline(
    [a, b, c, a],
    stroke_width=width,
    stroke=color
)]
#+END_SRC

The same idea is repeated to create an initial point ...:
#+name: Initiate triangle geometry
#+BEGIN_SRC jupyter-python
color, factor = self.points[current]
width = max(1, self.initial_width * factor)
point = gz.circle(r=width, fill=color)
#+END_SRC

... from which the three points are constructed:
#+name: Initiate triangle geometry
#+BEGIN_SRC jupyter-python
points = list(map(point.translate, (a, b, c)))
#+END_SRC

*** Subdivise triangle

Now that the geometric elements have been dealt with, only the recursive calls - or lack thereof - remains.
The generation is over when the maximal degree has been reached:
#+name: Subdivise triangle
#+BEGIN_SRC jupyter-python
if current == self.degree:
    return points, lines
#+END_SRC

Otherwise, we make recursive calls to =geometry=, using the midpoints of the three original points.
The order of the points and of the lines is important because the graphical elements are drawn in the order of their apparition and we want to make sure that the earliest subdivisions are written over the subsequent ones.
#+name: Subdivise triangle
#+BEGIN_SRC jupyter-python
ab = midpoint(a, b)
ac = midpoint(a, c)
bc = midpoint(b, c)
for sierpinski in [(a, ab, ac), (b, ab, bc), (c, ac, bc), (ab, ac, bc)]:
    recurse_points, recurse_lines = self.geometry(*sierpinski, current + 1)
    lines = recurse_lines + lines # order is important
    points = recurse_points + points
return points, lines
#+END_SRC

With =midpoint= being defined as:
#+name: Triangle
#+BEGIN_SRC jupyter-python
def midpoint(left, right):
    return ((left[0] + right[0]) / 2, (left[1] + right[1]) / 2)
#+END_SRC

** Octasierp net

#+name: Octanet
#+BEGIN_SRC jupyter-python :eval never
<<Triangle>>
<<Colors>>

import numpy as np
import math

class Octanet(object):
    def __init__(
            self, scale, degree=0, points=None, lines=None,
    ):
        self.degree = degree
        self.side = 100 * scale
        stroke_width = scale
        horizontal_margin = 10 * scale
        vertical_margin = 30 * scale

        self.altitude = math.sqrt(3) * (self.side / 2)
        self.width = int(4 * self.altitude)
        self.height = 2 * self.side
        self.left = horizontal_margin
        self.top = vertical_margin
        self.right = self.width + horizontal_margin
        self.bottom = self.height + vertical_margin

        self.surface_parameters = {
            'width': self.width + 2 * horizontal_margin,
            'height': self.height + 2 * vertical_margin,
            'bg_color': (1, 1, 1)
        }

        triangle = Triangle(degree, stroke_width, points=points, lines=lines)
        triangle = Triangle(degree, stroke_width)
        self.triangles = triangle.generate

    def make_net(self, progress):
        vertical_correction = progress * self.side / 2
        h_ab = (self.left + self.right) / 2
        v_a = self.bottom - self.side / 2 - vertical_correction
        v_b = self.bottom - self.side * 1.5 - vertical_correction
        a = (h_ab, v_a)
        b = (h_ab, v_b)

        angle = math.pi / 3 + progress * (math.pi / 6)
        cosa = math.cos(angle)
        sina = math.sin(angle)
        # Simplified from cosa * (h_ab - h_ab) - sina * (v_b - v_a) + h_ab
        h_c = - sina * (v_b - v_a) + h_ab
        # Simplified from sina * (h_ab - h_ab) + cosa * (v_b - v_a) + v_a
        v_c = cosa * (v_b - v_a) + v_a
        c = (h_c, v_c)

        t1 = self.triangles(a, b, c)

        twin_point = ((h_ab + h_c) / 2, (v_b + v_c) / 2)
        t2 = t1.rotate(math.pi, twin_point)

        first_quarter = gz.Group([t1, t2])
        second_quarter = first_quarter.rotate(-angle, a)
        third_quarter = first_quarter.rotate(-2 * angle, a)
        fourth_quarter = first_quarter.rotate(angle, a)
        return gz.Group([first_quarter, second_quarter, third_quarter, fourth_quarter])

    def make_surface(self, progress=0):
        surface = gz.Surface(**self.surface_parameters)
        self.make_net(progress).draw(surface)
        return surface
#+END_SRC

** Animate octahedron net to quasi grid

#+BEGIN_SRC jupyter-python :tangle scripts/animations.py :results silent
<<Octanet>>

degree = 4
animation = Octanet(scale=6, degree=degree)
animation.make_surface().write_to_png('octahedron_net.png')
animation.make_surface(1).write_to_png('octahedron_net_as_square.png')

animation_duration = 1.5
freeze_duration = .5
total_duration = animation_duration + freeze_duration
fps = 30
def generate_frame(time):
    return animation.make_surface(time / animation_duration).get_npimage()

from multiprocessing import Pool
pool = Pool()

frames = list(pool.map(generate_frame, np.linspace(0, animation_duration, int(fps * animation_duration))))
pool.close()
pool.join()
idx = 0
def next_frame(_):
    global idx
    idx += 1
    return frames[idx - 1] if idx <= len(frames) else frames[-1]

from moviepy.editor import VideoClip
clip = VideoClip(next_frame, duration=total_duration)
clip.write_videofile('net_to_square_degree{}.mp4'.format(degree), fps=fps)
#+END_SRC


#+name: Octahedron net
[[file:images/octahedron_net.png]]

#+name: Octahedron as quasi square
[[file:images/octahedron_net_as_square.png]]


* References
 - https://en.wikipedia.org/wiki/Find_first_set#CTZ

 - http://old.cescg.org/CESCG97/marak/index.html (erosion, move)

 - https://news.ycombinator.com/item?id=8681899, http://experilous.com/1/blog/post/procedural-planet-generation (planet generation, move)

 - http://jsfiddle.net/rL0qmee9/ (procedural generation bookmarks, move)

 - https://www.w3schools.com/colors/colors_picker.asp (color palettes)
