#+title: Octasierp: a solid foundation
#+author: mooss
#+property: header-args:bash :eval never
#+property: header-args:cpp :eval never :main no :noweb no-export
#+property: header-args:python :noweb no-export :results output :wrap "src text :minipage" :eval never

* Prelude
** About mathematical rigour

I'll be sometimes hand-wavy with the maths here both because I don't want to bother and because I don't know much about it.


* Of octahedrons and Sierpiński triangles
:PROPERTIES:
:header-args:python+: :eval no-export
:END:

This document is about octasierps, fractal solids destined to be used as the basis for a procedurally generated planet.

An octasierp is the brainchild of a regular octahedron and the Sierpiński triangle, the first is the platonic solid formed of 8 equilateral triangles and the second is a recursive subdivision of an equilateral triangle.
Indeed, since each face of an octahedron is an equilateral triangle, it can be divided into 4 smaller equilateral triangles which can themselves be divided and so on, thus adapting the concept of Sierpiński triangles to the third dimension.

This recursive structure is caracterised by its subdivision degree $d \in \mathbb{N}$, which is the number of successive subdivisions necessary to construct it.
The simplest octasierp occurs when $d=0$ and corresponds to an octahedron.

** Goals

This is my second attempt at generating a procedural planet using an octahedron as the starting point.

The main problem I encountered last time was finding a good data structure for my subdivided octahedron as well as implementing the code to get the neighbours of a point.
I ended up using a convoluted approach that I can't even remember now.
Thankfully I don't have to, since I've collected some observations that will help me to build a much simpler and intuitive data structure than last time.

A good data structure for an octasierp must meet some criteria:
 - A coordinate system, both for mental representation and as a programming primitive.
 - A support for different levels of detail, meaning the possibility to further subdivise the structure without having to reconstruct the whole object.
 - A fast way to request the neighbours of a point.

# Note: those goals are not static, the definition of a good data structure will probably expand when I'll get a better grasp on the problem.

** Some terminology

When used in isolation, degree is the shorthand for degree of subdivision.
I must offer this clarification because, unfortunately there are other degrees, such as the degree of appearance.

** Geometric visualisation

I think an appropriate first step to find the best underlying representation of an octasierp is to visualise the problem, since the subject of study is a geometric concept.

*** Octahedron net

An octahedron can be represented in two dimensions as a net, a flattened arrangement of the eight sides, ready to be folded back into three dimensions.
For an illustration of both the subdivision process and the net of an octahedron, extended to an octasierp, see figure [[montage_octa_degree_0-3]].

#+name: montage_octa_degree_0-3
#+caption: Octasierp net for degrees 0, 1, 2 and 3
[[file:images/montage_net_octa_degree_0-3.png]]

*** Squarified net

An interesting property of octasierps is that when you inflate the central angle to 90\textdegree{}, they can almost be represented as a square grid with additional diagonal connections as shown in figure [[montage_squa_degree_0-3]].
A strange thing about this representation is that points are neighbouring each other along the sides in a symmetric pattern.
This representation is strongly reminiscent of the Peirce quincuncial projection[fn::See https://en.wikipedia.org/wiki/Peirce_quincuncial_projection.], all the more because the end goal of this project is to generate a planet.

#+attr_latex: :placement [H]
#+name: montage_squa_degree_0-3
#+caption: Octasierp squarified net for degrees 0, 1, 2 and 3
[[file:images/montage_net_squa_degree_0-3.png]]

The figure [[montage_squa_degree_0-3]] provides a nice means of visualisation, but since it's an image (i.e. a binary file), its not so easy to hack upon, so for the rest of the document I will use a text representation to illustrate the various steps of the implementation.
See below the textual equivalent of figure [[montage_squa_degree_0-3]] [fn::=x= are points, =-= are horizontal lines, =|= are vertical lines and =+= are corners. The representations have been scaled to all appear at the same size, that is normally not the case.]:
#+begin_src python :exports results :eval no-export
<<Textual squarified net>>
between = ' ' * 25
def construct(degree):
    return SquareNet(
        3, list(range(degree+1)),
        display_redundant=Quarter.POINT
    ).repr()
for deg0, deg1 in zip(construct(0), construct(1)):
    print(deg0 + between + deg1)
print('           degree = 0           ' + between + '            degree = 1')
print()
print()
for deg2, deg3 in zip(construct(2), construct(3)):
    print(deg2 + between + deg3)
print('           degree = 2           ' + between + '            degree = 3')
#+end_src

#+RESULTS:
#+begin_src text :minipage
x---------------x---------------x                         x-------x-------x-------x-------x
|               |               |                         |               |               |
|               |               |                         |               |               |
|               |               |                         |               |               |
|               |               |                         x       x       x       x       x
|               |               |                         |               |               |
|               |               |                         |               |               |
|               |               |                         |               |               |
x---------------X---------------x                         x-------x-------X-------x-------x
|               |               |                         |               |               |
|               |               |                         |               |               |
|               |               |                         |               |               |
|               |               |                         x       x       x       x       x
|               |               |                         |               |               |
|               |               |                         |               |               |
|               |               |                         |               |               |
x---------------x---------------x                         x-------x-------x-------x-------x
           degree = 0                                                degree = 1


x---x---x---x---x---x---x---x---x                         x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x
|               |               |                         x x x x x x x x x x x x x x x x x
x   x   x   x   x   x   x   x   x                         x x x x x x x x x x x x x x x x x
|               |               |                         x x x x x x x x x x x x x x x x x
x   x   x   x   x   x   x   x   x                         x x x x x x x x x x x x x x x x x
|               |               |                         x x x x x x x x x x x x x x x x x
x   x   x   x   x   x   x   x   x                         x x x x x x x x x x x x x x x x x
|               |               |                         x x x x x x x x x x x x x x x x x
x---x---x---x---X---x---x---x---x                         x-x-x-x-x-x-x-x-X-x-x-x-x-x-x-x-x
|               |               |                         x x x x x x x x x x x x x x x x x
x   x   x   x   x   x   x   x   x                         x x x x x x x x x x x x x x x x x
|               |               |                         x x x x x x x x x x x x x x x x x
x   x   x   x   x   x   x   x   x                         x x x x x x x x x x x x x x x x x
|               |               |                         x x x x x x x x x x x x x x x x x
x   x   x   x   x   x   x   x   x                         x x x x x x x x x x x x x x x x x
|               |               |                         x x x x x x x x x x x x x x x x x
x---x---x---x---x---x---x---x---x                         x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x
           degree = 2                                                degree = 3
#+end_src

Everything related to the generation of the textual representation is gathered in section [[#textual_quarter]].

**** Four quarters

We can divise the squarified net into four quarters, each being a rotated image of the others around the central point.
This means rules devised for one quarter can easily be adapted to the others.

Those quarters are identified by a number ranging from 0 to 3, with quarter 0 being the top-right one and the others being numerated counter-clockwise.
The counter-clockwise rotation has been chosen to correspond to the sense of trigonometric rotation.

**** Two poles and four corners

To pay hommage to both the planet metaphor and the peirce quincuncial projection, the central point is the north pole, while the four extremes are one and the same, the south pole.

The four midpoints of the sides are actually just random points on the equator but since they also are initial vertices of the octasierp, let's give them a name ; the four corners of the world, with the right one being corner 0 and the others numerated once again counter-clockwise.
I know that the four corners are a bit confusing because from the 2d perspective of the squarified net, the corners of the square are actually the south pole but it will make more sense in 3d and I really like the term, so it stays.

** Coordinate system

Based on the observation of the squarified net, the natural coordinate system for an octasierp is an indexing along the axis between the central point and corner 0 (the x-axis) and the one between the central point and corner 1 (the y-axis).
In this scheme, the central point (of coordinates $(0, 0)$) is also the north pole.
This is the coordinate system we will use from now on, albeit we will sometimes call it the global coordinate system, because a system local to each quarter will be established later.

Since an octasierp is a discrete structure, the coordinates will be integer-based.
An unfortunate side effect of integer coordinates is that except for the north pole, points will not keep their coordinates when the degree of subdivision changes.
For example, as is illustrated below, when $degree = 0$, corner 0 is at the coordinates $(1, 0)$ and when $degree = 1$ it is at the coordinates $(2, 0)$.
In the end, the rule is that coordinates only make sense at a given degree.

#+begin_src python :exports results
<<Textual squarified net>>

def listr_replace(listr, replacements):
    for row, col, content in replacements:
        listr[row] = listr[row][:col] + content + listr[row][col+1:]

deg0 = SquareNet(0, None, show_axis=True).repr()
listr_replace(deg0, [(2, 10, 'Z   <====== Corner 0 at degree 0')])
print('\n'.join(deg0))

print()
print('__________________________________________')
print()
deg1 = SquareNet(1, None, show_axis=True).repr()
listr_replace(deg1, [(3, 14, 'Z   <== Corner 0 at degree 1')])
print('\n'.join(deg1))
#+end_src

#+RESULTS:
#+begin_src text :minipage
   ^
+1 |  +-+-+
 0 |  +-o-Z   <====== Corner 0 at degree 0
-1 |  +-+-+
   +-------->
      1 0 1
      -   +

__________________________________________

   ^
+2 |  +---+---+
+1 |  |   |   |
 0 |  +---o---Z   <== Corner 0 at degree 1
-1 |  |   |   |
-2 |  +---+---+
   +------------>
      2 1 0 1 2
      - -   + +
#+end_src


Another problem is that there is a redundancy in this coordinate system that needs to be resolved (most strikingly, the south pole is present four times).
First we will need to derive the cardinality of a half-axis, that is to say the number of points on it.
Then that property will be used to describe precisely the redundancy problem.
Finally, I will present the solution I opted for to resolve the situation and fix the coordinate system.

*** Half-axis cardinality

To pass from degree $d$ to degree $d + 1$, points are inserted between every adjacent point.
From degree 0 to degree 1, 1 point is added, from degree 1 to 2, 2 points are inserted, then 4, then 8, then $2^4$, then $2^5$, and so on.
Another way to see it is that the number of points added at degree $d + 1$ is the number of segments at degree $d$ ; we start with one segment to subdivise, then two, then four and so on.

Based on what we have deduced so far, we can express this number with the relation $\vert points_{d+1} \vert = \vert points_d \vert + 2^{d}$ with $d \in \mathbb{N}$.
The problem is that I don't know anymore how to process this kind of recurrence relationships and I can't be bothered to find how so let's just make a hasardous guess from the first five numbers, shown in table [[hasardous_guess]].
A most interesting pattern made evident by this table is that in each line we add $2^d$ to itself, plus one.
Thus we deduce that $\vert points_{d+1} \vert = 2 \times 2^d + 1 \Leftrightarrow \vert points_{d+1} \vert = 2^{d+1} + 1 \Leftrightarrow \vert points_d \vert = 2^{d} + 1$.

#+name: hasardous_guess
#+caption: Small amount of data to support my dubious claim (no mathematicians were hurt in the process (not on purpose at least))
| $d$ | $\vert points_d \vert$ | $2^{d}$ | $\vert points_{d+1} \vert$ |
|-----+------------------------+---------+----------------------------|
|   0 |                      2 |       1 |                          3 |
|   1 |                      3 |       2 |                          5 |
|   2 |                      5 |       4 |                          9 |
|   3 |                      9 |       8 |                         17 |
|   4 |                     17 |      16 |                         33 |

*** Points redundancy

A peculiar caracteristic of the squarified-net-inspired coordinate system is that there is a redundancy at the edges, where the four corners act as a center of symmetry.
For example, at degree 2 the points $A = (-3, 4)$ and $B = (3, 4)$ are the same, as well as the points $C = (4, 2)$ and $D = (4, -2)$:
#+name: Octasierp redundancy example
#+begin_src python :exports none
<<Textual squarified net>>
result = SquareNet(2, [0, 1, 2], display_redundant=display_redundant).repr()
first = result[0]
result[0] = first[:2] + 'A' + first[3:-3] + 'B' + first[-2:]
result[2] = result[2][:-1] + 'C'
result[6] = result[2][:-1] + 'D'

# Terribly cool hack, don't try this at home.
top = [0] * 5
<<Add axis to SquareNet representation>>
print('\n'.join(result))
#+end_src

#+begin_src python :exports results :eval no-export
display_redundant='x'
<<Octasierp redundancy example>>
#+end_src

#+RESULTS:
#+begin_src text :minipage
   ^
+4 |  x-A-x-x-x-x-x-B-x
+3 |  x x x x x x x x x
+2 |  x x x x x x x x C
+1 |  x x x x x x x x x
 0 |  x-x-x-x-X-x-x-x-x
-1 |  x x x x x x x x x
-2 |  x x x x x x x x D
-3 |  x x x x x x x x x
-4 |  x-x-x-x-x-x-x-x-x
   +-------------------->
      4 3 2 1 0 1 2 3 4
      - - - -   + + + +
#+end_src

We can deduce a general rule from this example.

First we need to find what are the extreme values of our coordinate system at a given degree.
The extreme value we are looking for here will be the number of points on an half-axis minus one, since the numerotation starts at 0.
We already know the number of points on a half-axis at degree $d$ to be $\vert points_d \vert = 2^{d} + 1$ so the extreme value we are looking for is $2^d$.

Since the centers of symmetry are the four corners, the following rules can be deduced for the redundant points at degree $d$ depending on the corners they are centered around:
 - *corner 0*: $\{(2^d, n), (2^d, -n)\}$
 - *corner 1*: $\{(n, 2^d), (-n, 2^d)\}$
 - *corner 2*: $\{(-2^d, n), (-2^d, -n)\}$
 - *corner 3*: $\{(n, -2^d), (-n, -2^d)\}$
With $n \in \mathbb{N}$ and $0 \leq n \leq 2^d$, so technically the centers of symmetry are included (when $n=0$).
Note that a special case arise when $n=2^d$, where the redundant points - for all the corners - are the south pole.

When applied to our four example points, the rules are correctly implying that:
 - $A = (-3, 4)$ and $B = (3, 4)$ are centered around corner 1 with $n=3$.
 - $C = (4, 2)$ and $D = (4, -2)$ are centered around corner 0 with $n=2$.

*** Border disputes and canonical quarters

Because there are redundancies in the coordinate system, it will be useful to define the canonical quarter of a redundant point, that is to say the one to which they "officially" belong.
Two main cases need to be treated:
 - The poles because they are on every quarter.
 - The borders between quarters (excluding the poles) because they are shared between two quarters.

There are only two poles, so they cannot be distributed equally between the four quarters.
Rather that attributing one pole to, say the quarter 0 and another to the quarter 2, I prefer to give them both to quarter 0 because:
 1. It is more memorable.
 2. It gets the message across that quarter 0 is the reference quarter, or The canonical quarter, if you will.

Because quarter 1, 2 and 3 are essentially a rotation of quarter 0, we resolve the border dispute between quarters by using this property.
The top and bottom border of quarter 0, i.e. its border with quarter 1 and quarter 3 respectively are attributed to quarter 0.
By rotation, every border has its quarter and every quarter has its border.

Beyond those two cases we just resolved lurks a third one, the corners.
Even though they technically belong to the borders, the rotation mecanism would still make them shared between quarters because there would be two corners per quarter while there is the same number of corners and quarters (4).
To solve this last issue, we'll just say that the bottom right corner belongs to quarter 0 and as always, this rule applies by rotation to the other quarters.

Here is the updated example from the previous section reflecting the changes we just made, with =v= characters representing a redundant point[fn::The canonical counterparts of those points are still represented with an =x=.]:
#+begin_src python :exports results :eval no-export
display_redundant=True
<<Octasierp redundancy example>>
#+end_src

#+RESULTS:
#+begin_src text :minipage
   ^
+4 |  v-A-v-v-x-x-x-B-x
+3 |  x x x x x x x x v
+2 |  x x x x x x x x C
+1 |  x x x x x x x x v
 0 |  x-x-x-x-X-x-x-x-x
-1 |  v x x x x x x x x
-2 |  x x x x x x x x D
-3 |  v x x x x x x x x
-4 |  v-x-x-x-x-v-v-v-v
   +-------------------->
      4 3 2 1 0 1 2 3 4
      - - - -   + + + +
#+end_src

*** About the resemblance

I must address the fact that the representation without redundant points bears an unfortunate resemblance with a swastika:
#+begin_src python :exports results :eval no-export
<<Textual squarified net>>
print(SquareNet(2, '*'))
#+end_src

#+RESULTS:
#+begin_src text :minipage
+-------x-x-x-x-x
x x x x x x x x |
x x x x x x x x |
x x x x x x x x |
x-x-x-x-X-x-x-x-x
| x x x x x x x x
| x x x x x x x x
| x x x x x x x x
+-x-x-x-x-------+
#+end_src

At first I tried to find other representations but found no other fitting my needs.
Then I thought about at least trying to make the arms point the other way but this contradicted the intuitive representation I had in mind so I finally decided to not let a hideous historical artifact affect a technical decision.
If you are offended by this decision I'm sorry about it.


* Memory representation

Now that the bases of the coordinate system are solidified, the next step is to build a structure that can hold a value for each valid coordinates.
The challenge here is that an octasierp can *almost* be reduced to a square grid, which is the polite way to say can it *cannot* be reduced to a square grid.

This is unfortunate because a square grid is excessively easy to represent in memory.
Had an octasierp been a square of side $n$, we would have used an array of $n \times n$ values and fetched the value of coordinate $(x, y)$ at the index $x \times n + y$.

Since we cannot do that, I will at first present the structure I choosed, that is to say how the points of one quarter are stored.
Then I will explain the corresponding indexing scheme, that is to say how to find a point corresponding to a given coordinate.
Finally, this representation will be expanded to the full octahedron (the three other quarters).

** Structure

One of the goals previously set is to support different levels of detail, thus the basic structure will hold the points at a given degree and a collection of this structure will form a quarter.

This notably means that given the coordinates of one point inside the quarter, we need to find the degree at which it first appeared before accessing it.
This is linked with what I called the binary degree of a number.

*** Binary degree

We can simplify the problem of finding the degree of appearance of a point by going from a rectangle grid to discrete points on a line.
We will explore this simplification in this section, with a short detour through 1-dimension territory.

At degree 0, there are two points (table [[bindeg_x0]]), at degree 1 one more point appears (table [[bindeg_x1]]), at degree 2 there are two more points (table [[bindeg_x2]]), four more at degree 3 (table [[bindeg_x3]]), then eight, then sixteen, and so on.
An interesting thing to note here is that since a point is introduced in between two adjacent points, a point's index is doubled at each subdivision so what is point 1 at subdivision degree 1 becomes point 4 at subdivision degree 3, thanks to two consecutive multiplications.

#+attr_latex: :placement [H]
#+name: bindeg_x0
#+caption: Degrees of appearance at subdivision degree 0
| point index          | 0 | 1 |
|----------------------+---+---|
| degree of appearance | 0 | 0 |

#+attr_latex: :placement [H]
#+name: bindeg_x1
#+caption: Degrees of appearance at subdivision degree 1
| point index          | 0 | 1 | 2 |
|----------------------+---+---+---|
| degree of appearance | 0 | 1 | 0 |

#+attr_latex: :placement [H]
#+name: bindeg_x2
#+caption: Degrees of appearance at subdivision degree 2
| point index          | 0 | 1 | 2 | 3 | 4 |
|----------------------+---+---+---+---+---|
| degree of appearance | 0 | 2 | 1 | 2 | 0 |

#+attr_latex: :placement [H]
#+name: bindeg_x3
#+caption: Degrees of appearance at subdivision degree 3
| point index          | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
|----------------------+---+---+---+---+---+---+---+---+---|
| degree of appearance | 0 | 3 | 2 | 3 | 1 | 3 | 2 | 3 | 0 |


I named $bindeg_{i,d}$ (binary degree) the function outputting the degree of appearance of a point when given its index $i$ and a global degree of subdivision $d$.
We have $i \in \mathbb{N}$ and $d \in \mathbb{N}$, with $0 \leq i \leq 2^d$.
In my (rather uninformed) opinion, it behaves as some kind of weird distance between $i$ and $2^d$, in that it is inversely proportional to the number of times the index can be divided by two while being bounded by $d$.

We can enumerate the binary degrees relatives to $2^3 = 8$ like so (this is just another way to present the data from table [[bindeg_x3]]):
 - $0 = bindeg_{0,3} = bindeg_{8, 3}$
 - $1 = bindeg_{4,3}$
 - $2 = bindeg_{2,3} = bindeg_{6,3}$
 - $3 = bindeg_{1,3} = bindeg_{3,3} = bindeg_{5,3} = bindeg_{7,3}$

The key observation is that the points with the highest binary degree are all the odd ones.
This phenomena can be explained by construction:
 - When going from degree $d - 1$ to degree $d$, we insert a new point between the first two points.
 - This new point is now point $1$ and the points to its right are increased by $1$.
 - The next point will insert itself at the right of what was the odd point $1$ but now is the even point $2$ and we find ourselves in the initial case, we are inserting the new point into a odd position, thus moving the next point into an even position.
 - This situation repeats itself until the end of the sequence and explains why a point's index doubles every subdivision.

We now have at our disposition three elements which can be used to construct a definition for the binary degree:
 1. The first and last indexes, $0$ and $2^d$ always appears at degree $0$ ($bindeg_{0, d} = bindeg_{2^d, d} = 0$).
 2. Indexes are multiplied by two every subdivision, while their degree of appearance stays the same ($bindeg_{i,d} = bindeg_{2i, d + 1}$).
 3. Odd indexes have the maximal binary degree ($i \bmod 2 = 1 \implies bindeg_{i, d} = d$).


From 1., we have the initial values.
From 3., we have the values of odd points.
By combining 2. and 3., we can deduce the values of the other even points, because 2. is equivalent to $i \bmod 2 = 0 \implies bindeg_{i,d} = bindeg_{\frac{i}{2},d-1}$, thus we can divise even values until they are odd to obtain their binary degree.

A naive C++ implementation will look like this:
#+name: Naive bindeg
#+begin_src cpp
unsigned int naive_bindeg(unsigned int index, unsigned int degree){
    if(index % 2 == 1 || degree == 0)
        return degree;
    return naive_bindeg(index >> 1, degree - 1);
}
#+end_src

The following minimal test should output data matching with table [[bindeg_x3]].
#+begin_src cpp :includes <iostream> :eval no-export :wrap "src text" :exports both
<<Naive bindeg>>
int main(){
    unsigned int degree = 3;
    auto rightmost = 1 << degree;
    for(unsigned int i = 0; i <= rightmost; ++i){
        std::cout << "bindeg(" << i << "," << degree << ") = " << naive_bindeg(i, degree) << "\n";
    }
    return 0;
}

#+end_src

#+RESULTS:
#+begin_src text :minipage
bindeg(0,3) = 0
bindeg(1,3) = 3
bindeg(2,3) = 2
bindeg(3,3) = 3
bindeg(4,3) = 1
bindeg(5,3) = 3
bindeg(6,3) = 2
bindeg(7,3) = 3
bindeg(8,3) = 0
#+end_src

The binary degree function will be fundamental to point indexation in an octasierp and can probably be optimised using =<strings.h>='s =ffs= (find first set).


* Diagrams generation

The diagrams are generated in python, using Gizeh for the geometry and =moviepy= for stiching images together into animations, inspired by this [[http://zulko.github.io/blog/2014/09/20/vector-animations-with-python/][blogpost]].

They can be installed via pip:
#+begin_src bash :eval never
pip install --user gizeh moviepy
#+end_src


Images are saved in the =images= folder and the scripts are supposed to be executed (that is to say after they have been tangled) from the root of the project like so:
#+begin_src bash
./script/your-favorite-script.sh
#+end_src

** Colors
:PROPERTIES:
:header-args:python+: :noweb-ref "Colors"
:END:

I use a =SimpleNamespace= to store some colors that I want to use (the names are probably innacurate).
The obvious alternative would be to use a =class= but that would be tedious to initialize, or a =dict= but I want to be able to access members through the dot operator.

#+begin_src python
from types import SimpleNamespace
colors = SimpleNamespace(
    canard=(0, .6, .6),
    turquoise=(0, 1, 1),
    orange=(1, .5, 0),
    mandarine=(1, .8, 0),
    purple=(.4, 0, .4),
    violet=(.6, .2, .6),
    black=(0, 0, 0),
    evergrey=(.5, .5, .5),
    white=(1, 1, 1),
    forest=(0, .4, 0),
    grass=(0, .6, .2),
    ocean=(0, .2, .8),
    river=(0, .4, .8),
    air=(0, 0, 0, 0)
)
#+end_src

Here are some color palettes:

#+begin_src python
palette_colorful = [
    (colors.canard, colors.turquoise),
    (colors.purple, colors.violet),
    (colors.orange, colors.mandarine),
    (colors.black, colors.white),
    (colors.black, colors.white)
]
palette_gfg = [
    (colors.white, colors.canard),
    (colors.canard, colors.purple),
    (colors.purple, colors.orange),
    (colors.orange, colors.black),
    (colors.black, colors.white)
]
palette_gfgpoints = [
    (colors.air, colors.canard),
    (colors.air, colors.purple),
    (colors.air, colors.orange),
    (colors.air, colors.evergrey),
    (colors.air, colors.air),
    (colors.air, colors.canard)
]
palette_psyche = [
    (colors.canard, colors.white),
    (colors.orange, colors.white),
    (colors.purple, colors.white),
    (colors.black, colors.white),
    (colors.black, colors.white),
]
#+end_src

** Basic =Geometry=
:PROPERTIES:
:header-args:python+: :noweb-ref "Geometric primitives"
:END:

The class =Geometry= is here to provide an abstraction about the way a subdivided object is to be drawn.
For the moment, geometric primitives only have two caracteristics at a given degree of subdivision :
 - their color as a tuple of three or four floats =(r, g, b)= or =(r, g, b, a)=, and
 - their size as a factor by which to multiply a reference size.

Thus, =Geometry= is initialised with:
 - A color palette (a list of colors).
 - A size policy (a function  $f : \mathbb{N} \rightarrow \mathbb{R}^+$ associating a subdivision degree to a desired size).

The geometry parameters for degree $d$ can then simply be obtained with square brackets indexing (like =geometry[d]=), thanks to the method =__getitem__=.

#+begin_src python
class Geometry(object):
    def __init__(self,
                 degree,
                 color_palette=[(0, 0, 0)],
                 size_policy=None
    ):
        self.color_palette = color_palette
        if size_policy is None:
            self.size_policy = decrease_size_linearly(degree)
        else:
            self.size_policy = size_policy

    def __getitem__(self, current):
        return self.color_palette[current % len(self.color_palette)],\
            self.size_policy(current)
#+end_src

*** Decrease size linearly

The default element size policy is to decrease the size of a primitive linearly with the degree of subdivision.
Thus, the aim of this policy is to provide a factor $factor_{current}$ by which to multiply an initial size such that $1 \geq factor_{current} \geq minFactor$, where $current$ is the current degree of subdivision.

We know that $factor_0 = 1$ and $factor_{degree} = minFactor$.
Since we want to decrease the size linearly, we also know that $factor_{current} = a \times current + b$, thus

\begin{equation*}
  \begin{cases}
    a \times 0 + b = 1 & \Leftrightarrow b = 1\\
    a \times degree + b = minFactor & \Leftrightarrow a = \frac{minFactor -1}{degree}
  \end{cases}
\end{equation*}

We finally obtain the function $factor_{current} = \frac{minFactor - 1}{degree} \times current + 1$.
This function is not defined when $degree = 0$ so this needs to be addressed as a special case.

After playing a bit with the $minFactor$ value, it looks like .25 is a good value.

#+begin_src python
def decrease_size_linearly(degree, min_factor=.25, scale=1):
    def result(current):
        if degree == 0:
            return 1
        return (current * (min_factor - 1) / degree + 1) * scale
    return result
#+end_src

I added a =scale= parameter to easily be able to make things bigger while keeping the linear relationship between degrees.

** Triangle
:PROPERTIES:
:header-args:python+: :eval never
:END:

A =Triangle= represents one of the triangles of an octasierp net, its properties are:
#+attr_latex: :float left :center nil
| -- =degree=:          | The degree of subdivision.                              |
| -- =initial_width=:   | The width of the first element.                         |
| -- =points_geometry=: | =Geometry= object describing how points are to be drawn |
| -- =lines_geometry=:  | =Geometry= object describing how lines are to be drawn  |

A =Triangle= has no coordinates of its own because the coordinates of its constituent points will be used in =generate=, whose role is to create a Gizeh object representing the geometry of the triangle, whereas =geometry= does the recursive calculations regarding all the points and lines of the final figure.
In =__init__=, a value of =0= is used to represent the default geometry which is a color palette of black and a size policy of linear decrease.
=None= is not used because it means to not draw anything.

#+begin_src python :noweb-ref "Triangle"
import gizeh as gz

<<Geometric primitives>>

class Triangle(object):
    def __init__(self, degree, initial_width, points_geometry=0, lines_geometry=0, background_color=None):
        self.degree = degree
        self.initial_width = initial_width
        if points_geometry == 0:
            self.points_geometry = Geometry(degree)
        else:
            self.points_geometry = points_geometry
        if lines_geometry == 0:
            self.lines_geometry = Geometry(degree)
        else:
            self.lines_geometry = lines_geometry
        self.background_color = background_color

    def generate(self, a, b, c):
        points, lines = self.geometry(a, b, c)
        if self.background_color is not None:
            lines.insert(0, self.make_background(a, b, c))
        return gz.Group(lines + points)

    def geometry(self, a, b, c, current=0):
        lines = self.make_lines(a, b, c, current)
        points = self.make_points(a, b, c, current)
        <<Subdivise triangle>>

    <<Triangle/>>
#+end_src

*** Lines, points and background generation

The lines characteristics at a given level are deduced from the dedicated geometry object:
#+begin_src python :noweb-ref Triangle/
def make_lines(self, a, b, c, current):
    if self.lines_geometry is None:
        return []
    color, factor = self.lines_geometry[current]
    width = max(1, self.initial_width * factor)
    return [gz.polyline(
        [a, b, c],
        close_path=True,
        stroke_width=width,
        stroke=color
    )]
#+end_src

A similar approach is done for points, with two differences:
 1. They are scaled a bit ($\times 1.2$) because they are used to hide the corners of lines.
 2. They are generated via translation.
#+begin_src python :noweb-ref Triangle/
def make_points(self, a, b, c, current):
    if self.points_geometry is None:
        return []
    color, factor = self.points_geometry[current]
    width = max(1, self.initial_width * factor * 1.2)
    point = gz.circle(r=width, fill=color)
    return list(map(point.translate, (a, b, c)))
#+end_src

Background generation is similar to lines generation, except that the lines are drawn and the fill color is set to =background_color=.
#+begin_src python :noweb-ref Triangle/
def make_background(self, a, b, c):
    return gz.polyline(
        [a, b, c],
        close_path=True,
        stroke_width=0,
        fill=self.background_color
    )
#+end_src

*** Subdivise triangle
:PROPERTIES:
:header-args:python+: :noweb-ref "Subdivise triangle"
:END:

Now that the geometric elements have been dealt with, only the recursive calls - or lack thereof - remains.
The generation is over when the maximal degree has been reached:
#+begin_src python
if current == self.degree:
    return points, lines
#+end_src

Otherwise, we make recursive calls to =geometry=, using the midpoints of the three original points.
The order of the points and of the lines is important because the graphical elements are drawn in the order of their apparition and we want to make sure that the earliest subdivisions are drawn over the subsequent ones.
#+begin_src python
ab = midpoint(a, b)
ac = midpoint(a, c)
bc = midpoint(b, c)
for sierpinski in [(a, ab, ac), (b, ab, bc), (c, ac, bc), (ab, ac, bc)]:
    recurse_points, recurse_lines = self.geometry(*sierpinski, current + 1)
    lines = recurse_lines + lines # order is important
    points = recurse_points + points
return points, lines
#+end_src

With =midpoint= being defined as:
#+begin_src python :noweb-ref "Triangle"
def midpoint(left, right):
    return ((left[0] + right[0]) / 2, (left[1] + right[1]) / 2)
#+end_src

** Octasierp net

=Octanet= represent the net of an octasierp through its evolution from an octahedron to a quasi-squaregrid.
This evolution will be tracked through a =progress= parameter:
 - When $progress = 0$, it is octahedron net shaped.
 - When $progress = 1$, it is quasi-squaregrid shaped.
 - When $0 < progress < 1$, its shape is deduced by interpolating the value of the central angle.

Below is the basic structure of this class and its dependencies.
The sections below will fill the missing parts in =<<Before Octanet>>= and =<<Octanet/>>=.

#+name: Octanet
#+begin_src python
<<Triangle>>
<<Colors>>

import math

<<Before Octanet>>

class Octanet(object):
    <<Octanet/>>
#+end_src

*** Computations independant of progress

Everything that does not depend on =progress= is computed in =__init__=:
#+begin_src python :noweb-ref Octanet/
def __init__(
        self, scale, degree=0, points_geometry=0, lines_geometry=0,
        triangle_background=None, surface_parameters={}
):
    self.degree = degree
    self.side = int(50 * scale) # Bugs may arise at very low scale.
    stroke_width = scale
    horizontal_margin = int(5 * scale)
    vertical_margin = int(15 * scale)

    altitude = math.sqrt(3) * (self.side / 2)
    width = int(4 * altitude)
    height = 2 * self.side
    left = horizontal_margin
    right = width + horizontal_margin
    bottom = height + vertical_margin

    self.x_ab = (left + right) /2
    self.y_a = bottom - self.side / 2
    self.y_b = bottom - self.side * 1.5

    self.surface_parameters = {
        'width': width + 2 * horizontal_margin,
        'height': height + 2 * vertical_margin,
        'bg_color': (1, 1, 1)
    }
    self.surface_parameters.update(surface_parameters)

    triangle = Triangle(
        degree, stroke_width,
        points_geometry=points_geometry, lines_geometry=lines_geometry,
        background_color=triangle_background
    )
    self.triangles = triangle.generate
#+end_src

*** Net construction according to progress

=make_net= uses basic trigonometry to compute the coordinate of the first quarter at the desired =progress= value.
This quarter is then cloned and rotated three times to form the complete figure.

#+begin_src python :noweb-ref Octanet/
def make_net(self, progress):
    vertical_correction = progress * self.side / 2
    angle = math.pi / 3 + progress * (math.pi / 6)

    y_a = self.y_a - vertical_correction
    y_b = self.y_b - vertical_correction
    a = (self.x_ab, y_a)
    b = (self.x_ab, y_b)

    cosa = math.cos(angle)
    sina = math.sin(angle)

    x_c = -sina * (y_b - y_a) + self.x_ab
    y_c = cosa * (y_b - y_a) + y_a
    c = (x_c, y_c)

    t1 = self.triangles(a, b, c)
    twin_point = ((self.x_ab + x_c) / 2, (y_b + y_c) / 2)
    t2 = t1.rotate(math.pi, twin_point)

    first_quarter = gz.Group([t1, t2])
    second_quarter = first_quarter.rotate(-angle, a)
    third_quarter = first_quarter.rotate(-2 * angle, a)
    fourth_quarter = first_quarter.rotate(angle, a)

    return gz.Group([first_quarter, second_quarter, third_quarter, fourth_quarter])
#+end_src

*** Surface creation and export

=draw= creates a Gizeh surface, draws the =Octanet= on it and returns it.
This Gizeh surface can be manipulated directly, or can be directly saved to a png.
#+begin_src python :noweb-ref Octanet/
def draw(self, progress=0):
    surface = gz.Surface(**self.surface_parameters)
    self.make_net(progress).draw(surface)
    return surface

def write_to_png(self, filename, progress=0):
    self.draw(progress).write_to_png(filename)
#+end_src

Writing to svg requires a different surface, not given directly by Gizeh.
#+begin_src python :noweb-ref Octanet/
def write_to_svg(self, filename, progress=0):
    surface = SVGSurface(filename, **self.surface_parameters)
    self.make_net(progress).draw(surface)
    surface.finish()
#+end_src

Below is defined the surface in question.
This is almost copy-pasted from Gizeh's own =PDFSurface=.
#+begin_src python :noweb-ref "Before Octanet"
import cairocffi as cairo
class SVGSurface(object):
    def __init__(self, filename, width, height, bg_color=None):
        self.width = width
        self.height = height
        self._cairo_surface = cairo.SVGSurface(filename, width, height)
        if bg_color is not None:
            gz.rectangle(2 * width, 2 * height, fill=bg_color).draw(self)

    def get_new_context(self):
        return cairo.Context(self._cairo_surface)

    def flush(self):
        self._cairo_surface.flush()

    def finish(self):
        self._cairo_surface.finish()
#+end_src

** Illustration: degrees 0 through 3

We use the =Octanet= class defined above to create the 8 images corresponding to the degrees 0 through 3 of the octahedron and the quasi-square version:
#+begin_src python :tangle script/octasierp_net_0-3.py :eval no-export
<<Octanet>>

for degree in range(4):
    net = Octanet(scale=10, degree=degree)
    net.write_to_png('net_octa_degree_{}.png'.format(degree), 0)
    net.write_to_png('net_squa_degree_{}.png'.format(degree), 1)
#+end_src

The code above is then called by a bash script who annotates and stitches the images together with imagemagick's =mogrify= and =montage=:
#+begin_src bash :tangle script/illustration_0_through_3.sh :shebang "#!/usr/bin/env bash" :eval no-export :results silent
python3 script/octasierp_net_0-3.py

function make_montage(){
    base=net_${version}_degree_

    for degree in 0 1 2 3
    do
        mogrify -size 600x400 -pointsize 60\
                -annotate +770+$vertical "degree = $degree"\
                $base$degree.png
    done

    montage ${base}{0,1,2,3}.png -geometry 600x400 images/montage_${base}0-3.png
    # -background none
    rm ${base}{0,1,2,3}.png
}

mkdir -p images

version=octa
vertical=1165
make_montage

version=squa
vertical=1250
make_montage
#+end_src

** Logo creation

Yliss's logo is an octasierp net at degree 3 with big colorful points and no lines.
To achieve the big points, =decrease_size_linearly= is scaled 3 times and is slightly abused by initialising it with a degree of 4.
This makes the linear size decrease slightly less prononced.

#+name: Yliss logo definition
#+begin_src python :tangle script/animations.py
<<Octanet>>

degree = 3
light=[colors.canard, colors.purple, colors.orange, colors.evergrey]
colorful_oversized = Geometry(
    degree,
    color_palette=light,
    size_policy=decrease_size_linearly(degree=4, scale=3)
)
yliss_logo = Octanet(
    scale=10, degree=degree,
    lines_geometry=None,
    points_geometry=colorful_oversized,
    triangle_background=colors.black,
    surface_parameters={'bg_color': colors.air}
)
#+end_src

The definition above is reused to generate the proper logo, in its octahedral shape but also its quasi-squaregrid equivalent.
#+begin_src python :results silent :eval no-export
<<Yliss logo definition>>
yliss_logo.write_to_svg('images/octahedron_logo.svg', 0)
yliss_logo.write_to_svg('images/square_logo.svg', 1)
yliss_logo.write_to_png('images/octahedron_logo.png', 0)
yliss_logo.write_to_png('images/square_logo.png', 1)
#+end_src

#+caption: Octahedron net
[[file:images/octahedron_logo.png]]

#+caption: Octahedron as quasi square
[[file:images/square_logo.png]]

The logos are generated in svg and png.
I originally planned to use the svg version since it is scalable but I went against it because I felt it was too big:
#+begin_src bash :exports both :eval yes :wrap "src text :minipage"
du -sh images/{octahedron,square}_logo.{svg,png} | sort -rh
#+end_src

#+RESULTS:
#+begin_src text :minipage
776K	images/octahedron_logo.svg
640K	images/square_logo.svg
200K	images/octahedron_logo.png
100K	images/square_logo.png
#+end_src

Finally, using the same logo definition, an animation from octahedron to quasi-squarenet is stitched together:

#+begin_src python :results silent :eval no-export
<<Yliss logo definition>>

animation_duration = 1.5
freeze_duration = .5
total_duration = animation_duration + freeze_duration
fps = 30
def generate_frame(time):
    return yliss_logo.draw(time / animation_duration).get_npimage()

from multiprocessing import Pool
pool = Pool()

import numpy as np
frames = list(pool.map(
    generate_frame,
    np.linspace(0, animation_duration, int(fps * animation_duration))
))
pool.close()
pool.join()

idx = 0
def next_frame(_):
    global idx
    idx += 1
    return frames[idx - 1] if idx <= len(frames) else frames[-1]

from moviepy.editor import VideoClip
clip = VideoClip(next_frame, duration=total_duration)
clip.write_videofile('images/net_to_square_degree{}.mp4'.format(degree), fps=fps)
#+end_src


* Textual representation
:PROPERTIES:
:CUSTOM_ID: textual_quarter
:header-args:python+: :eval never
:END:


This section contains the implementation of the class used to produce the various ASCII-style representations of squarified-net quarters.
Here is a breakdown of the arguments accepted by Quarter's init:
 - =degree= is the degree of subdivision.
 - =appearance= is the degree of appearance to eventually display.
 - =quarter= is the index of the quarter (between 1 and 4).
 - =display_redundant= commands whether the redundant points should be included in the representation.

The inclusion of =appearance= in the arguments means that only points appearing at the degree =appearance= are included in the representation.
I'll explain later how to make a representation including all the points or only the points in a given list.

#+name: Textual quarter
#+begin_src python :noweb no-export
<<Textual quarter dependencies>>
<<Textual quarter utils>>

class Quarter:
    <<Textual quarter constants>>

    def __init__(self, degree, appearance=None, quarter=0, display_redundant=False):
        self.degree = degree
        self.appearance = appearance
        self.quarter = quarter % 4
        self.display_redundant = display_redundant
        <<Textual quarter init>>

    <<Textual quarter methods>>

<<Textual quarter helper functions>>
#+end_src

** Character set

The character set used to describe a quarter is not supposed to be changed, that's why it is defined at the class level.
#+begin_src python :noweb-ref "Textual quarter constants"
POINT = 'x'
HORIZONTAL = '-'
EMPTY = ' '
VERTICAL = '|'
CORNER = '+'
COLLISION = 'E'
REDUNDANT = 'v'
NORTH_POLE_POINT = 'X'
NORTH_POLE = 'o'
#+end_src
=CORNER= is not a great name because it already means the 4 corners of the world of an octasierp but here it is the litteral corners of one quarter (two of which happen to be corners in the octasierp sense).

We also define the set of character that can collide and the set of character that are point.
They are complementary in the sense that their intersection is empty and their union is the whole character set.
#+begin_src python :noweb-ref "Textual quarter constants"
CAN_COLLIDE = {
    HORIZONTAL, EMPTY, VERTICAL,
    CORNER, NORTH_POLE
}
IS_POINT = {POINT, COLLISION, REDUNDANT, NORTH_POLE_POINT}
#+end_src

We want the caller to be able to select the redundant character.
This is done based on the value of =display_redundant= ; any value other than =True= will be interpreted as the an attempt to override the default redundant character.
#+begin_src python :noweb-ref "Textual quarter init"
if self.display_redundant is True:
    self.redundant = Quarter.REDUNDANT
else:
    self.redundant = self.display_redundant
if self.redundant is not False\
   and self.redundant not in Quarter.IS_POINT:
    msg = 'Usage of invalid redundant character `{}`.'.format(self.redundant)\
        + ' Expected values in {}.'.format(Quarter.IS_POINT)
    raise ValueError(msg)
#+end_src

** Generate a raw representation

This method is the core of the text representation logic.
Its role is to create a string where every character except =\n= maps to the real corresponding point.
It should not be called by an end user, as it still needs to be prettyfied and it has its own =appearance= argument which restricts the representation to one specific degree of appearance.
The assembly steps required will be the subject of the next sections.

With that being said, this method is a perfect example of why designing code using (poorly) observed artifacts rather than carefully deduced mathematical knowledge will result in a terrible unmaintanable mess.
But hey, it works.

In retrospect, it would have been much better to start from the central point since it is obviously a center of symmetry.
Even with that in mind, I will not bother redesigning the code below because once again hey, it works^{tm}.
If you don't understand how this code works, don't worry, neither do I.
#+begin_src python :noweb-ref "Textual quarter methods"
def raw(self, appearance=None):
    # Length of the sides.
    length = pow(2, self.degree) + 1

    # Special case without points.
    if appearance is None:
        tb_common = Quarter.HORIZONTAL * (length - 2)\
            + Quarter.CORNER
        top = Quarter.CORNER + tb_common
        bottom = Quarter.NORTH_POLE + tb_common
        emptyline = Quarter.VERTICAL + Quarter.EMPTY * (length - 2)\
            + Quarter.VERTICAL
        return [top] + [emptyline] * (length - 2) + [bottom]

    # Special case with corner points.
    if appearance == 0:
        if self.quarter == 0:
            topright = Quarter.POINT # Technically south pole
            bottomleft = Quarter.NORTH_POLE_POINT
        else:
            bottomleft = Quarter.NORTH_POLE
            if self.display_redundant:
                topright = self.redundant
            else:
                topright = Quarter.CORNER
        top = Quarter.CORNER + Quarter.HORIZONTAL * (length - 2) + topright
        bottom = bottomleft\
            + Quarter.HORIZONTAL * (length - 2) + Quarter.POINT
        emptyline = Quarter.VERTICAL + Quarter.EMPTY * (length - 2)\
            + Quarter.VERTICAL
        return [top] + [emptyline] * (length - 2) + [bottom]

    # Number of points in odd and even lines.
    npoints_even = pow(2, appearance - 1)
    npoints_odd = pow(2, appearance) - 1

    # Number of spaces separating points in the middle
    # for odd and even lines.
    nspaces_odd = pow(2, self.degree - appearance) - 1
    nspaces_even = 2 * nspaces_odd + 1

    # Number of even lines.
    nlines_even = pow(2, appearance - 1) - 1

    # Construct composite strings.
    small_horizontal = Quarter.HORIZONTAL * nspaces_odd
    big_horizontal = Quarter.HORIZONTAL * nspaces_even
    small_empty = Quarter.EMPTY * nspaces_odd
    big_empty = Quarter.EMPTY * nspaces_even

    # Build lines.
    right_vertical = self.redundant if self.display_redundant else Quarter.VERTICAL
    tb_common = small_horizontal\
        + big_horizontal.join([Quarter.POINT] * npoints_even)\
        + small_horizontal + Quarter.CORNER
    top = Quarter.CORNER + tb_common
    bottom = Quarter.NORTH_POLE + tb_common
    emptylines = [
        Quarter.VERTICAL + Quarter.EMPTY * (length - 2) + Quarter.VERTICAL
    ] * nspaces_odd
    oddline = Quarter.VERTICAL + small_empty\
        + small_empty.join([Quarter.POINT] * npoints_odd)\
        + small_empty + right_vertical
    evenline = Quarter.VERTICAL + small_empty\
        + big_empty.join([Quarter.POINT] * npoints_even)\
        + small_empty + Quarter.VERTICAL

    # Assemble the quarter this is like str.join but with list
    fulllines = [top] + ([oddline, evenline]) * nlines_even\
        + [oddline, bottom]
    def joinlines():
        it = iter(fulllines)
        yield next(it)
        for el in it:
            for empty in emptylines:
                yield empty
            yield el

    return list(joinlines())
#+end_src

** Generate the final representation

Here are handled the forementioned assembly steps, in the following method:
#+begin_src python :noweb no-export :noweb-ref "Textual quarter methods"
def repr(self):
    <<Assemble the degrees of appearance>>
    <<Rotate the quarter>>
    <<Apply horizontal compensation>>
#+end_src

The =Quarter= class is represented as a list of lines.
To put icing on the cake, we also handle a string version of the representation:
#+begin_src python :noweb-ref "Textual quarter methods"
def __str__(self):
    return '\n'.join(self.repr())
#+end_src

=__str__= is a magic method that is called when a =str= conversion is applied by Python.
Since a =str= conversion is automatically applied in code when =print= is called, code like src_python[:exports code]{print(quarter0)} will be enough to print the representation, which is great syntactic sugar in my opinion.

*** Assemble the degrees of appearance

When we have a list of degrees of appearance, we assemble them together by using:
 - =map= with =raw_string= to create all the text representations
 - =reduce= with =merge_raw_quarters= (the operation merging two quarters together) to combine them into one
#+name: Assemble the degrees of appearance
#+begin_src python
if type(self.appearance) is list:
    assembly = reduce(
        self.merge_raw_quarters,
        map(self.raw, self.appearance)
    )
else:
    assembly = self.raw(self.appearance)
#+end_src

To make life easier, I added a special case for =appearance=; the string src_python[:exports code]{'*'} is a shortcut for all the degrees of appearance possible:
#+begin_src python :noweb-ref "Textual quarter init"
if self.appearance == '*':
    self.appearance = list(range(self.degree+1))
#+end_src

Using =reduce= here is by no means fast (to execute) but at least it's fast (to code).

To implement =merge_raw_quarters=, we first need to be able to merge two lines together.
With this textual representation, we just have to iterate through the two lines simultaneously and prioritise the point character above every other.
I also output a collision character when two points collide, because that would mean either a repetition in =appearance= or a mistake in =merge_quarter_lines= and I want both failures to be obvious.

#+begin_src python :noweb-ref "Textual quarter utils"
def merge_quarter_lines(arg):
    left, right = arg
    buffer = []
    for cleft, cright in zip(left, right):
        if cright in Quarter.IS_POINT:
            if cleft in Quarter.CAN_COLLIDE:
                buffer += cright
            else:
                buffer += Quarter.COLLISION
        else:
            buffer += cleft
    return ''.join(buffer)
#+end_src

The actual merging method simply uses =merge_quarter_lines= to merge every line into a new list:
#+begin_src python :noweb-ref "Textual quarter methods"
def merge_raw_quarters(self, left, right):
    return list(map(merge_quarter_lines, zip(left, right)))
#+end_src

Because =reduce= is no longer a primitive in Python3, it must be imported:
#+name: Textual quarter dependencies
#+begin_src python
from functools import reduce
#+end_src

*** Rotate the quarter

To put the quarter into the right orientation, we do =quarter= left rotations.
It would be faster, for example, to do one right rotation when =quarter == 3= but there is no need for optimisation right now.
#+name: Rotate the quarter
#+begin_src python
for _ in range(self.quarter):
    assembly = rotate_quarter_representation_left(assembly)
#+end_src

Rotating the representation left is a succession of two tricks:
 1. Replacing vertical characters with horizontal ones and vice versa.
 2. Replacing lines with columns, in inverse order (that's what =reversed(list(zip(*lines)))= does).
#+begin_src python :noweb-ref "Textual quarter utils"
def rotate_quarter_representation_left(lines):
    replacement = {Quarter.HORIZONTAL: Quarter.VERTICAL,
                   Quarter.VERTICAL: Quarter.HORIZONTAL}
    def replace(sequence):
        return ''.join(
            replacement[char] if char in replacement
            else char
            for char in sequence
        )
    return [newline for newline in map(replace, reversed(list(zip(*lines))))]
#+end_src

*** Apply horizontal compensation

Applying horizontal compensation is a must because vertical text space is roughly twice as big as horizontal text space, so the representation is excessively vertical:
#+begin_src python :eval no-export :exports both
<<Textual quarter>>
print('\n'.join(Quarter(2).raw(2)))
#+end_src

#+RESULTS:
#+begin_src text :minipage
+x-x+
|xxx|
|x x|
|xxx|
ox-x+
#+end_src

Horizontal compensation is the last step to produce the final representation so we are ready to return:
#+name: Apply horizontal compensation
#+begin_src python
return horizontal_compensation(assembly)
#+end_src


The horizontal compensation function simply pads the top and bottom lines with horizontal characters and the other lines with empty characters.
#+begin_src python :noweb-ref "Textual quarter utils"
def horizontal_compensation(lines):
    buffer = [Quarter.HORIZONTAL.join(lines[0])]       # Top.
    for line in lines[1:-1]:
        buffer.append(Quarter.EMPTY.join(line))        # Others.
    buffer.append(Quarter.HORIZONTAL.join(lines[-1]))  # Bottom.
    return buffer
#+end_src

Now the text representation looks much better:
#+begin_src python :eval no-export :exports both
<<Textual quarter>>
print('\n'.join(horizontal_compensation(Quarter(2).raw(2))))
#+end_src

#+RESULTS:
#+begin_src text :minipage
+-x---x-+
| x x x |
| x   x |
| x x x |
o-x---x-+
#+end_src

** Demonstration
:PROPERTIES:
:header-args:python+: :exports both :eval no-export
:END:

#+begin_src python :exports both
<<Textual quarter>>
for degree in range(2, 5):
    print(Quarter(degree=degree, appearance=2, quarter=0))
#+end_src

#+RESULTS:
#+begin_src text :minipage
+-x---x-+
| x x x |
| x   x |
| x x x |
o-x---x-+
+---x-------x---+
|               |
|   x   x   x   |
|               |
|   x       x   |
|               |
|   x   x   x   |
|               |
o---x-------x---+
+-------x---------------x-------+
|                               |
|                               |
|                               |
|       x       x       x       |
|                               |
|                               |
|                               |
|       x               x       |
|                               |
|                               |
|                               |
|       x       x       x       |
|                               |
|                               |
|                               |
o-------x---------------x-------+
#+end_src

** Textual squarified net representation

Textual representation of a squarified octasierp net is generated with the  =SquareNet= class.
Most of the work has already been done in =Quarter= so the arguments are the same, except for:
 - =quarter= which becomes =quarters=, illustrating that what's left to be done is to assemble the four quarters together.
 - =show_axis= is a specific argument to include the axis and their gradation in the final representation.

The caller can choose to represent only a subset of the quarter by specifying for example src_python[:exports code]{SquareNet(degree, appearance, quarters={0,1})} to include only quarters 0 and 1.
The excluded quarters will be represented devoid of points.

#+name: Textual squarified net
#+begin_src python
<<Textual quarter>>
<<SquareNet utils>>
class SquareNet:
    def __init__(
            self, degree, appearance=None, quarters={0, 1, 2, 3},
            display_redundant=False, show_axis=False
    ):
        self.degree = degree
        self.appearance = appearance
        self.quarters = [Quarter(
            degree=degree,
            appearance=appearance if n in quarters else None,
            quarter=n,
            display_redundant=display_redundant
        ) for n in range(4)]
        self.show_axis = show_axis

    <<Final squarified net representation>>
#+end_src

*** Vertical and horizontal contatenation

To generate the final representation, we have to first concatenate horizontally quarter 0 with quarter 1 and quarter 2 with quarter 3.
Then only one vertical concatenation on the results of those two previous concatenations remain to be done.
Like with =Quarter=, =repr= returns a list of lines:
#+begin_src python :noweb-ref "Final squarified net representation"
def repr(self):
    top = cat_quarter_horizontally(
        self.quarters[1].repr(),
        self.quarters[0].repr()
    )
    bottom = cat_quarter_horizontally(
        self.quarters[2].repr(),
        self.quarters[3].repr()
    )
    result = cat_quarter_vertically(top, bottom)
    if self.show_axis:
        <<Add axis to SquareNet representation>>
    return result
#+end_src

And =__str__=, the string equivalent:
#+begin_src python :noweb-ref "Final squarified net representation"
def __str__(self):
    return '\n'.join(self.repr())
#+end_src

The vertical concatenation is the easiest ; since the representation is a list of lines, all lines are concatenated, except the central one (the one in common between the two quarters), which is merged:
#+begin_src python :noweb-ref "SquareNet utils"
def cat_quarter_vertically(top, bottom):
    return top[:-1] + [merge_quarter_lines((top[-1], bottom[0]))] + bottom[1:]
#+end_src

The horizontal concatenation is a little bit longer because it goes against our vertically-oriented representation.
It's not that complicated because =merge_quarter_lines= can merge columns as well as lines:
#+begin_src python :noweb-ref "SquareNet utils"
def cat_quarter_horizontally(left, right):
    right_of_left = [line[-1] for line in left]
    left_of_right = [line[0] for line in right]
    merged_column = merge_quarter_lines((right_of_left, left_of_right))
    return [
        l[:-1] + merged_column[i] + r[1:]
        for i, (l, r) in enumerate(zip(left, right))
    ]
#+end_src

We can now represent for example the last points of all quarters of a squarified net of degree 2, with the redundant points:
#+begin_src python :eval no-export :exports both
<<Textual squarified net>>
print(SquareNet(2, 2, quarters={0, 1, 2, 3}, display_redundant=True))
#+end_src

#+RESULTS:
#+begin_src text :minipage
+-v---v-+-x---x-+
x x x x x x x x v
| x   x | x   x |
x x x x x x x x v
+-x---x-o-x---x-+
v x x x x x x x x
| x   x | x   x |
v x x x x x x x x
+-x---x-+-v---v-+
#+end_src

*** Add axis to representation
:PROPERTIES:
:header-args:python+: :noweb-ref "Add axis to SquareNet representation"
:END:

First of all we create the gradations with the help of =lenhalf=, the length of strictly positive (and strictly negative) values on the gradations.
For example the =gradations= of a squarified net of degree 2 will be =[-4, -3, -2, -1, 0, 1, 2, 3, 4]= and =lenhalf= will be =4=.
#+begin_src python
lenhalf = len(top) - 1
gradations = list(range(lenhalf, 0, -1))
gradations = list(map(str, gradations + [0] + list(reversed(gradations))))
#+end_src

The left axis is split into three part:
 1. The axis proper.
 2. The gradation.
 3. The legend (plus and minus signs).
#+begin_src python
leftax = '^|' + '|' * len(result)
leftgrad = ' ' + ''.join(reversed(gradations))
leftleg = ' ' + '+' * lenhalf + ' ' + '-' * lenhalf
#+end_src

Same thing for the bottom ax:
#+begin_src python
bottomax = '   +' + '--' * len(result) + '-->'
bottomgrad = '      ' + ' '.join(gradations)
bottomleg = '      ' + '- ' * lenhalf + ' ' + ' +' * lenhalf
#+end_src

Finally we modify the =result= by first inserting the left axis into each line and then appending the bottom axis to it.
#+begin_src python
result = [
    leg + grad + ' ' + ax + '  ' + line
    for leg, grad, ax, line in zip(
            leftleg, leftgrad, leftax, [''] + result
    )
] + [bottomax, bottomgrad, bottomleg]
# Remove extraneous space, I can't bear the thought.
result[0] = result[0].rstrip(' ')
#+end_src


Demonstration time:
#+begin_src python :eval no-export :exports both :noweb-ref no
<<Textual squarified net>>
print(SquareNet(2, [0, 2], show_axis=True))
#+end_src

#+RESULTS:
#+begin_src text :minipage
   ^
+4 |  +-------x-x---x-x
+3 |  x x x x x x x x |
+2 |  | x   x | x   x |
+1 |  x x x x x x x x |
 0 |  x-x---x-X-x---x-x
-1 |  | x x x x x x x x
-2 |  | x   x | x   x |
-3 |  | x x x x x x x x
-4 |  +-x---x-x-------+
   +-------------------->
      4 3 2 1 0 1 2 3 4
      - - - -   + + + +
#+end_src

Note that this representation will break if we ever try to include gradations greater than 9, because it assumes that gradations are single-digit numbers.
The last degree for which a correct axis can be made is therefore degree 3 with its gradations going from -8 to 8.
It would be possible to make it work with higher degrees but degree 3 covers my needs regarding this feature.


* References
 - https://en.wikipedia.org/wiki/Find_first_set#CTZ

 - http://old.cescg.org/CESCG97/marak/index.html (erosion, move)

 - https://news.ycombinator.com/item?id=8681899, http://experilous.com/1/blog/post/procedural-planet-generation (planet generation, move)

 - http://jsfiddle.net/rL0qmee9/ (procedural generation bookmarks, move)

 - https://www.w3schools.com/colors/colors_picker.asp (color palettes)
