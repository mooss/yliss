#+property: header-args:jupyter-python :session sierp :results silent :tangle no

* Development setup                                                :noexport:

** Python packages
Some illustrations and animations are generated with =gizeh= and =moviepy=, inspired by this [[http://zulko.github.io/blog/2014/09/20/vector-animations-with-python/][blogpost]].

They can be installed via pip:
#+BEGIN_SRC bash :eval never
pip install --user gizeh moviepy
#+END_SRC

* About mathematical rigour

The maths presented here will be hand-wavy most of the time and a lot of it will not be formally proved because I'm a lazy bastard who mostly want to program.
So do not expect much rigour.

* Octahedron and Sierpiński triangle

An octasierp is the brainchild of a regular octahedron and the Sierpiński triangle, the first is the platonic solid formed of 8 equilateral triangles and the second is a recursive subdivision of an equilateral triangle.
Each face of an octahedron can be divided into 4 smaller equilateral triangles which can themselves be divided and so on.
The number of subdivision of an octasierp is its degree $d \in \mathbb{N}$, with $d=0$ being the initial octahedron.

An interesting property of octasierp is that they can almost be represented as a square grid.

* Diagrams generation

The diagrams are generated in python, using =gizeh= for the geometry and =moviepy= for stiching images together into animations.

#+BEGIN_SRC jupyter-python :tangle scripts/animations.py
import gizeh as gz
#+END_SRC

Images are saved in the =images= folder:
#+BEGIN_SRC jupyter-python :tangle scripts/animations.py
import os
os.chdir('images')
#+END_SRC


** Triangle
:PROPERTIES:
:header-args:jupyter-python+: :eval never
:END:

A =Triangle= represents one of the triangles of an octasierp net.
It has two main properties, its degree of subdivision and the initial width of its strokes.
It has no coordinate of its own because the coordinates of its constituent points will be used in =generate=, whose role is to create a Gizeh object representing the geometry of the triangle.

#+name: Triangle
#+BEGIN_SRC jupyter-python :noweb no-export
class Triangle(object):
    def __init__(self, degree, initial_width):
        self.degree = degree
        self.initial_width = initial_width

    def generate(self, a, b, c, current=0):
        <<generate implementation>>
#+END_SRC

*** =generate= implementation
We want to adapt the size of the points and of the lines in order to make the subdivisions more evident.
To achieve this, we decrease the stroke width linearly with the current degree by multiplying the initial width by a factor $factor_{current}$ such that $1 \geq factor_{current} \geq minFactor$, where $current$ is the current degree of subdivision.

We know that $factor_0 = 1$ and $factor_{degree} = minFactor$.
Since we want to decrease the width linearly, we also know that $factor_{current} = a \times current + b$, thus
\begin{cases}
  a \times 0 + b = 1 \Leftrightarrow b = 1\\
  a \times degree + b = minFactor \Leftrightarrow a = \frac{minFactor -1}{degree}
\end{cases}

We finally obtain the function $factor_{current} = \frac{minFactor - 1}{degree} \times current + 1$.
This function is not defined when $degree = 0 so this need to be addressed as a special case.

After playing a bit with $minFactor$ value, it looks like 0.75 is a good value.

#+name: generate implementation
#+BEGIN_SRC jupyter-python
# factor = - current / (1.5 * self.degree) + 1
factor = current * (-.75 /  self.degree) + 1 if self.degree != 0 else 1
stroke_width = self.initial_width * factor
stroke_width = max(1, stroke_width)
#+END_SRC

The triangle is simply three lines joining the three points:
#+name: generate implementation
#+BEGIN_SRC jupyter-python
main_triangle = gz.polyline(
    [a, b, c, a],
    stroke_width=stroke_width
)
#+END_SRC

We also display the points, mostly as a way to hide artifacts generated at the end of the lines, where they cross.
#+name: generate implementation
#+BEGIN_SRC jupyter-python
point = gz.circle(r=stroke_width, fill=(1, 1, 1))
points = [point.translate(a), point.translate(b), point.translate(c)]
#+END_SRC

Now that the geometric elements have been dealt with, only the recursive calls - or lack thereof - remains.
The generation is over when the maximal degree has been reached:
#+name: generate implementation
#+BEGIN_SRC jupyter-python
if current == self.degree:
    return gz.Group([main_triangle] + points)
#+END_SRC

Otherwise, we make recursive calls to =generate=, using the midpoints of the three original points:
#+name: generate implementation
#+BEGIN_SRC jupyter-python
ab = midpoint(a, b)
ac = midpoint(a, c)
bc = midpoint(b, c)
return gz.Group([
    main_triangle,
    self.generate(a, ab, ac, current + 1),
    self.generate(b, ab, bc, current + 1),
    self.generate(c, ac, bc, current + 1),
    self.generate(ab, ac, bc, current + 1) # sierpinsky if absent
] + points)
#+END_SRC

With =midpoint= being defined as:
#+name: Triangle
#+BEGIN_SRC jupyter-python
def midpoint(left, right):
    return ((left[0] + right[0]) / 2, (left[1] + right[1]) / 2)
#+END_SRC

** Octasierp net

#+name: Octanet
#+BEGIN_SRC jupyter-python :eval never
import numpy as np
import math

class Octanet(object):
    def __init__(
            self, side, horizontal_margin, vertical_margin, stroke_width,
            degree=0
    ):
        self.altitude = math.sqrt(3) * (side / 2)
        self.stroke_width = stroke_width
        self.side = side
        self.degree = degree

        self.width = int(4 * self.altitude)
        self.height = 2 * side
        self.left = horizontal_margin
        self.top = vertical_margin
        self.right = self.width + horizontal_margin
        self.bottom = self.height + vertical_margin

        self.surface_parameters = {
            'width': self.width + 2 * horizontal_margin,
            'height': self.height + 2 * vertical_margin,
            'bg_color': (0.4, 0.007843137, 0.235294118)
        }
        self.point = gz.circle(r=stroke_width, fill=(1, 1, 1))
        self.progress = 0

        triangle = Triangle(degree, stroke_width)
        self.triangles = triangle.generate

    def make_net(self, progress):
        vertical_correction = progress * self.side / 2
        h_ab = (self.left + self.right) / 2
        v_a = self.bottom - self.side / 2 - vertical_correction
        v_b = self.bottom - self.side * 1.5 - vertical_correction
        a = (h_ab, v_a)
        b = (h_ab, v_b)

        angle = math.pi / 3 + progress * (math.pi / 6)
        cosa = math.cos(angle)
        sina = math.sin(angle)
        # Simplified from cosa * (h_ab - h_ab) - sina * (v_b - v_a) + h_ab
        h_c = - sina * (v_b - v_a) + h_ab
        # Simplified from sina * (h_ab - h_ab) + cosa * (v_b - v_a) + v_a
        v_c = cosa * (v_b - v_a) + v_a
        c = (h_c, v_c)

        t1 = self.triangles(a, b, c)

        twin_point = ((h_ab + h_c) / 2, (v_b + v_c) / 2)
        t2 = t1.rotate(math.pi, twin_point)

        first_quarter = gz.Group([t1, t2])
        second_quarter = first_quarter.rotate(-angle, a)
        third_quarter = first_quarter.rotate(-2 * angle, a)
        fourth_quarter = first_quarter.rotate(angle, a)
        return gz.Group([first_quarter, second_quarter, third_quarter, fourth_quarter])

    def make_surface(self, progress=0):
        surface = gz.Surface(**self.surface_parameters)
        self.make_net(progress).draw(surface)
        return surface
#+END_SRC


#+BEGIN_SRC jupyter-python :noweb no-export :tangle scripts/animations.py
<<Triangle>>
<<Octanet>>

scale = 5
def instantiate(scale):
    return Octanet(
        100 * scale, 10 * scale, 30 * scale, 1.5 * scale,
        degree=4
    )

animation = instantiate(4)
animation.make_surface().write_to_png('octahedron_net.png')
animation.make_surface(1).write_to_png('octahedron_net_as_square.png')

from moviepy.editor import VideoClip
duration = 1.5
still_time = .5
clip = VideoClip(
    lambda x: animation.make_surface(min(x / duration, 1)).get_npimage(),
    duration=duration + still_time
)
clip.write_videofile('net_to_square.mp4', fps=30, threads=3)
#+END_SRC

#+name: Octahedron net
[[file:images/octahedron_net.png]]

#+name: Octahedron as quasi square
[[file:images/octahedron_net_as_square.png]]

* References
 - https://en.wikipedia.org/wiki/Find_first_set#CTZ
