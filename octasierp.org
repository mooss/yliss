#+property: header-args:jupyter-python :session sierp :results silent :tangle no

* Development setup                                                :noexport:

** Python packages
Some illustrations and animations are generated with =gizeh= and =moviepy=, inspired by this [[http://zulko.github.io/blog/2014/09/20/vector-animations-with-python/][blogpost]].

They can be installed via pip:
#+BEGIN_SRC bash :eval never
pip install --user gizeh moviepy
#+END_SRC


* About mathematical rigour

The maths presented here will be hand-wavy most of the time and a lot of it will not be formally proved because I'm a lazy bastard who mostly want to program.
So do not expect much rigour.


* Octahedron and Sierpiński triangle

An octasierp is the brainchild of a regular octahedron and the Sierpiński triangle, the first is the platonic solid formed of 8 equilateral triangles and the second is a recursive subdivision of an equilateral triangle.
Each face of an octahedron can be divided into 4 smaller equilateral triangles which can themselves be divided and so on.
The number of subdivision of an octasierp is its degree $d \in \mathbb{N}$, with $d=0$ being the initial octahedron.

An interesting property of octasierp is that they can almost be represented as a square grid.


* Diagrams generation

The diagrams are generated in python, using =gizeh= for the geometry and =moviepy= for stiching images together into animations.

#+BEGIN_SRC jupyter-python :tangle scripts/animations.py
import gizeh as gz
#+END_SRC

Images are saved in the =images= folder:
#+BEGIN_SRC jupyter-python :tangle scripts/animations.py
import os
os.chdir('images')
#+END_SRC

** Triangle
:PROPERTIES:
:header-args:jupyter-python+: :eval never
:END:

A =Triangle= represents one of the triangles of an octasierp net, its properties are:
 - =degree= :: Degree of subdivision.
 - =initial_width= :: Width of the first element.
 - =color_code= :: Color code of each subdivision.
                   This is a list whose elements describe the colors at a given degree.
                   If the list is too short, the colors are cycled through again.
                   The elements take the form of a 2-uple of colors with first the color for the lines and then the color for the points.
                   For example, the default color code is black for lines and white for points, resulting in the element =((1, 1, 1), (0, 0, 0))=.

A =Triangle= has no coordinate of its own because the coordinates of its constituent points will be used in =generate=, whose role is to create a Gizeh object representing the geometry of the triangle.

#+name: Triangle
#+BEGIN_SRC jupyter-python :noweb no-export
class Triangle(object):
    def __init__(self, degree, initial_width, color_code=None):
        self.degree = degree
        self.initial_width = initial_width
        if color_code is None:
            color_code = [((0, 0, 0), (1, 1, 1))]
        assert type(color_code) is list and all(type(el) is tuple for el in color_code),\
            'Invalid color code, expected a list of tuple of colors.'
        self.color_code = color_code

    def generate(self, a, b, c):
        lines, points = self.geometry(a, b, c)
        return gz.Group(lines + points)

    def geometry(self, a, b, c, current=0):
        <<Initiate triangle geometry>>
        <<Subdivise triangle>>
#+END_SRC

*** Initiate triangle geometry
We want to adapt the size of the points and of the lines in order to make the subdivisions more evident.
To achieve this, we decrease the stroke width linearly with the current degree by multiplying the initial width by a factor $factor_{current}$ such that $1 \geq factor_{current} \geq minFactor$, where $current$ is the current degree of subdivision.

We know that $factor_0 = 1$ and $factor_{degree} = minFactor$.
Since we want to decrease the width linearly, we also know that $factor_{current} = a \times current + b$, thus
\begin{cases}
  a \times 0 + b = 1 \Leftrightarrow b = 1\\
  a \times degree + b = minFactor \Leftrightarrow a = \frac{minFactor -1}{degree}
\end{cases}

We finally obtain the function $factor_{current} = \frac{minFactor - 1}{degree} \times current + 1$.
This function is not defined when $degree = 0 so this need to be addressed as a special case.

After playing a bit with $minFactor$ value, it looks like 0.75 is a good value.

#+name: Initiate triangle geometry
#+BEGIN_SRC jupyter-python
factor = current * (-.75 /  self.degree) + 1 if self.degree != 0 else 1
stroke_width = self.initial_width * factor
stroke_width = max(1, stroke_width)
#+END_SRC

Before drawing the triangle, we have to find the color code for the current degree.
#+name: Initiate triangle geometry
#+BEGIN_SRC jupyter-python
line_color, point_color = self.color_code[current % len(self.color_code)]
#+END_SRC


The initial triangle is simply three lines joining the three points, kept in a list that will eventually hold the subsequent triangles.
#+name: Initiate triangle geometry
#+BEGIN_SRC jupyter-python
lines = [gz.polyline(
    [a, b, c, a],
    stroke_width=stroke_width,
    stroke=line_color
)]
#+END_SRC

We also display the points, mostly as a way to hide artifacts generated at the end of the lines, where they cross.
#+name: Initiate triangle geometry
#+BEGIN_SRC jupyter-python
point = gz.circle(r=stroke_width * 1.2, fill=point_color)
points = [point.translate(a), point.translate(b), point.translate(c)]
#+END_SRC

*** Subdivise triangle
Now that the geometric elements have been dealt with, only the recursive calls - or lack thereof - remains.
The generation is over when the maximal degree has been reached:
#+name: Subdivise triangle
#+BEGIN_SRC jupyter-python
if current == self.degree:
    return lines, points
#+END_SRC

Otherwise, we make recursive calls to =geometry=, using the midpoints of the three original points.
The order of the points and of the lines is important because the graphical elements are drawn in the order of their apparition and we want to make sure that the earliest subdivisions are written over the subsequent ones.
#+name: Subdivise triangle
#+BEGIN_SRC jupyter-python
ab = midpoint(a, b)
ac = midpoint(a, c)
bc = midpoint(b, c)
for sierpinski in [(a, ab, ac), (b, ab, bc), (c, ac, bc), (ab, ac, bc)]:
    recurse_lines, recurse_points = self.geometry(*sierpinski, current + 1)
    lines = recurse_lines + lines # order is important
    points = recurse_points + points
return lines, points
#+END_SRC

With =midpoint= being defined as:
#+name: Triangle
#+BEGIN_SRC jupyter-python
def midpoint(left, right):
    return ((left[0] + right[0]) / 2, (left[1] + right[1]) / 2)
#+END_SRC

** Color palette

I use a =SimpleNamespace= to store some colors that I want to use (the names are probably innacurate).
#+name: Color palette
#+BEGIN_SRC jupyter-python
from types import SimpleNamespace
palette = SimpleNamespace(
    canard=(0, .6, .6),
    turquoise=(0, 1, 1),
    orange=(1, .6, 0),
    mandarine=(1, .8, 0),
    purple=(.4, 0, .4),
    violet=(.6, .2, .6),
    black=(0, 0, 0),
    white=(1, 1, 1),
    forest=(0, .4, 0),
    grass=(0, .6, .2),
    ocean=(0, .2, .8),
    river=(0, .4, .8)
)
#+END_SRC

** Octasierp net

#+name: Octanet
#+BEGIN_SRC jupyter-python :eval never :noweb no-export
<<Triangle>>
<<Color palette>>

import numpy as np
import math

class Octanet(object):
    def __init__(
            self, side, horizontal_margin, vertical_margin, stroke_width,
            degree=0
    ):
        self.stroke_width = stroke_width
        self.side = side
        self.degree = degree

        self.altitude = math.sqrt(3) * (side / 2)
        self.width = int(4 * self.altitude)
        self.height = 2 * side
        self.left = horizontal_margin
        self.top = vertical_margin
        self.right = self.width + horizontal_margin
        self.bottom = self.height + vertical_margin

        self.surface_parameters = {
            'width': self.width + 2 * horizontal_margin,
            'height': self.height + 2 * vertical_margin,
            'bg_color': (1, 1, 1)
        }

        triangle = Triangle(degree, stroke_width, color_code=[
            (palette.canard, palette.turquoise),
            (palette.orange, palette.mandarine),
            (palette.purple, palette.violet),
            (palette.black, palette.white)
        ] * 2)
        self.triangles = triangle.generate

    def make_net(self, progress):
        vertical_correction = progress * self.side / 2
        h_ab = (self.left + self.right) / 2
        v_a = self.bottom - self.side / 2 - vertical_correction
        v_b = self.bottom - self.side * 1.5 - vertical_correction
        a = (h_ab, v_a)
        b = (h_ab, v_b)

        angle = math.pi / 3 + progress * (math.pi / 6)
        cosa = math.cos(angle)
        sina = math.sin(angle)
        # Simplified from cosa * (h_ab - h_ab) - sina * (v_b - v_a) + h_ab
        h_c = - sina * (v_b - v_a) + h_ab
        # Simplified from sina * (h_ab - h_ab) + cosa * (v_b - v_a) + v_a
        v_c = cosa * (v_b - v_a) + v_a
        c = (h_c, v_c)

        t1 = self.triangles(a, b, c)

        twin_point = ((h_ab + h_c) / 2, (v_b + v_c) / 2)
        t2 = t1.rotate(math.pi, twin_point)

        first_quarter = gz.Group([t1, t2])
        second_quarter = first_quarter.rotate(-angle, a)
        third_quarter = first_quarter.rotate(-2 * angle, a)
        fourth_quarter = first_quarter.rotate(angle, a)
        return gz.Group([first_quarter, second_quarter, third_quarter, fourth_quarter])

    def make_surface(self, progress=0):
        surface = gz.Surface(**self.surface_parameters)
        self.make_net(progress).draw(surface)
        return surface
#+END_SRC

** Animate octahedron net to quasi grid

#+BEGIN_SRC jupyter-python :noweb no-export :tangle scripts/animations.py :results silent
<<Octanet>>

scale = 8
degree = 4
def instantiate(scale):
    return Octanet(
        100 * scale, 10 * scale, 30 * scale, 1.5 * scale,
        degree=degree
    )

animation = instantiate(4)
animation.make_surface().write_to_png('octahedron_net.png')
animation.make_surface(1).write_to_png('octahedron_net_as_square.png')

animation_duration = 1.5
freeze_duration = .5
total_duration = animation_duration + freeze_duration
fps = 30
def generate_frame(time):
    return animation.make_surface(time / animation_duration).get_npimage()

from multiprocessing import Pool
pool = Pool()

frames = list(pool.map(generate_frame, np.linspace(0, animation_duration, int(fps * animation_duration))))
pool.close()
pool.join()
idx = 0
def next_frame(_):
    global idx
    idx += 1
    return frames[idx - 1] if idx <= len(frames) else frames[-1]

from moviepy.editor import VideoClip
clip = VideoClip(next_frame, duration=total_duration)
clip.write_videofile('net_to_square_degree{}.mp4'.format(degree), fps=fps)
#+END_SRC


#+name: Octahedron net
[[file:images/octahedron_net.png]]

#+name: Octahedron as quasi square
[[file:images/octahedron_net_as_square.png]]


* References
 - https://en.wikipedia.org/wiki/Find_first_set#CTZ

 - http://old.cescg.org/CESCG97/marak/index.html (erosion, move)

 - https://news.ycombinator.com/item?id=8681899, http://experilous.com/1/blog/post/procedural-planet-generation (planet generation, move)

 - http://jsfiddle.net/rL0qmee9/ (procedural generation bookmarks, move)

 - https://www.w3schools.com/colors/colors_picker.asp (color palettes)
