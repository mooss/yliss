#+title: Octasierp: a solid foundation
#+author: mooss

#+property: header-args:bash :eval never
#+property: header-args:cpp :flags -std=c++20 -Wall -Werror :eval never :main no :noweb no-export :wrap "src text :minipage"
#+property: header-args:python :noweb no-export :results output :wrap "src text :minipage" :eval never
#+options: ^:nil

* Prelude
** About mathematical rigour

I'll be sometimes hand-wavy with the maths here both because I don't want to bother and because I don't know much about it.


** Inclusion

The following code block includes desired code blocks along with their dependencies.

#+name: include
#+begin_src sh :var args="" :results output :wrap "src cpp" :eval no-export :minipage
./litlib/include.pl "octasierp.org litlib/cpp.org" "$args"
#+end_src


* Of octahedrons and Sierpiński triangles
:PROPERTIES:
:header-args:python+: :eval no-export
:END:

This document is about octasierps, fractal solids destined to be used as the basis for a procedurally generated planet.

An octasierp is the brainchild of a regular octahedron and the Sierpiński triangle, the first is the platonic solid formed of 8 equilateral triangles and the second is a recursive subdivision of an equilateral triangle.
Indeed, since each face of an octahedron is an equilateral triangle, it can be divided into 4 smaller equilateral triangles which can themselves be divided and so on, thus adapting the concept of Sierpiński triangles to the third dimension.

This recursive structure is caracterised by its subdivision degree $d \in \mathbb{N}$, which is the number of successive subdivisions necessary to construct it.
The simplest octasierp occurs when $d=0$ and corresponds to an octahedron.

** Goals

This is my second attempt at generating a procedural planet using an octahedron as the starting point.

The main problem I encountered last time was finding a good data structure for my subdivided octahedron as well as implementing the code to get the neighbours of a point.
I ended up using a convoluted approach that I can't even remember now.
Thankfully I don't have to, since I've collected some observations that will help me to build a much simpler and intuitive data structure than last time.

A good data structure for an octasierp should meet some criteria:
 - A coordinate system, both for mental representation and as a programming primitive.
 - A support for different levels of detail, meaning the possibility to further subdivise the structure without having to reconstruct the whole object.
 - A fast way to request the neighbours of a point.

# Note: those goals are not static, the definition of a good data structure will probably expand when I'll get a better grasp on the problem.


** Geometric visualisation

I think an appropriate first step to find the best underlying representation of an octasierp is to visualise the problem, since the subject of study is a geometric concept.

*** Octahedron net

An octahedron can be represented in two dimensions as a net, a flattened arrangement of the eight sides, ready to be folded back into three dimensions.
Look below for an illustration of both the subdivision process and the net of an octahedron, extended to an octasierp.

#+name: montage_octa_degree_0-3
#+caption: Octasierp net for degrees 0, 1, 2 and 3
[[file:images/montage_net_octa_degree_0-3.png]]

*** Squarified net

An interesting property of octasierps is that when you inflate the central angle to 90\textdegree{}, they can almost be represented as a square grid with additional diagonal connections as shown in the figure below.
A strange thing about this representation is that points are neighbouring each other along the sides in a symmetric pattern.
This representation is strongly reminiscent of the Peirce quincuncial projection[fn::See https://en.wikipedia.org/wiki/Peirce_quincuncial_projection.], all the more because the end goal of this project is to generate a planet.

#+attr_latex: :placement [H]
#+name: montage_squa_degree_0-3
#+caption: Octasierp squarified net for degrees 0, 1, 2 and 3

[[file:images/montage_net_squa_degree_0-3.png]]

The figure above provides a nice visualisation, but since it's an image (i.e. a binary file), its not so easy to hack upon, so for the rest of the document I will use a text representation to illustrate the various steps of representation and manipulation of an octasierp.
See below the textual equivalent of this figure[fn::=x= are points, =-= are horizontal lines, =|= are vertical lines and =+= are corners. The representations have been scaled to all appear at the same size, that is normally not the case.]:
#+begin_src python :exports results :eval no-export
<<Textual squarified net>>
between = ' ' * 25
def construct(degree):
    return SquareNet(
        3, list(range(degree+1)),
        display_redundant='x'
    ).repr()
for deg0, deg1 in zip(construct(0), construct(1)):
    print(deg0 + between + deg1)
print('           degree = 0           ' + between + '            degree = 1')
print()
print()
for deg2, deg3 in zip(construct(2), construct(3)):
    print(deg2 + between + deg3)
print('           degree = 2           ' + between + '            degree = 3')
#+end_src

#+RESULTS:
#+begin_src text :minipage
x---------------x---------------x                         x-------x-------x-------x-------x
|               |               |                         |               |               |
|               |               |                         |               |               |
|               |               |                         |               |               |
|               |               |                         x       x       x       x       x
|               |               |                         |               |               |
|               |               |                         |               |               |
|               |               |                         |               |               |
x---------------X---------------x                         x-------x-------X-------x-------x
|               |               |                         |               |               |
|               |               |                         |               |               |
|               |               |                         |               |               |
|               |               |                         x       x       x       x       x
|               |               |                         |               |               |
|               |               |                         |               |               |
|               |               |                         |               |               |
x---------------x---------------x                         x-------x-------x-------x-------x
           degree = 0                                                degree = 1


x---x---x---x---x---x---x---x---x                         x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x
|               |               |                         x x x x x x x x x x x x x x x x x
x   x   x   x   x   x   x   x   x                         x x x x x x x x x x x x x x x x x
|               |               |                         x x x x x x x x x x x x x x x x x
x   x   x   x   x   x   x   x   x                         x x x x x x x x x x x x x x x x x
|               |               |                         x x x x x x x x x x x x x x x x x
x   x   x   x   x   x   x   x   x                         x x x x x x x x x x x x x x x x x
|               |               |                         x x x x x x x x x x x x x x x x x
x---x---x---x---X---x---x---x---x                         x-x-x-x-x-x-x-x-X-x-x-x-x-x-x-x-x
|               |               |                         x x x x x x x x x x x x x x x x x
x   x   x   x   x   x   x   x   x                         x x x x x x x x x x x x x x x x x
|               |               |                         x x x x x x x x x x x x x x x x x
x   x   x   x   x   x   x   x   x                         x x x x x x x x x x x x x x x x x
|               |               |                         x x x x x x x x x x x x x x x x x
x   x   x   x   x   x   x   x   x                         x x x x x x x x x x x x x x x x x
|               |               |                         x x x x x x x x x x x x x x x x x
x---x---x---x---x---x---x---x---x                         x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x
           degree = 2                                                degree = 3
#+end_src

Everything related to the generation of the textual representation is gathered in the section [[#textual_quarter][Textual representation]].


** Some terminology

*** Degrees

When used in isolation, degree is the shorthand for degree of subdivision.
I must offer this clarification because, unfortunately there are other degrees, such as the degree of appearance.

*** Quarters

A squarified net can be divided into four quarters, each being a rotated image of the others around the central point.
This means rules devised for one quarter can easily be adapted to the others.

Those quarters are identified by a number ranging from 0 to 3, with quarter 0 being the top-right one and the others being numbered counter-clockwise.
The counter-clockwise rotation has been chosen to correspond to the sense of trigonometric rotation.

*** Poles and corners

To pay hommage to both the planet metaphor and the peirce quincuncial projection, the central point is the north pole, while the four extremes are one and the same, the south pole.

The four midpoints of the sides are actually just random points on the equator but since they also are initial vertices of the octasierp, let's give them a name ; the four corners of the world, with the right one being corner 0 and the others numbered once again counter-clockwise.
I know that the four corners are a bit confusing because from the 2d perspective of the squarified net, the corners of the square are actually the south pole but it will make more sense in 3d and I really like the term, so it stays.


** Coordinate system

Based on the observation of the squarified net, the natural coordinate system for an octasierp is an indexing along the axis between the central point and corner 0 (the x-axis) and the one between the central point and corner 1 (the y-axis).
In this scheme, the central point (of coordinates $(0, 0)$) is also the north pole.

Since an octasierp is a discrete structure, the coordinates will be integer-based.
An unfortunate side effect of integer coordinates is that except for the north pole, points will not keep their coordinates when the degree of subdivision changes.
For example, in the illustration below, when $degree = 0$, corner 0 is at the coordinates $(1, 0)$ and when $degree = 1$ it is at the coordinates $(2, 0)$.
In the end, the rule is that coordinates only make sense at a given degree.

#+begin_src python :exports results
<<Textual squarified net>>
<<listr_replace>>
deg0 = SquareNet(0, None, show_axis=True).repr()
listr_replace(deg0, [(2, 10, 'Z   <====== Corner 0 at degree 0')])
print('\n'.join(deg0))

print()
print('__________________________________________')
print()
deg1 = SquareNet(1, None, show_axis=True).repr()
listr_replace(deg1, [(3, 14, 'Z   <== Corner 0 at degree 1')])
print('\n'.join(deg1))
#+end_src

#+RESULTS:
#+begin_src text :minipage
   ^
+1 |  +-+-+
 0 |  +-o-Z   <====== Corner 0 at degree 0
-1 |  +-+-+
   +-------->
      1 0 1
      -   +

__________________________________________

   ^
+2 |  +---+---+
+1 |  |   |   |
 0 |  +---o---Z   <== Corner 0 at degree 1
-1 |  |   |   |
-2 |  +---+---+
   +------------>
      2 1 0 1 2
      - -   + +
#+end_src

Another problem is that there is a redundancy in this coordinate system that needs to be resolved (most strikingly, the south pole is present four times).
First the cardinality of a half-axis (that is to say the number of points on it) must be derived.
Then that property will be used to describe precisely the redundancy problem.
Finally, a solution will be proposed to resolve the redundancy problem and fix the coordinate system.

*** Half-axis cardinality

To pass from degree $d$ to degree $d + 1$, points are inserted between every adjacent point.
From degree 0 to degree 1, 1 point is added, from degree 1 to 2, 2 points are inserted, then 4, then 8, then $2^4$, then $2^5$, and so on.
Another way to see it is that the number of points added at degree $d + 1$ is the number of segments at degree $d$ ; we start with one segment to subdivise, then two, then four and so on.

Based on what we have deduced so far, we can express this number with the relation $\vert points_{d+1} \vert = \vert points_d \vert + 2^{d}$ with $d \in \mathbb{N}$.
The problem is that I don't know anymore how to process this kind of recurrence relationships and I can't be bothered to find how so let's just make a hasardous guess from the first five numbers, shown in table [[hasardous_guess]].
A most interesting pattern made evident by this table is that in each line we add $2^d$ to itself, plus one.
Thus we deduce that $\vert points_{d+1} \vert = 2 \times 2^d + 1 \Leftrightarrow \vert points_{d+1} \vert = 2^{d+1} + 1 \Leftrightarrow \vert points_d \vert = 2^{d} + 1$.

#+name: hasardous_guess
#+caption: Small amount of data to support my dubious claim (no mathematicians were hurt in the process (not on purpose at least))
| $d$ | $\vert points_d \vert$ | $2^{d}$ | $\vert points_{d+1} \vert$ |
|-----+------------------------+---------+----------------------------|
|   0 |                      2 |       1 |                          3 |
|   1 |                      3 |       2 |                          5 |
|   2 |                      5 |       4 |                          9 |
|   3 |                      9 |       8 |                         17 |
|   4 |                     17 |      16 |                         33 |

*** Points redundancy

A peculiar caracteristic of the squarified-net-inspired coordinate system is that there is a redundancy at the edges, where the four corners act as a center of symmetry.
For example, at degree 2 the points $A = (-3, 4)$ and $B = (3, 4)$ are the same, as well as the points $C = (4, 2)$ and $D = (4, -2)$:
#+name: Octasierp redundancy example
#+begin_src python :exports none :eval never
<<Textual squarified net>>
<<listr_replace>>
redundant_representation = SquareNet(2, [0, 1, 2], display_redundant=display_redundant, show_axis=True).repr()
listr_replace(redundant_representation, [
    (1, 8, 'A'),
    (1, 20, 'B'),
    (3, 22, 'C'),
    (7, 22, 'D')
])
print('\n'.join(redundant_representation))
#+end_src

#+begin_src python :exports results :eval no-export
display_redundant='x'
<<Octasierp redundancy example>>
#+end_src

#+RESULTS:
#+begin_src text :minipage
   ^
+4 |  x-A-x-x-x-x-x-B-x
+3 |  x x x x x x x x x
+2 |  x x x x x x x x C
+1 |  x x x x x x x x x
 0 |  x-x-x-x-X-x-x-x-x
-1 |  x x x x x x x x x
-2 |  x x x x x x x x D
-3 |  x x x x x x x x x
-4 |  x-x-x-x-x-x-x-x-x
   +-------------------->
      4 3 2 1 0 1 2 3 4
      - - - -   + + + +
#+end_src

We can deduce a general rule from this example.

First we need to find what are the extreme values of our coordinate system at a given degree.
The extreme value we are looking for here will be the number of points on an half-axis minus one, since the numerotation starts at 0.
We already know the number of points on a half-axis at degree $d$ to be $\vert points_d \vert = 2^{d} + 1$ so the extreme value we are looking for is $2^d$.

Since the centers of symmetry are the four corners, the following rules can be deduced for the redundant points at degree $d$ depending on the corners they are centered around:
 - *corner 0*: $\{(2^d, n), (2^d, -n)\}$
 - *corner 1*: $\{(n, 2^d), (-n, 2^d)\}$
 - *corner 2*: $\{(-2^d, n), (-2^d, -n)\}$
 - *corner 3*: $\{(n, -2^d), (-n, -2^d)\}$
With $n \in \mathbb{N}$ and $0 \leq n \leq 2^d$, so technically the centers of symmetry are included (when $n=0$).
Note that a special case arise when $n=2^d$, where the redundant points - for all the corners - are the south pole.

When applied to our four example points, the rules are correctly implying that:
 - $A = (-3, 4)$ and $B = (3, 4)$ are centered around corner 1 with $n=3$.
 - $C = (4, 2)$ and $D = (4, -2)$ are centered around corner 0 with $n=2$.

*** Border disputes and canonical quarters

Because there are redundancies in the coordinate system, it will be useful to define the canonical quarter of a redundant point, that is to say the one to which they "officially" belong.
Two main cases need to be treated:
 - The poles because they are on every quarter.
 - The borders between quarters (excluding the poles) because they are shared between two quarters.

There are only two poles, so they cannot be distributed equally between the four quarters.
Rather that attributing one pole to, say the quarter 0 and another to the quarter 2, I prefer to give them both to quarter 0 because:
 1. It is more memorable.
 2. It gets the message across that quarter 0 is the reference quarter, or The canonical quarter, if you will.

Quarter 1, 2 and 3 are essentially a rotation of quarter 0.
We resolve the border dispute between quarters by using this property.
The top and bottom border of quarter 0, i.e. its border with quarter 1 and quarter 3 respectively are attributed to quarter 0.
By rotation, every border has its quarter and every quarter has its border.

Beyond those two cases we just resolved lurks a third one, the corners.
Even though they technically belong to the borders, the rotation mecanism would still make them shared between quarters because there would be two corners per quarter while there is the same number of corners and quarters (4).
To solve this last issue, we'll just say that the bottom right corner belongs to quarter 0 and as always, this rule applies by rotation to the other quarters.

Here is the updated example from the previous section, with =v= characters (as well as =A= and =C=) representing redundant points[fn::The canonical counterparts of those points are still represented with an =x=.]:
#+begin_src python :exports results :eval no-export
display_redundant='v'
<<Octasierp redundancy example>>
#+end_src

#+RESULTS:
#+begin_src text :minipage
   ^
+4 |  v-A-v-v-x-x-x-B-x
+3 |  x x x x x x x x v
+2 |  x x x x x x x x C
+1 |  x x x x x x x x v
 0 |  x-x-x-x-X-x-x-x-x
-1 |  v x x x x x x x x
-2 |  v x x x x x x x D
-3 |  v x x x x x x x x
-4 |  v-x-x-x-x-v-v-v-v
   +-------------------->
      4 3 2 1 0 1 2 3 4
      - - - -   + + + +
#+end_src

*** About the resemblance

I must address the fact that the representation without redundant points bears an unfortunate resemblance with a swastika:
#+begin_src python :exports results :eval no-export
<<Textual squarified net>>
print(SquareNet(2, list(range(3))))
#+end_src

#+RESULTS:
#+begin_src text :minipage
+-------x-x-x-x-x
x x x x x x x x |
x x x x x x x x |
x x x x x x x x |
x-x-x-x-X-x-x-x-x
| x x x x x x x x
| x x x x x x x x
| x x x x x x x x
+-x-x-x-x-------+
#+end_src

At first I tried to find other representations but found no other fitting my needs.
Then I thought about at least trying to make the arms point the other way but this contradicted the intuitive representation I had in mind so I finally decided to not let a hideous historical artifact affect a technical decision.
If you are offended by this decision I'm sorry about it.


** Storage

The challenge in storing an octasierp is that it can *almost* be reduced to a square grid, which is the polite way to say can it *cannot* be reduced to a square grid.

This is unfortunate because a square grid is excessively easy to represent in memory.
Had an octasierp been a square of side $n$, it would have been storable as an array of $n \times n$ values.

*** Separate scheme

It would be good to find an octasierp storage scheme that can grow new points without needing to move the old ones.
However, that would imply storing each stage separately and would have the following problems:
 1. Memory would not be contiguous thus slowing iteration on all points.
 2. It would be tedious to pull off because when an octasierp grows, new points are added in a checkered pattern as illustrated below.
 3. The indexing scheme would need to be a bit too clever to account for this checkered pattern (meaning it would require more computation than the alternative).

Growth of quarter 0 at degrees 0, 1, 2 and 3:
#+begin_src python :eval no-export :exports results
<<Textual squarified net>>

for degree in range(4):
    print('Quarter 0 at degree d=' + str(degree) + ':')
    in_between = max(0, degree - 1)
    representation = ['a'] + ['0'] * in_between + ['*']
    print(Quarter(degree, list(range(degree + 1)), display_points=representation))
    if degree < 3:
        print()
#+end_src

#+RESULTS:
#+begin_src text :minipage
Quarter 0 at degree d=0:
+-a
X-a

Quarter 0 at degree d=1:
+-*-a
| * |
X-*-a

Quarter 0 at degree d=2:
+-*-0-*-a
| * * * |
| * 0 * |
| * * * |
X-*-0-*-a

Quarter 0 at degree d=3:
+-*-0-*-0-*-0-*-a
| * * * * * * * |
| * 0 * 0 * 0 * |
| * * * * * * * |
| * 0 * 0 * 0 * |
| * * * * * * * |
| * 0 * 0 * 0 * |
| * * * * * * * |
X-*-0-*-0-*-0-*-a
#+end_src
\\
Legend:
 - =X= :: North pole.
 - =a= :: Other points of degree 0, including the south pole.
 - =*= :: New point at degree $d$.
 - =0= :: Points between degree 1 and degree $d - 1$.

*** Rectangular scheme

A simpler storage scheme can use to its advantage the fact that, for a given quarter, points of degree greater than zero have a neatly rectangular repartition.
This can be illustrated by looking at the growth of quarter 0 when all points appearing after the degree 0 are given the same symbol:
#+begin_src python :eval no-export :exports results
<<Textual squarified net>>

for degree in range(4):
    print('Quarter 0 at degree d=' + str(degree) + '.')
    print(Quarter(degree, list(range(degree + 1)), display_points=['a', '0']))
    if degree < 3:
        print()
#+end_src

#+RESULTS:
#+begin_src text :minipage
Quarter 0 at degree d=0.
+-a
X-a

Quarter 0 at degree d=1.
+-0-a
| 0 |
X-0-a

Quarter 0 at degree d=2.
+-0-0-0-a
| 0 0 0 |
| 0 0 0 |
| 0 0 0 |
X-0-0-0-a

Quarter 0 at degree d=3.
+-0-0-0-0-0-0-0-a
| 0 0 0 0 0 0 0 |
| 0 0 0 0 0 0 0 |
| 0 0 0 0 0 0 0 |
| 0 0 0 0 0 0 0 |
| 0 0 0 0 0 0 0 |
| 0 0 0 0 0 0 0 |
| 0 0 0 0 0 0 0 |
X-0-0-0-0-0-0-0-a
#+end_src
\\
Legend:
 - =X= :: North pole.
 - =a= :: Other points of degree 0, including the south pole.
 - =0= :: Points of degree greater than 0.

This pattern is repeated by rotation for other quarters, as can be observed for quarter 1 at degree 3:
#+begin_src python :eval no-export :exports results
<<Textual quarter>>
print(Quarter(3, list(range(4)), quarter=1, display_points=['b', '1']))
#+end_src

#+RESULTS:
#+begin_src text :minipage
+---------------b
1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1
+---------------o
#+end_src
\\
Legend:
 - =o= :: Origin, aka north pole.
 - =b= :: Point of degree 0 (there is only one for quarter 1).
 - =1= :: Points of degree greater than 0.

\\
Using this rectangular storage scheme, all the points can be stored contiguously, and this is actually what will be done in practice because this has the following implications:
 - Contiguous storage can be iterated upon very fast.
 - Implementation using a =std::vector= is handy because methods from the vector can be used as-is in the octasierp implementation, most notably =begin= and =end=, making iteration on points basically free.

*** Cardinality

The rectangular storage scheme requires to know the size of the rectangle.
Looking at the textual representation of quarter 0 will help for this:
#+begin_src python :eval no-export :exports results
<<Textual squarified net>>

for degree in range(3):
    print('Quarter 0 at degree d=' + str(degree) + '.')
    print(Quarter(degree, list(range(degree + 1)), display_points=['a', '0']))
    if degree < 2:
        print()
#+end_src

#+RESULTS:
#+begin_src text :minipage
Quarter 0 at degree d=0.
+-a
X-a

Quarter 0 at degree d=1.
+-0-a
| 0 |
X-0-a

Quarter 0 at degree d=2.
+-0-0-0-a
| 0 0 0 |
| 0 0 0 |
| 0 0 0 |
X-0-0-0-a
#+end_src
\\
Legend:
 - =X= :: North pole.
 - =a= :: Other points of degree 0, including the south pole.
 - =0= :: Points of degree greater than 0.

An important observation is that vertically the whole quarter is covered, but horizontally two columns are missing.
Additionally, the quarter's shape goes from a $2 \times 2$ square at degree zero into a square of $3 \times 3$ and $5 \times 5$ at degrees one and two.

Because the subdivision mechanism inserts a point between each existing one, there is a power of two somewhere in there.
A bruteforce deduction should be enough to tell that a given quarter at degree $d$ will have a shape of $2^d + 1$ by $2^d + 1$.

Looking at the following representation of quarter 0 at degree 3 in all its $9 \times 9$ glory is enough to convince me:

#+begin_src python :eval no-export :exports results
<<Textual squarified net>>
print(Quarter(3, list(range(4)), quarter=0, display_points=['a', '0']))
#+end_src

#+RESULTS:
#+begin_src text :minipage
+-0-0-0-0-0-0-0-a
| 0 0 0 0 0 0 0 |
| 0 0 0 0 0 0 0 |
| 0 0 0 0 0 0 0 |
| 0 0 0 0 0 0 0 |
| 0 0 0 0 0 0 0 |
| 0 0 0 0 0 0 0 |
| 0 0 0 0 0 0 0 |
X-0-0-0-0-0-0-0-a
#+end_src

Removing the two empty columns gives us a $2^d - 1$ by $2^d + 1$ rectangle containing all points of degrees 1 to $d$ for quarter 0.
The sames applies by rotation to quarter 1, 2 and 3.
By adding the six initial points, we have the numbers of points in an octasierp of degree $d$ $\vert octasierp_d \vert = 4 (2^d - 1) (2^d + 1) + 6$, which boils down to the very pleasing $\vert octasierp_d \vert = 2^{2d+2} + 2$.

*** Ordering and indexing

To be indexable, a storage scheme must define an order so that each element has its place and each place its element.
The indexation is based on the previously defined coordinate system.

At the highest level, the first 6 places are reserved for the points of degree 0, then come the points of strictly positive degree from quarter 0, then those same points for quarter 1, 2 and 3.
Therefore, at degree 1, the storage looks like this: =NSABCD000111222333=, with =NSABCD= representing the points of degree 0 (north pole, south pole, and corners 0 to 3) and =0=, =1=, =2= and =3= their respective quarter.

At the quarter level, the procedure is as usual to define rules for quarter 0 and then apply them to the other quarters by rotation.

Within quarter 0, a simple way to order the points is to do as if they were in a graph, with the first coordinate indexing the x axis and the second coordinate indexing the y axis.
The resulting point order is illustrated below for quarter 0 at degree 2, with hexadecimal digits to keep them one character only:
#+begin_src text :minipage
   ^
+4 |  +-------+-c-d-e-x
+3 |  |       | 9 a b |
+2 |  |       | 6 7 8 |
+1 |  |       | 3 4 5 |
 0 |  +-------X-0-1-2-x
-1 |  |       |       |
-2 |  |       |       |
-3 |  |       |       |
-4 |  +-------+-------+
   +-------------------->
      4 3 2 1 0 1 2 3 4
      - - - -   + + + +
#+end_src
\\
\\
By rotation, quarter 1 is ordered this way:
#+begin_src text :minipage
   ^
+4 |  +-------x-------+
+3 |  e b 8 5 2       |
+2 |  d a 7 4 1       |
+1 |  c 9 6 3 0       |
 0 |  +-------o-------+
-1 |  |       |       |
-2 |  |       |       |
-3 |  |       |       |
-4 |  +-------+-------+
   +-------------------->
      4 3 2 1 0 1 2 3 4
      - - - -   + + + +
#+end_src
\\
\\
And so on with the other quarters.


** Iteration

Iteration facilities are needed to manipulate an octasierp in a meaningful way.
Iteration is much more tricky to explain using the textual representation so this section is going to be light on illustrations.
The best visualisation at hand is to remember the squarified net for degrees 0 through 4 that was previously included above and is once again visible below:
#+attr_latex: :placement [H]
[[file:images/montage_net_squa_degree_0-3.png]]

*** Points

If the storage is one continuous block, as should be the case with the rectangular storage scheme, iteration on all the points simply corresponds to iteration on the storage.
Since this storage order has no particular meaning outside of allowing an easy-ish translation from coordinates to storage index, this kind of iteration is for most practical purposes orderless.

If the storage is not one continous block, something else should be done depending on how the storage is handled.


** Binary degree

We can simplify the problem of finding the degree of appearance of a point by going from a rectangular grid to discrete points on a line.

The subdivision process is pretty much the same for a line and for a rectangular grid.
At degree 0, there are two points, at degree 1 one more point appears, at degree 2 there are two more points, four more at degree 3, then eight, then sixteen, and so on.

#+attr_latex: :placement [H]
#+name: bindeg_x0
#+caption: Degrees of appearance at subdivision degree 0
| Index                | 0 | 1 |
|----------------------+---+---|
| Degree of appearance | 0 | 0 |

#+attr_latex: :placement [H]
#+name: bindeg_x1
#+caption: Degrees of appearance at subdivision degree 1
| Index                | 0 | 1 | 2 |
|----------------------+---+---+---|
| Degree of appearance | 0 | 1 | 0 |

#+attr_latex: :placement [H]
#+name: bindeg_x2
#+caption: Degrees of appearance at subdivision degree 2
| Index                | 0 | 1 | 2 | 3 | 4 |
|----------------------+---+---+---+---+---|
| Degree of appearance | 0 | 2 | 1 | 2 | 0 |

#+attr_latex: :placement [H]
#+name: bindeg_x3
#+caption: Degrees of appearance at subdivision degree 3
| Index                | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
|----------------------+---+---+---+---+---+---+---+---+---|
| Degree of appearance | 0 | 3 | 2 | 3 | 1 | 3 | 2 | 3 | 0 |

An interesting thing to note here is that since a new point is introduced between every adjacent points, a point's index is doubled at each subdivision so what is point 1 at subdivision degree 1 becomes point 4 at subdivision degree 3, thanks to two consecutive multiplications.

$bindeg_{i,d}$ (binary degree) is the function outputting the degree of appearance of a point when given its index $i$ and a global degree of subdivision $d$.
We have $i \in \mathbb{N}$ and $d \in \mathbb{N}$, with $0 \leq i \leq 2^d$.

In my uninformed opinion, it behaves as some kind of weird distance between $i$ and $2^d$, in that it is inversely proportional to the number of times the index can be divided by 2, with a maximum number of division of $d$.
This inversely proportional relation is illustrated in the table below, in which $d - bindeg_{i,d}$ is shown to be equal to the number of times $i$ is divisible by 2 when $d = 3 \implies 2^d = 8$.
Note that $i = 0$ is a special case, and the reason why +we can't have nice things+ there is a rule about having $d$ as the maximum number of divisions.

#+attr_latex: :placement [H]
| $i$                | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
|--------------------+---+---+---+---+---+---+---+---+---|
| $bindeg_{i,3}$     | 0 | 3 | 2 | 3 | 1 | 3 | 2 | 3 | 0 |
| $3 - bindeg_{i,3}$ | 3 | 0 | 1 | 0 | 2 | 0 | 1 | 0 | 3 |

We can enumerate the binary degrees relatives to $2^3 = 8$ like so:
 - $0 = bindeg_{0,3} = bindeg_{8, 3}$
 - $1 = bindeg_{4,3}$
 - $2 = bindeg_{2,3} = bindeg_{6,3}$
 - $3 = bindeg_{1,3} = bindeg_{3,3} = bindeg_{5,3} = bindeg_{7,3}$

This is just another way to present the binary degrees at subdivision degree 3.
The key observation is that the points with the highest binary degree are all the odd ones.
This phenomenon can be explained by construction:
 - When going from degree $d - 1$ to degree $d$, a new point is inserted between the first two.
 - This new point is now point $1$ and the points to its right are increased by $1$.
 - The next point will insert itself at the right of what was the odd point $1$ but now is the even point $2$ and we find ourselves in the initial case, we are inserting the new point into a odd position, thus moving the next point into an even position.
 - This situation repeats itself until the end of the sequence and explains why a point's index doubles every subdivision.

We now have at our disposition three elements which can be used to construct a definition for the binary degree:
 1. The first and last indexes, $0$ and $2^d$ always appears at degree $0$ ($bindeg_{0, d} = bindeg_{2^d, d} = 0$).
 2. Indexes are multiplied by two every subdivision, while their degree of appearance stays the same ($bindeg_{i,d} = bindeg_{2i, d + 1}$).
 3. Odd indexes have the maximal binary degree ($i \bmod 2 = 1 \implies bindeg_{i, d} = d$).

From 1., we have the initial values.
From 3., we have the values of odd points.
By combining 2. and 3., we can deduce the values of the other even points, because 2. is equivalent to $i \bmod 2 = 0 \implies bindeg_{i,d} = bindeg_{\frac{i}{2},d-1}$, thus we can divise even values until they are odd to obtain their binary degree.


* Octasierp primitives

In this section are implemented utilities to manipulate octasierps in a fundamental way.
Those utilities will most crucially help to store points, iterate on an octasierp in various manners and query information about an octasierp.

** Pointless octasierp

A =pointless_octasierp= is an octasierp that does not store points and is therefore only useful for theoretical manipulation.
I coudn't resist.
#+name: pointless_octasierp
#+begin_src cpp :minipage
struct pointless_octasierp {
    const std::size_t degree;

    // Maximum value of the half-axis (half-axis cardinality - 1).
    const int extreme_index;
    // Width of the rectangular storage of one quarter.
    const std::size_t quarter_rectangle_width;
    // Number of points of the rectangular storage of one quarter.
    const std::size_t quarter_rectangle_cardinality;

    pointless_octasierp()=delete;
    pointless_octasierp(std::size_t _degree):
        degree(_degree),
        extreme_index(1 << degree),
        quarter_rectangle_width(extreme_index - 1),
        quarter_rectangle_cardinality(quarter_rectangle_width * (extreme_index + 1))
    {}

    <<pointless_octasierp/public>>
};
#+end_src
#+depends:pointless_octasierp :noweb xy_coords :cpp array cmath

Note:
 - =extreme_index= in an =int= because the coordinate system uses negative indexes.

Since everyting is const, the only way to change the degree is to create a new =pointless_octasierp= instance, therefore the various cached variables bound to the degree are guaranteed to be kept in sync.

*** Point cardinality

The size of an octasierp, previously described as $\vert octasierp_d \vert = 2^{2d+2} + 2$, can be translated in C++ to the following, using the fact that $2^n$ can be expressed as =1 << n=:
#+begin_src cpp :noweb-ref pointless_octasierp/public :minipage
std::size_t point_cardinality() const {
    return (1 << (2 * degree + 2)) + 2;
}
#+end_src

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb print pointless_octasierp")>>

int main() {
    auto printer = print{{.sep=""}};
    for(std::size_t degree: {0, 1, 2, 3, 4}) {
        pointless_octasierp octa(degree);
        printer("This octasierp of degree ", degree, " would have had ",
                octa.point_cardinality(), " points had it not been pointless.");
    }
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
This octasierp of degree 0 would have had 6 points had it not been pointless.
This octasierp of degree 1 would have had 18 points had it not been pointless.
This octasierp of degree 2 would have had 66 points had it not been pointless.
This octasierp of degree 3 would have had 258 points had it not been pointless.
This octasierp of degree 4 would have had 1026 points had it not been pointless.
#+end_src

*** Coordinates validation

The representation of a squarified octasierp net of degree 2 below can help creating a coordinates validation method:
#+begin_src python :eval no-export :exports results
<<Textual squarified net>>
<<quarter_rep>>
# print(SquareNet(2, list(range(3)), show_axis=True, point_rep=quarter_rep))
print(SquareNet(2, list(range(3))))
#+end_src

#+RESULTS:
#+begin_src text :minipage
+-------x-x-x-x-x
x x x x x x x x |
x x x x x x x x |
x x x x x x x x |
x-x-x-x-X-x-x-x-x
| x x x x x x x x
| x x x x x x x x
| x x x x x x x x
+-x-x-x-x-------+
#+end_src

That method can take the form below, by first testing if the coordinates are within the internal square, and otherwise testing if they are within the top part of quarter 0 and otherwise test the other quarters by rotation.
#+begin_src cpp :noweb-ref pointless_octasierp/public :minipage
bool valid_coordinates(int i, int j) const {
    if(abs(i) < extreme_index && abs(j) < extreme_index)
        return true;
    if(j == extreme_index)
        return i >= 0 && i <= extreme_index;
    if(i == -extreme_index)
        return j >= 0 && j < extreme_index;
    if(j == -extreme_index)
        return i <= 0 && i > -extreme_index;
    return i == extreme_index && j <= 0 && j > -extreme_index;
}
#+end_src

The following function can be used to print a shadow of a squarified net by asking every step of the way whether the current coordinate is valid:
#+name: squarenet_shadow
#+begin_src cpp :minipage
template<typename WhichChar>
void squarenet_shadow(
    const pointless_octasierp& octa,
    const WhichChar& which_char
) {
    int extremum = (1 << octa.degree) + 1;
    for(int j = extremum; j >= -extremum; --j) {
        for(int i = -extremum; i <= extremum; ++i) {
            out(octa.valid_coordinates(i, j) ? which_char(xy_coords{i, j}): '.');
            if(i != extremum)
                out(" ");
        }
        out('\n');
    }
}
#+end_src
#+depends:squarenet_shadow :noweb pointless_octasierp out xy_coords

#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb pointless_octasierp squarenet_shadow")>>
int main() {
    pointless_octasierp octa(2);
    squarenet_shadow(octa, [](const auto& ignored){return 'X';});
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
. . . . . . . . . . .
. . . . . X X X X X .
. X X X X X X X X . .
. X X X X X X X X . .
. X X X X X X X X . .
. X X X X X X X X X .
. . X X X X X X X X .
. . X X X X X X X X .
. . X X X X X X X X .
. . X X X X . . . . .
. . . . . . . . . . .
#+end_src


** Indexing

=index_of= is a hairy beast because it is all about cutting a not-so-trivial figure into its more easily manageable components.
The illustration below shows those manageable components:
 - The north and south poles (=X= and =S=).
 - The four corners (=a=, =b=, =c= and =d=).
 - The isolated quarters (=0=, =1=, =2= and =3=).

# Helper to distinctly print the points representation according to quarter and degree.
#+name: quarter_rep
#+begin_src python :exports none
def quarter_rep(quarter):
    return [['a', '0'], ['b', '1'], ['c', '2'], ['d', '3']][quarter]
#+end_src
# This code block is disabled because the south pole has been inserted manually below.
#+begin_src python :eval never :exports results
<<Textual squarified net>>
<<quarter_rep>>
print(SquareNet(2, list(range(3)), show_axis=True, point_rep=quarter_rep))
#+end_src

#+RESULTS:
#+begin_src text :minipage
   ^
+4 |  +-------b-0-0-0-S
+3 |  1 1 1 1 1 0 0 0 |
+2 |  1 1 1 1 1 0 0 0 |
+1 |  1 1 1 1 1 0 0 0 |
 0 |  c-2-2-2-X-0-0-0-a
-1 |  | 2 2 2 3 3 3 3 3
-2 |  | 2 2 2 3 3 3 3 3
-3 |  | 2 2 2 3 3 3 3 3
-4 |  +-2-2-2-d-------+
   +-------------------->
      4 3 2 1 0 1 2 3 4
      - - - -   + + + +
#+end_src

In an attempt to make the beast below a bit more readable, it only contains the "cutting into manageable parts" logic.
The return statements are handled in the four next subsections, one per quarter.
This if forest can certainly be optimised, be it from a readability perspective or from a performance perspective.
#+begin_src cpp :noweb-ref pointless_octasierp/public :minipage
std::size_t index_of(int i, int j) const {
    if(i > 0) {
        if(j >= 0) {
            if(i < extreme_index) {
                <<Index of quarter 0 degree > 0>>
            } else {
                <<Index of corner 0 or south pole>>
            }
        } else {
            <<Index of quarter 3 degree > 0>>
        }
    } else if(i < 0) {
        if(j < 0) {
            <<Index of quarter 2 degree > 0>>
        } else if(j > 0) {
            <<Index of quarter 1 degree > 0>>
        } else { // j == 0
            if(i == -extreme_index) {
                <<Index of corner 2>>
            } else {
                <<Index of quarter 2 degree > 0>>
            }
        }
    } else { // i == 0
        if(j > 0) {
            if(j == extreme_index) {
                <<Index of corner 1>>
            } else {
                <<Index of quarter 1 degree > 0>>
            }
        } else if(j < 0) {
            if(j == -extreme_index) {
                <<Index of corner 3>>
            } else {
                <<Index of quarter 3 degree > 0>>
            }
        } // i == 0 and j == 0, therefore north pole.
    }
    <<Index of north pole>>
}
#+end_src

Not that the parameters =i= and =j= are assumed to be correct, that is to say they are assumed to refer to a valid canonical point.
It's up to the caller to ensure the validity of =i= and =j=.

*** Quarter 0

Illustration at degree 2 of the points that are handled in this section:
# This code block is disabled for the same reason as the previous one.
#+begin_src python :eval never :exports results :minipage
<<Textual squarified net>>
<<quarter_rep>>
print(SquareNet(2, list(range(3)), quarters={0}, show_axis=True, point_rep=quarter_rep))
#+end_src

#+RESULTS:
#+begin_src text :minipage
   ^
+4 |  +-------+-0-0-0-S
+3 |  |       | 0 0 0 |
+2 |  |       | 0 0 0 |
+1 |  |       | 0 0 0 |
 0 |  +-------X-0-0-0-a
-1 |  |       |       |
-2 |  |       |       |
-3 |  |       |       |
-4 |  +-------+-------+
   +-------------------->
      4 3 2 1 0 1 2 3 4
      - - - -   + + + +
#+end_src
\\
Legend:
 - =X= :: North pole.
 - =S= :: South pole.
 - =a= :: Corner 0.
 - =0= :: Points of degree greater than 0.

The indexes of the north pole, south pole and corner 0 are trivial to find.
#+name: Index of north pole
#+begin_src cpp :minipage
return 0;
#+end_src

#+name: Index of corner 0 or south pole
#+begin_src cpp :minipage
if(j == 0)
    return 2;
else
    return 1;
#+end_src

The other points are barely more difficult since it's just a rectangle indexation $+6$ after taking the points of degree 0 into account and $-1$ after taking the offset of =i= into account.
#+name: Index of quarter 0 degree > 0
#+begin_src cpp :minipage
return quarter_rectangle_width * j + i + 5;
#+end_src

*** Quarter 1

Illustration at degree 2 of the points that are handled in this section:
#+begin_src python :eval no-export :exports results :minipage
<<Textual squarified net>>
<<quarter_rep>>
print(SquareNet(2, list(range(3)), quarters={1}, show_axis=True, point_rep=quarter_rep))
#+end_src

#+RESULTS:
#+begin_src text :minipage
   ^
+4 |  +-------b-------+
+3 |  1 1 1 1 1       |
+2 |  1 1 1 1 1       |
+1 |  1 1 1 1 1       |
 0 |  +-------o-------+
-1 |  |       |       |
-2 |  |       |       |
-3 |  |       |       |
-4 |  +-------+-------+
   +-------------------->
      4 3 2 1 0 1 2 3 4
      - - - -   + + + +
#+end_src
\\
Legend:
 - =o= :: Origin, aka north pole.
 - =b= :: Corner 1.
 - =1= :: Points of degree greater than 0.
# Hello there.

#+name: Index of corner 1
#+begin_src cpp :minipage
return 3;
#+end_src

The other indexes can be computed in a similar way to quarter 0, with the following twists:
 1. =i= and =j= are swapped because quarter 1 is rotated left compared to quarter 0.
 2. =i= is negated because it is negative.
 3. =quarter_rectangle_cardinality= is added to the index to take the first quarter into account.
#+name: Index of quarter 1 degree > 0
#+begin_src cpp :minipage
return quarter_rectangle_width * -i + j + 5 + quarter_rectangle_cardinality;
#+end_src

*** Quarter 2

Illustration at degree 2 of the points that are handled in this section:
#+begin_src python :eval no-export :exports results
<<Textual squarified net>>
<<quarter_rep>>
print(SquareNet(2, list(range(3)), quarters={2}, show_axis=True, point_rep=quarter_rep))
#+end_src

#+RESULTS:
#+begin_src text :minipage
   ^
+4 |  +-------+-------+
+3 |  |       |       |
+2 |  |       |       |
+1 |  |       |       |
 0 |  c-2-2-2-o-------+
-1 |  | 2 2 2 |       |
-2 |  | 2 2 2 |       |
-3 |  | 2 2 2 |       |
-4 |  +-2-2-2-+-------+
   +-------------------->
      4 3 2 1 0 1 2 3 4
      - - - -   + + + +
#+end_src
\\
Legend:
 - =o= :: Origin, aka north pole.
 - =c= :: Corner 2.
 - =2= :: Points of degree greater than 0.

#+name: Index of corner 2
#+begin_src cpp :minipage
return 4;
#+end_src

This time, =i= and =j= are no longer swapped when compared to quarter 0 but they both have to be negated.
#+name: Index of quarter 2 degree > 0
#+begin_src cpp :minipage
return quarter_rectangle_width * -j -i + 5 + 2 * quarter_rectangle_cardinality;
#+end_src

*** Quarter 3

Illustration at degree 2 of the points that are handled in this section:
#+begin_src python :eval no-export :exports results
<<Textual squarified net>>
<<quarter_rep>>
print(SquareNet(2, list(range(3)), quarters={3}, show_axis=True, point_rep=quarter_rep))
#+end_src

#+RESULTS:
#+begin_src text :minipage
   ^
+4 |  +-------+-------+
+3 |  |       |       |
+2 |  |       |       |
+1 |  |       |       |
 0 |  +-------o-------+
-1 |  |       3 3 3 3 3
-2 |  |       3 3 3 3 3
-3 |  |       3 3 3 3 3
-4 |  +-------d-------+
   +-------------------->
      4 3 2 1 0 1 2 3 4
      - - - -   + + + +
#+end_src
\\
Legend:
 - =o= :: Origin, aka north pole.
 - =d= :: Corner 3.
 - =3= :: Points of degree greater than 0.

#+name: Index of corner 3
#+begin_src cpp :minipage
return 5;
#+end_src

#+name: Index of quarter 3 degree > 0
#+begin_src cpp :minipage
return quarter_rectangle_width * i -j + 5 + 3 * quarter_rectangle_cardinality;
#+end_src

*** Indexing directly with coordinates

#+begin_src cpp :noweb-ref pointless_octasierp/public :minipage
template<typename Coords>
std::size_t index_of(const Coords& coords) const {
    return index_of(coords.x, coords.y);
}
#+end_src


** Neighbours

The goal of this section is to write a method of =pointless_octasierp= that returns the neighbours of a given set of squarenet coordinates.

This method is rather complex because it handles a lot of different cases, which are illustrated below (the reality is worse that what the illustration suggests):
#+begin_src python :eval no :exports results :minipage
<<Textual squarified net>>
<<quarter_rep>>
print(SquareNet(2, list(range(3)), show_axis=True, point_rep=quarter_rep))
#+end_src

#+RESULTS:
#+begin_src text :minipage
   ^
+4 |  +-------I-°-°-#-I
+3 |  # ' ' ' ! . . ' |
+2 |  ° . . . ! . . ' |
+1 |  ° . . . ! . . ' |
 0 |  I-~-~-~-I-~-~-~-I
-1 |  | ' . . ! . . . °
-2 |  | ' . . ! . . . °
-3 |  | ' . . ! ' ' ' #
-4 |  +-#-°-°-I-------+
   +-------------------->
      4 3 2 1 0 1 2 3 4
      - - - -   + + + +
#+end_src
\\
Legend:
 - =~, != :: Natural borders between the quarters, following the x or y axis.
 - =.= :: Trivial points inside quarter 0, 1, 2 and 3.
 - ='= :: Long nightmare border.
 - =°= :: Short nightmare border.
 - =I= :: Initial points (poles and corners).
 - =#= :: Pseudo-corners, the hairiest case of them all.

One reason why the reality is more complex than the illustration is that every case different for each quarter.
There are:
 - 4 natural borders.
 - 4 rectangles of trivial points.
 - 4 long nightmare borders.
 - 4 short nightmare borders.
 - 2 poles.
 - 4 corners.
 - 4 Pseudo-corders.

So 26 different cases to handle.
This method is looong.

But first below is the result type.
Note that upon construction, every neighbour is initialised as a copy of the original point.
To give them their proper value, they will then be nudged in the right direction.

The initial points (the poles and corners) only have 4 neighbours but it would not make sense to put them in a separate type or to use dynamic storage for this type.
Instead, when asking for the neighbours of one of the initial points, the last two neighbours will be left intact.
This property can even be used to differentiate them.

#+begin_src cpp :noweb-ref pointless_octasierp/public :minipage
struct octasierp_neighbours {
    template<class Coords>
    octasierp_neighbours(Coords c):
        array{{{c.x, c.y}, {c.x, c.y}, {c.x, c.y}, {c.x, c.y}, {c.x, c.y}, {c.x, c.y}}}
    {}

    union {
        struct {
            xy_coords<int> n0;
            xy_coords<int> n1;
            xy_coords<int> n2;
            xy_coords<int> n3;
            xy_coords<int> n4;
            xy_coords<int> n5;
        };
        std::array<xy_coords<int>, 6> array;
    };

    bool is_initial_point() const {
        return n4 == n5;
    }
};
#+end_src

Redirection operator:
#+name: <<octasierp_neighbours
#+begin_src cpp :minipage
std::ostream& operator<<(
    std::ostream& os, const pointless_octasierp::octasierp_neighbours& el
) {
    os << "<"
       << "(" << el.n0.x << ", " << el.n0.y << "), "
       << "(" << el.n1.x << ", " << el.n1.y << "), "
       << "(" << el.n2.x << ", " << el.n2.y << "), "
       << "(" << el.n3.x << ", " << el.n3.y << ")";
    if(!el.is_initial_point()) {
        os << ", (" << el.n4.x << ", " << el.n4.y << "), "
           <<   "(" << el.n5.x << ", " << el.n5.y << ")";
    }
    return os << ">";
}
#+end_src
#+depends:<<octasierp_neighbours :noweb pointless_octasierp :cpp iostream

*** Cutting the squarenet

Not all the cases are represented here, the outline below roughly cuts the squarenet into quarters, corners and natural borders.
Most cases will be handled inside their respective quarters, in the next section.

#+begin_src cpp :noweb-ref pointless_octasierp/public
template<class Coords>
octasierp_neighbours neighbours(Coords c) {
    octasierp_neighbours result(c);
    if(c.x > 0) { // Right.
        if(c.y > 0) { // Up right (inside q0).
            <<fill_octa_neighbours/inside_quarter0>>
        } else if(c.y < 0) { // Down right (inside q3).
            <<fill_octa_neighbours/inside_quarter3>>
        } else { // Positive x axis.
            if(c.x == extreme_index) { // Corner 0.
                <<fill_octa_neighbours/corner0>>
            } else { // Any other point on the natural border towards corner 0.
                <<fill_octa_neighbours/right_natural_border>>
            }
        }
    } else if(c.x < 0) { // Left.
        if(c.y > 0) { // Up left (inside q1).
            <<fill_octa_neighbours/inside_quarter1>>
        } else if(c.y < 0) { // Down left (inside q2).
            <<fill_octa_neighbours/inside_quarter2>>
        } else { // Negative x axis.
            if(c.x == -extreme_index) { // Corner 2.
                <<fill_octa_neighbours/corner2>>
            } else { // Any other point on the natural border towards corner 2.
                <<fill_octa_neighbours/left_natural_border>>
            }
        }
    } else { // y axis.
        if(c.y > 0) { // Positive y axis.
            if(c.y == extreme_index) { // Corner 1.
                <<fill_octa_neighbours/corner1>>
            } else { // Any other point on the natural border towards corner 1.
                <<fill_octa_neighbours/top_natural_border>>
            }
        } else if(c.y < 0) { // Negative y axis.
            if(c.y == - extreme_index) { // Corner 3.
                <<fill_octa_neighbours/corner3>>
            } else { // Any other point on the natural border towards corner 3.
                <<fill_octa_neighbours/bottom_natural_border>>
            }
        } else { // Origin (north pole).
            <<fill_octa_neighbours/north_pole>>
        }
    }
    return result;
}
#+end_src

Convenience overload:
#+begin_src cpp :noweb-ref pointless_octasierp/public :minipage
octasierp_neighbours neighbours(int x, int y) {
    return neighbours(xy_coords{x, y});
}
#+end_src

*** Inside of quarters

This section is the most intense because this is where all the nightmare coordinates are handled.

This is also where some easy cases can be found, i.e. the points inside the trivial rectangles.
Those points can be separated in two categories, the ones whose upwards diagonal neighbours are in the left direction, and the those whose diagonals are in the right direction.

Those simple cases double as an introduction to the storage order of the neighbours.
Using the referential of the squarenet coordinates, the first neighbour is always the one to the right and the other neighbours are ordered counterclockwise.

The left diagonals correspond to quarters 0 and 2:
#+name: fill_octa_neighbours/upleft_diagonal
#+begin_src cpp :minipage
++result.n0.x;                // Right.
++result.n1.y;                // Up.
--result.n2.x; ++result.n2.y; // Up left.
--result.n3.x;                // Left.
--result.n4.y;                // Down.
++result.n5.x; --result.n5.y; // Down right.
#+end_src

The right diagonals are found on quarters 1 and 3:
#+name: fill_octa_neighbours/upright_diagonal
#+begin_src cpp :minipage
++result.n0.x;                // Right.
++result.n1.x; ++result.n1.y; // Up right.
++result.n2.y;                // Up.
--result.n3.x;                // Left.
--result.n4.x; --result.n4.y; // Down left.
--result.n5.y;                // Down.
#+end_src

Quarter 0 needs more code that the other quarters because it also has the south pole:
#+name: fill_octa_neighbours/inside_quarter0
#+begin_src cpp :minipage
if(c.y == extreme_index) { // Top part of quarter 0's nightmare border.
    if(c.x >= extreme_index - 1) { // Pseudo-corner 0 or south pole.
        if(c.x == extreme_index) { // South pole.
            <<fill_octa_neighbours/south_pole>>
        } else { // Pseudo-corner 0.
            ++result.n0.x;                               // Right      (on q0). South pole.
            result.n1.x = -extreme_index; --result.n1.y; // Top right  (on q1). Pseudo-corner 1.
            result.n2.x = -c.x; --result.n2.y;           // Top        (on q1).
            --result.n3.x;                               // Left       (on q0).
            --result.n4.y;                               // Down       (on q0).
            ++result.n5.x; result.n5.y = -c.x;           // Down right (on q3). Pseudo-corner 3.
        }
    } else { // Any other point of the top of quarter 0's nightmare border.
        ++result.n0.x;                        // Right      (on q0).
        result.n1.x = -c.x -1; --result.n1.y; // Top right  (on q1).
        result.n2.x = -c.x; --result.n2.y;    // Top        (on q1).
        --result.n3.x;                        // Left       (on q0/q1).
        --result.n4.y;                        // Down       (on q0).
        ++result.n5.x; --result.n5.y;         // Down right (on q0).
    }
} else if(c.x == extreme_index - 1) { // Right part of quarter 0's nightmare border.
    ++result.n0.x; result.n0.y = -c.y;     // Right      (on q3).
    ++result.n1.y;                         // Up         (on q0).
    --result.n2.x; ++result.n2.y;          // Up left    (on q0).
    --result.n3.x;                         // Left       (on q0).
    --result.n4.y;                         // Down       (on q0/q3).
    ++result.n5.x; result.n5.y = -c.y + 1; // Down right (on q3/q0).
} else { // Trivial part of quarter 0.
    <<fill_octa_neighbours/upleft_diagonal>>
}
#+end_src

Quarter 1:
#+name: fill_octa_neighbours/inside_quarter1
#+begin_src cpp :minipage
if(c.x == -extreme_index) { // Left part of quarter 1's nightmare border.
    if(c.y == extreme_index - 1) { // Pseudo-corner 1.
        ++result.n0.x;                                   // Right    (on q1).
        result.n1.x = extreme_index - 1; ++result.n1.y;  // Up right (on q0). Pseudo-corner 0.
        result.n2.x = result.n2.y = extreme_index;       // Up       (on q0). South pole.
        ++result.n3.x; result.n3.y = -extreme_index;     // Up left  (on q2). Pseudo-corner 2.
        ++result.n4.x; result.n4.y = -extreme_index + 1; // Left     (on q2).
        --result.n5.y;                                   // Down     (on q1).
    } else { // Any other point of the left part of quarter 1's nightmare border.
        ++result.n0.x;                         // Right    (on q1).
        ++result.n1.x; ++result.n1.y;          // Up right (on q1).
        ++result.n2.y;                         // Up       (on q1).
        ++result.n3.x; result.n3.y = -c.y - 1; // Up left  (on q2).
        ++result.n4.x; result.n4.y = -c.y;     // Left     (on q2).
        --result.n5.y;                         // Down     (on q1/q2).
    }
} else if(c.y == extreme_index - 1) { // Top part of quarter 1's nightmare border.
    ++result.n0.x;                         // Right     (on q1/q0).
    result.n1.x = -c.x - 1; ++result.n1.y; // Up right  (on q0/q1).
    result.n2.x = -c.x; ++result.n2.y;     // Up        (on q0).
    --result.n3.x;                         // Left      (on q1).
    --result.n4.x; --result.n4.y;          // Down left (on q1).
    --result.n5.y;                         // Down      (on q1).
} else { // Trivial part of quarter 1.
    <<fill_octa_neighbours/upright_diagonal>>
}
#+end_src

Quarter 2:
#+name: fill_octa_neighbours/inside_quarter2
#+begin_src cpp :minipage
if(c.y == -extreme_index) { // Bottom part of quarter 2's nightmare border.
    if(c.x == -extreme_index + 1) { // Pseudo-corner 2.
        ++result.n0.x;                                  // Right     (on q2).
        ++result.n1.y;                                  // Up        (on q2).
        --result.n2.x; result.n2.y = extreme_index - 1; // Up left   (on q1). Pseudo-corner 1.
        result.n3.x = result.n3.y = extreme_index;      // Left      (on q0). South pole.
        result.n4.x = extreme_index; ++result.n4.y;     // Down left (on q3). Pseudo-corner 3.
        result.n5.x = extreme_index - 1; ++result.n5.y; // Down      (on q3).
    } else { // Any other point of the bottom part of quarter 2's nightmare border.
        ++result.n0.x;                         // Right     (on q2/q3).
        ++result.n1.y;                         // Up        (on q2).
        --result.n2.x; ++result.n2.y;          // Up left   (on q2).
        --result.n3.x;                         // Left      (on q2).
        result.n4.x = -c.x + 1; ++result.n4.y; // Down left (on q3).
        result.n5.x = -c.x; ++result.n5.y;     // Down      (on q3).
    }
} else if(c.x == -extreme_index + 1) { // Left part of quarter 2's nightmare border.
    ++result.n0.x;                         // Right      (on q2).
    ++result.n1.y;                         // Up         (on q2/q1).
    --result.n2.x; result.n2.y = -c.y - 1; // Up left    (on q1/q2).
    --result.n3.x; result.n3.y = - c.y;    // Left       (on q1).
    --result.n4.y;                         // Down       (on q2).
    ++result.n5.x; --result.n5.y;         // Down right (on q2).
} else { // Trivial part of quarter 2.
    <<fill_octa_neighbours/upleft_diagonal>>
}
#+end_src


Quarter 3:
#+name: fill_octa_neighbours/inside_quarter3
#+begin_src cpp :minipage
if(c.x == extreme_index) { // Right part of quarter 3's nightmare border.
    if(c.y == -extreme_index + 1) { // Pseudo-corner 3.
        --result.n0.x; result.n0.y = extreme_index - 1;  // Right      (on q0).
        ++result.n1.y;                                   // Up         (on q3).
        --result.n2.x;                                   // Left       (on q3).
        result.n3.x = -extreme_index + 1; --result.n3.y; // Down left  (on q2). Pseudo-corner 2.
        result.n4.x = result.n4.y = extreme_index;       // Down       (on q0). South pole.
        --result.n5.x; result.n5.y = extreme_index;      // Down right (on q0). Pseudo-corner 0.
    } else { // Any other point on the right part of quarter 3's nightmare border.
        --result.n0.x; result.n0.y = -c.y;     // Right      (on q0).
        ++result.n1.y;                         // Up         (on q3/q0).
        --result.n2.x;                         // Left       (on q3).
        --result.n3.x; --result.n3.y;          // Down left  (on q3).
        --result.n4.y;                         // Down       (on q3).
        --result.n5.x; result.n5.y = -c.y + 1; // Down right (on q0).
    }
} else if(c.y == -extreme_index + 1) { // Bottom part of quarter 3's nightmare border.
    ++result.n0.x;                         // Right     (on q3).
    ++result.n1.x; ++result.n1.y;          // Up right  (on q3).
    ++result.n2.y;                         // Up        (on q3).
    --result.n3.x;                         // Left      (on q3/q2).
    result.n4.x = -c.x + 1; --result.n4.y; // Down left (on q2/q3).
    result.n5.x = -c.x; --result.n5.y;     // Down      (on q2).
} else { // Trivial part of quarter 3.
    <<fill_octa_neighbours/upright_diagonal>>
}
#+end_src

*** Natural borders

Towards corner 0:
#+name: fill_octa_neighbours/right_natural_border
#+begin_src cpp :minipage
++result.n0.x;                // Right     (on q0).
++result.n1.y;                // Up        (on q0).
--result.n2.x; ++result.n2.y; // Up left   (on q0/q1).
--result.n3.x;                // Left      (on q0).
--result.n4.x; --result.n4.y; // Down left (on q3).
--result.n5.y;                // Down      (on q3).
#+end_src

Towards corner 1:
#+name: fill_octa_neighbours/top_natural_border
#+begin_src cpp :minipage
++result.n0.x;                // Right      (on q0).
++result.n1.y;                // Up         (on q1).
--result.n2.x;                // Left       (on q1).
--result.n3.x; --result.n3.y; // Down left  (on q1/q2).
--result.n4.y;                // Down       (on q1/q0).
++result.n5.x; --result.n5.y; // Down right (on q0).
#+end_src

Towards corner 2:
#+name: fill_octa_neighbours/left_natural_border
#+begin_src cpp :minipage
++result.n0.x;                // Right      (on q2/q0).
++result.n1.x; ++result.n1.y; // Up right   (on q1).
++result.n2.y;                // Up         (on q1).
--result.n3.x;                // Left       (on q2).
--result.n4.y;                // Down       (on q2).
++result.n5.x; --result.n5.y; // Down right (on q2/q3).
#+end_src

Towards corner 3:
#+name: fill_octa_neighbours/bottom_natural_border
#+begin_src cpp :minipage
++result.n0.x;                // Right    (on q3).
++result.n1.x; ++result.n1.y; // Up right (on q3/q0).
++result.n2.y;                // Up       (on q3/q0).
--result.n3.x; ++result.n3.y; // Up left  (on q2).
--result.n4.x;                // Left     (on q2).
--result.n5.y;                // Down     (on q3).
#+end_src

*** Corners

The corners require a special case for degree 0 because in this configuration they are neighbours with the south pole, but except for corner 1, the generic implementation gives redundant coordinates instead of the canonical ones.

Corner 0:
#+name: fill_octa_neighbours/corner0
#+begin_src cpp :minipage
--result.n0.x; ++result.n0.y; // Up left   (on q0).
--result.n1.x;                // Left      (on q0).
--result.n2.x; --result.n2.y; // Down left (on q3).
if(degree == 0)
    result.n3.y = 1;          // Special case.
else
    --result.n3.y;            // Down      (on q3).
#+end_src

Corner 1:
#+name: fill_octa_neighbours/corner1
#+begin_src cpp :minipage
++result.n0.x;                // Right      (on q0).
--result.n1.x; --result.n1.y; // Down left  (on q1).
--result.n2.y;                // Down       (on q1).
++result.n3.x; --result.n3.y; // Down right (on q0).
#+end_src

Corner 2:
#+name: fill_octa_neighbours/corner2
#+begin_src cpp :minipage
++result.n0.x;                     // Right      (on q2).
++result.n1.x; ++result.n1.y;      // Up right   (on q1).
if(degree == 0)
    result.n2.x = result.n2.y = 1; //Special case.
else
    ++result.n2.y;                 // Up         (on q1).
++result.n3.x; --result.n3.y;      // Down right (on q2).
#+end_src

Corner 3:
#+name: fill_octa_neighbours/corner3
#+begin_src cpp :minipage
++result.n0.x; ++result.n0.y;      // Up right (on q3).
++result.n1.y;                     // Up       (on q3).
--result.n2.x; ++result.n2.y;      // Up left  (on q2).
if(degree == 0)
    result.n3.x = result.n3.y = 1; // Special case.
else
    --result.n3.x;                 // Left     (on q2).
#+end_src

*** Poles

The poles are refreshingly simple.
Even though the south pole does its own thing.

North pole:
#+name: fill_octa_neighbours/north_pole
#+begin_src cpp :minipage
++result.n0.x; // Right (on q0).
++result.n1.y; // Up    (on q1).
--result.n2.x; // Left  (on q2).
--result.n3.y; // Down  (on q3).
#+end_src

South pole:
#+name: fill_octa_neighbours/south_pole
#+begin_src cpp :minipage
result.n0.x = -extreme_index + 1; result.n0.y = -extreme_index; // "Right" (on q2).
result.n1.x = extreme_index; result.n1.y = -extreme_index + 1;  // "Up"    (on q3).
--result.n2.x;                                                  // "Left"  (on q0).
result.n3.x = - extreme_index; result.n3.y = extreme_index - 1; // "Down"  (on q1).
#+end_src

*** Usage

To show that at least neighbour cardinality is consistant with the expectations, the code below counts the number of times a point appears as the neighbour of another, and prints the corresponding squarenet shadow.

#+begin_src cpp :eval no-export :exports both :flags -std=c++20 -Wall
<<include(":noweb print pointless_octasierp squarenet_shadow <<octasierp_neighbours :cpp vector")>>

int main() {
    pointless_octasierp octa(2);
    std::vector<char> neighbour_cardinality(octa.point_cardinality(), '0');
    for(int x = -octa.extreme_index; x <= octa.extreme_index; ++x) {
        for(int y = -octa.extreme_index; y <= octa.extreme_index; ++y) {
            if(octa.valid_coordinates(x, y)) {
                auto neighbours = octa.neighbours(x, y);
                ++neighbour_cardinality[octa.index_of(neighbours.n0)];
                ++neighbour_cardinality[octa.index_of(neighbours.n1)];
                ++neighbour_cardinality[octa.index_of(neighbours.n2)];
                ++neighbour_cardinality[octa.index_of(neighbours.n3)];
                if(!neighbours.is_initial_point()) {
                    ++neighbour_cardinality[octa.index_of(neighbours.n4)];
                    ++neighbour_cardinality[octa.index_of(neighbours.n5)];
                }
            }
        }
    }

    squarenet_shadow(
        octa,
        [&](auto coords) {return neighbour_cardinality[octa.index_of(coords)];}
    );

    // Demonstration of the ostream operator.
    print{};
    print{"Neighbours of the north pole:", octa.neighbours(0, 0)};
    print{"Neighbours of (1, 0):        ", octa.neighbours(1, 0)};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
. . . . . . . . . . .
. . . . . 4 6 6 6 4 .
. 6 6 6 6 6 6 6 6 . .
. 6 6 6 6 6 6 6 6 . .
. 6 6 6 6 6 6 6 6 . .
. 4 6 6 6 4 6 6 6 4 .
. . 6 6 6 6 6 6 6 6 .
. . 6 6 6 6 6 6 6 6 .
. . 6 6 6 6 6 6 6 6 .
. . 6 6 6 4 . . . . .
. . . . . . . . . . .

Neighbours of the north pole: <(1, 0), (0, 1), (-1, 0), (0, -1)>
Neighbours of (1, 0):         <(2, 0), (1, 1), (0, 1), (0, 0), (0, -1), (1, -1)>
#+end_src

This is precisely the cardinality expected (4 neighbours for the initial points, 6 neighbours for every other point).


** Storage

The code block below forms the outline of the actual octasierp implementation, the one using a =std::vector= to store the points.

#+name: octasierp
#+begin_src cpp :minipage
template<typename Point>
class octasierp {
  private:
    pointless_octasierp bound_;

  public:
    using value_type = Point;
    std::vector<Point> storage;

    octasierp()=delete;
    octasierp(std::size_t degree, Point const& initial_value):
        bound_(degree), storage(bound_.point_cardinality(), initial_value)
    {}

    auto begin() {return storage.begin();}
    auto end() {return storage.end();}
    auto begin() const {return storage.begin();}
    auto end() const {return storage.end();}
    auto size() const {return storage.size();}

    const pointless_octasierp& bound() const {return bound_;}
    auto degree() const {return bound_.degree;}

    <<octasierp/public>>
};
#+end_src
#+depends:octasierp :noweb pointless_octasierp :cpp vector cmath

Points iteration is built into the above via the =begin= and =end= shortcuts, which makes range-based iteration possible as shown below:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb octasierp type_str print")>>
int main() {
    octasierp octa(1, -1);
    print{"Built an octasierp of degree", octa.degree(),
          "containing", octa.size(), type_str<decltype(octa)::value_type>()};
    for(auto point: octa)
        print{{.end="|"}}(point);
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Built an octasierp of degree 1 containing 18 int
-1|-1|-1|-1|-1|-1|-1|-1|-1|-1|-1|-1|-1|-1|-1|-1|-1|-1|
#+end_src

*** Indexing

Those indexing methods are delegating all the work to =bound_='s =index_of= method.
#+begin_src cpp :noweb-ref octasierp/public :minipage
const Point& point(int x, int y) const {
    return storage[bound_.index_of(x, y)];
}

Point& point(int x, int y) {
    return storage[bound_.index_of(x, y)];
}
#+end_src

For convenience, here is a square brackets operator that will work on anything with =x= and =y= fields:
#+begin_src cpp :noweb-ref octasierp/public :minipage
template<typename Coords>
const Point& operator[](const Coords& coords) const {
    return point(coords.x, coords.y);
}
template<typename Coords>
Point& operator[](const Coords& coords) {
    return point(coords.x, coords.y);
}
#+end_src

*** Indexing usage

The code below prints a squarenet shadow whose individual points are the actual point itself, each point having been initialised to its own character.
Therefore, beyond being a usage example, this is also a pretty good illustration of the storage order.

#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb octasierp squarenet_shadow")>>
int main() {
    octasierp octa(2, '0');
    std::string representation("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/*-+");
    int i = 0;
    for(auto& point: octa) {
        point = representation[i++];
    }
    squarenet_shadow(octa.bound(), [&octa](const auto& coords){
        return octa[coords];
    });
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
. . . . . . . . . . .
. . . . . 3 i j k 1 .
. z w t q n f g h . .
. y v s p m c d e . .
. x u r o l 9 a b . .
. 4 C B A 0 6 7 8 2 .
. . F E D P S V Y * .
. . I H G Q T W Z - .
. . L K J R U X / + .
. . O N M 5 . . . . .
. . . . . . . . . . .
#+end_src

*** Note on the pointless and point-filled octahedra variants

The idea behind separating =octasierp= from =pointless_octasierp= is to be able to query the various properties of an octasierp without having to actually allocate points.
Therefore, everything not directly linked with the actual storage will go in the =pointless_octasierp=.


** Quarter rotation

A key notion when manipulation octasierps is that of construction by rotation, meaning that operations can often be defined for quarter 0 and then be applied to the other quarters by rotation.
This section's goal is to transform this notion of construction by rotation from an analytical tool to a programming one.

There is a lot of strange details with very generic names in this implementation so most of it will go inside the namespace =quarter_rotation_details=.

#+name: quarter_rotation_details
#+begin_src cpp :minipage
namespace quarter_rotation_details {
<<quarter_rotation_details/public>>
} // quarter_rotation_details
#+end_src

*** Directed axes

Since quarters 1, 2 and 3 are successive left rotations of quarter 0, moving a point in a given direction will have a different meaning depending on the quarter.
For example, quarter 2 is the exact opposite of quarter 1.
This means that incrementing x in quarter 2 is like decrementing it in quarter 0.

The first step toward supporting this behaviour is directed axes, implemented in =natural_axis= and =inverted_axis=.
The =value_= stored is not directly accessible on purpose, as those classes meant to represent a restricted set of operations on an axis.

=axis= forms the base of =natural_axis= and =inverted_axis=, with only four operations delcared:
#+begin_src cpp :noweb-ref quarter_rotation_details/public :minipage
enum class direction {natural, inverted};
template<direction Dir> class axis {
  public:
    axis(int value):
        value_(value)
    {}

    int operator+=(int);
    int operator-=(int);
    int operator*();
    bool operator==(const axis&) const=default;
    int operator++() {return *this += 1;}
    int operator--() {return *this -= 1;}

  private:
    int value_;
};
#+end_src

Incrementation and decrementation:
#+begin_src cpp :noweb-ref quarter_rotation_details/public :minipage
template<> int axis<direction::natural>::operator+=(int n)
{return value_ += n;}
template<> int axis<direction::natural>::operator-=(int n)
{return value_ -= n;}

template<> int axis<direction::inverted>::operator+=(int n)
{value_ -= n; return -value_;}
template<> int axis<direction::inverted>::operator-=(int n)
{value_ += n; return -value_;}
#+end_src

Note that the inverted operators return a negated value, this is done in order to allow the usage of iteration on both inverted and natural axes on the same way.
Alternatively, the operator =*= can be used for this:
#+begin_src cpp :noweb-ref quarter_rotation_details/public :minipage
template<> int axis<direction::natural>::operator*() {return value_;}
template<> int axis<direction::inverted>::operator*() {return -value_;}
#+end_src

Proper definition of =natural_axis= and =inverted_axis=:
#+begin_src cpp :noweb-ref quarter_rotation_details/public :minipage
using natural_axis = axis<direction::natural>;
using inverted_axis = axis<direction::inverted>;
#+end_src

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb quarter_rotation_details/public print")>>

int main() {
    inverted_axis inv(0);
    natural_axis nat(0);
    while(++inv < 15);
    while(++nat < 15);
    print{++inv, ++nat};
    print{*inv, *nat};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
16 16
16 16
#+end_src
\\
The usefulness of those classes is not apparent right now.
The fact is that while using them in this manner gives the same behaviour, their actual state (=_value=) is different, which will become pertinent later on.

*** Quarter reference frame

=QRF= (Quarter Reference Frame) builds upon the directed axes to provide a way to represent operations on each quarter, vis-a-vis quarter 0, the canonical reference frame.

#+begin_src cpp :noweb-ref quarter_rotation_details/public :minipage
// Quarter Reference Frame
template<int Id>
struct QRF {};

template<> struct QRF<0> {
    natural_axis x;
    natural_axis y;
};

template<> struct QRF<1> {
    inverted_axis y;
    natural_axis x;
};

template<> struct QRF<2> {
    inverted_axis x;
    inverted_axis y;
};

template<> struct QRF<3> {
    natural_axis y;
    inverted_axis x;
};
#+end_src
The replacement of a =natural_axis= by an =inverted_axis= and /vice versa/ represents an inversion of this axis.
More subtly, the swapping of the axes is encoded in their order.

For example, where =QRF<0>= is laid out as ={x, y}=, =QRF<1>= is laid out as ={-y, x}= because that is what happens when going from quarter 0 from quarter 1.
The axes are rotated 90\textdegree{} left, thus the x axis is now the y axis and the y axis is now the opposite the x axis.
In other words, the axes have been swapped and what was the x axis but is now the y axis must be negated.

See below for an illustration of this situation:
#+begin_src text :minipage
Quarter 0 (x, y):

         ^ y
         |
         |
  -------+------>
         |      x
         |
         |

___________________

#+end_src
#+begin_src text :minipage

Quarter 1 (x', y'):

         ^ x' = y
         |
         |
  <------+-------
 y' = -x |
         |
         |
#+end_src


\\
The following template will be useful to extract the quarter represented by a given =QRF=:
#+begin_src cpp :noweb-ref quarter_rotation_details/public :minipage
template<typename QRF_>
struct QRF_quarter;

template<int Quarter>
struct QRF_quarter<QRF<Quarter>> {enum {v = Quarter};};
#+end_src

\\
This code block below recapitulates the usage of everything that has been defined up to now in this section:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb quarter_rotation_details print print_size")>>

using namespace quarter_rotation_details;

template<int Quarter>
struct point_quarter {
    union {
        QRF<Quarter> axes;
        struct {
            const int x;
            const int y;
        };
    };
};

template<int Quarter, typename Lambda>
void apply_on_origin(Lambda lambda) {
    point_quarter origin{QRF<Quarter>{0, 0}};
    lambda(origin);
}

int main() {
    auto axes_direction = [] <typename T> (T& point) {
        ++point.axes.x;
        ++point.axes.y;
        char x_sign = point.x > 0 ? '+': '-';
        char y_sign = point.y > 0 ? '+': '-';
        print{{.sep="", .end="    "}}(
            "Quarter ", QRF_quarter<decltype(T::axes)>::v,
            " (", x_sign, "x, ", y_sign, "y)"
        );
        print_size<T>();
    };
    apply_on_origin<0>(axes_direction);
    apply_on_origin<1>(axes_direction);
    apply_on_origin<2>(axes_direction);
    apply_on_origin<3>(axes_direction);
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Quarter 0 (+x, +y)    point_quarter<0> -> 8 bytes (64 bits)
Quarter 1 (-x, +y)    point_quarter<1> -> 8 bytes (64 bits)
Quarter 2 (-x, -y)    point_quarter<2> -> 8 bytes (64 bits)
Quarter 3 (+x, -y)    point_quarter<3> -> 8 bytes (64 bits)
#+end_src
\\

There is a lot to unpack from this usage example.
 - The intended way to access the value of a =QRF= is to store it in a union alongside an anonymous struct containing two constant ints.
   Since members of a union share the same layout, those ints map the ones stored in the =QRF= axes.

   This is where the inversion of the axes order in the =QRF= becomes pertinent because when this order is inverted, the anonymous struct is not inverted.
   Therefore in those cases, the struct's =x= maps to the =QRF='s =y= and /vice versa/, thus reflecting the swapped axes caused by the rotation.

 - A templated lambda can be used to apply operations transparently on a given quarter referential.
   In this instance, the lambda is used to show the orientation of the axes of each quarter referential, as well as the size of the lambda parameter.

*** Id of the left, back and right quarters

Since quarters are numbered using successive left rotations from quarter 0, the id of the quarter to its left, its back and its right can be obtained by adding respectively 1, 2 and 3.
And since they wrap around after quarter 3, applying modulo 4 makes this approach work for all 4 quarters.
#+begin_src cpp :noweb-ref quarter_rotation_details/public :minipage
template<int quarter>
constexpr int left_quarter() {
    return (quarter + 1) % 4;
}

template<int quarter>
constexpr int back_quarter() {
    return (quarter + 2) % 4;
}

template<int quarter>
constexpr int right_quarter() {
    return (quarter + 3) % 4;
}
#+end_src

*** Quarter coordinates

Quarter coordinates are represented using the technique of the anonymous union exposing a =QRF='s true =x= and =y= values with the left, back and right rotation of the quarter also included.
It should be noted that the constructor always takes values from the canonical quarter, even if the =Quarter= template parameter is something else that 0.

#+begin_src cpp :noweb-ref quarter_rotation_details/public :minipage
<<coordinates<Quarter>/pre>>
template<int Quarter>
struct coordinates {
    static constexpr int main_id = Quarter;
    static constexpr int left_id = left_quarter<Quarter>();
    static constexpr int back_id = back_quarter<Quarter>();
    static constexpr int right_id = right_quarter<Quarter>();

    union {
        QRF<main_id> main;
        QRF<left_id> left;
        QRF<back_id> back;
        QRF<right_id> right;
        struct {
            const int x;
            const int y;
        };
        <<coordinates<Quarter>/union>>
    };

    coordinates(int _x, int _y): x(_x), y(_y) {}
    coordinates(): coordinates(0, 0) {}
    <<coordinates<Quarter>/public>>
};
#+end_src

Verification of the correctness of the rotations:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb quarter_rotation_details print")>>

using namespace quarter_rotation_details;

template<int Quarter>
void print_quarter_layout() {
    print{
        "quarter", Quarter,
        "main:", coordinates<Quarter>::main_id,
        "left:", coordinates<Quarter>::left_id,
        "back:", coordinates<Quarter>::back_id,
        "right:", coordinates<Quarter>::right_id,
    };
}

int main() {
    print_quarter_layout<0>();
    print_quarter_layout<1>();
    print_quarter_layout<2>();
    print_quarter_layout<3>();
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
quarter 0 main: 0 left: 1 back: 2 right: 3
quarter 1 main: 1 left: 2 back: 3 right: 0
quarter 2 main: 2 left: 3 back: 0 right: 1
quarter 3 main: 3 left: 0 back: 1 right: 2
#+end_src

\\
Everything is as expected.

*** Printing quarter coordinates

This redirection operator can be used to print coordinates:
#+name: <<qoords
#+begin_src cpp :minipage
namespace quarter_rotation_details {
template<int Quarter>
std::ostream& operator<<(std::ostream& os, const coordinates<Quarter>& c) {
    os << "(";
    if(c.x >= 0)
        os << '+'; // To better align coordinates.
    os << c.x << ", ";
    if(c.y >= 0)
        os << '+';
    return os << c.y << ")";
}
} // namespace quarter_rotation_details
#+end_src
#+depends:<<qoords :noweb quarter_rotation_details :cpp iostream

The name of this block is shortened to =<<qoords= rather than something like =<<octasierp/quarter-coordinates=, for the sake of brevity.

*** Rotation of the quarter coordinates

Rotating quarter coordinates requires a read/write access to the storage so the anonymous union must be updated:
#+begin_src cpp :noweb-ref coordinates<Quarter>/union :minipage
struct {
    int __private_x;
    int __private_y;
};
#+end_src

The =rotate_left=, =rotate_back= and =rotate_right= methods reflect the axis-swapping-and-inverting logic of =QRF= but in a dynamic manner, acting on stored values, where =QRF='s logic is statically embedded in the type of its members and the order of its layout.
Those methods are equivalent to applying respectively one, two or three rotations.
#+begin_src cpp :noweb-ref coordinates<Quarter>/public :minipage
void rotate_left()  {rotate<1>(*this);}
void rotate_back()  {rotate<2>(*this);}
void rotate_right() {rotate<3>(*this);}
#+end_src

To make the implementation of =rotate= a bit clearer, but also to have those operations easily accessible from the outside, the following functions can be used to mirror and swap the axes.
#+begin_src cpp :noweb-ref coordinates<Quarter>/public :minipage
void mirror_x() {__private_x = -__private_x;}
void mirror_y() {__private_y = -__private_y;}
void swap_axes() {std::swap(__private_x, __private_y);}
#+end_src

The actual implementation of 1, 2, and 3 (and 0) rotations is a bit painful because it is a specialisation of a templated method within a templated class, with the inner template argument having to be specialised while the outer template argument should stay generic.
I found no better way than to do that than using a helper templated struct with the templates reversed, i.e. the inner template becomes the outer one and /vice versa/.
#+begin_src cpp :noweb-ref coordinates<Quarter>/pre :minipage
template<int Rotations>
struct rotate_impl {template<typename T> static void f(T&);};
template<> struct rotate_impl<0> {
    template<typename T> static void f(T& coord) {}
};
template<> struct rotate_impl<1> {
    template<typename T> static void f(T& coord) {
        coord.mirror_y();
        coord.swap_axes();
    }
};
template<> struct rotate_impl<2> {
    template<typename T> static void f(T& coord) {
        coord.mirror_x();
        coord.mirror_y();
    }
};
template<> struct rotate_impl<3> {
    template<typename T> static void f(T& coord) {
        coord.mirror_x();
        coord.swap_axes();
    }
};

template<int Rotations, typename T>
void rotate(T& coords) {
    rotate_impl<Rotations>::f(coords);
}
#+end_src

The following usage example shows the equivalency between the rotation encoded in the structure of =QRF= and the one enacted on the state by the rotation methods:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb quarter_rotation_details print <<qoords")>>

using namespace quarter_rotation_details;

template<int Quarter>
void demonstrate_rotation() {
    print{};
    print{"-----------------------"};
    print{"Quarter", Quarter};
    coordinates<Quarter> point(0, 0);
    auto copy = point;
    for(int i = 0; i < 4; ++i) {
        ++point.main.x;
        ++copy.left.x;
    }
    print{"Main incremented:", point};
    print{"Left incremented:", copy};
    copy.rotate_right();
    print{"Rotated right:   ", copy};
}

int main() {
    demonstrate_rotation<0>();
    demonstrate_rotation<1>();
    demonstrate_rotation<2>();
    demonstrate_rotation<3>();
}
#+end_src

#+RESULTS:
#+begin_src text :minipage

-----------------------
Quarter 0
Main incremented: (+4, +0)
Left incremented: (+0, +4)
Rotated right:    (+4, +0)

-----------------------
Quarter 1
Main incremented: (+0, +4)
Left incremented: (-4, +0)
Rotated right:    (+0, +4)

-----------------------
Quarter 2
Main incremented: (-4, +0)
Left incremented: (+0, -4)
Rotated right:    (-4, +0)

-----------------------
Quarter 3
Main incremented: (+0, -4)
Left incremented: (+4, +0)
Rotated right:    (+0, -4)
#+end_src

*** Copy constructors and assignment operators

The copy constructor and a copy assignment operator are not generated automatically, presumably because of the union.
The fact that they work regardless of the quarter of both objects is not a problem because the stored coordinates are all relative to quarter 0 anyway.
The goal of the =Quarter= template parameter is to encode behaviour, not state.

#+begin_src cpp :noweb-ref coordinates<Quarter>/public :minipage
template<int OtherQuarter>
coordinates(const coordinates<OtherQuarter>& other):
    x(other.x), y(other.y)
{}

template<int OtherQuarter>
coordinates& operator=(const coordinates<OtherQuarter>& other) {
    __private_x = other.x;
    __private_y = other.y;
    return *this;
}

// Must also be present explicitely, otherwise the compiler conplains of a ambiguous overload
// when Quarter == OtherQuarter.
coordinates& operator=(const coordinates& other) {
    __private_x = other.x;
    __private_y = other.y;
    return *this;
}
#+end_src

*** Exposed API

Similarly to the redirection operator =<<qoord=, the quarter coordinates implemented in the previous sections is exposed to the outside world as =qoords= (=quarter_coordinates= was too long for my taste).
#+name: qoords
#+begin_src cpp :minipage
template<int Quarter>
using qoords = quarter_rotation_details::coordinates<Quarter>;
#+end_src
#+depends:qoords :noweb quarter_rotation_details

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb qoords print <<qoords")>>

int main() {
    qoords<0> a(16, -16);
    print{"Original:        ", a};
    --a.back.y;
    print{"Back decremented:", a};
    a.rotate_left();
    print{"Rotated left:    ", a};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Original:         (+16, -16)
Back decremented: (+16, -15)
Rotated left:     (+15, +16)
#+end_src

*** Rotate quarter from its origin

=from= is a factory function dedicated to construct coordinates of the current =Quarter= from values of another quarter, =OriginQuarter=.
It is just a question of finding the number of rotations required to rotate the result correctly.

#+begin_src cpp :noweb-ref coordinates<Quarter>/public :minipage
template<int OriginQuarter>
static coordinates from(int _x, int _y) {
    coordinates result(_x, _y);
    rotate<rotations_from_to(OriginQuarter, Quarter)>(result);
    return result;
}
#+end_src

In practice, the correct number of rotations is just a substraction ajusted to wrap around:
#+begin_src cpp :noweb-ref coordinates<Quarter>/pre :minipage
constexpr int rotations_from_to(int from_quarter, int to_quarter) {
    int rotations = to_quarter - from_quarter;
    return rotations >= 0 ? rotations : rotations + 4;
}
#+end_src

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb qoords print <<qoords print_type")>>

int main() {
    print_type<qoords<0>>();
    print{qoords<0>::from<1>(4, 8)};
    print{qoords<1>::from<1>(15, 16)};
    print{qoords<2>::from<1>(23, 42)};
    print{qoords<3>::from<1>(108, 6)};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
quarter_rotation_details::coordinates<0>
(+8, -4)
(+15, +16)
(-42, +23)
(-108, -6)
#+end_src

*** =foreach_quarter=

The function presented here is what motivated this whole quarter rotation system in the first place.
By using it, iteration logic can be defined for quarter 0 only and applied to the other quarters by rotation, sparing a lot of implementation headaches.
To be honest only future implementation headaches have been spared because coding this was one hell of a ride.

I tried very hard to make it accept a lambda but in the end I only managed to make it work with a struct providing a =apply= method.
Included with =foreach_quarter= is the templated function =rotate_from=, destined to reduce the ugliness of having to use template disambiguation (the =::template= part).

#+name: foreach_quarter
#+begin_src cpp :minipage
template<int OriginQuarter, typename Coordinates>
auto rotate_from(int x, int y) {
    return Coordinates::template from<OriginQuarter>(x, y);
}

template<class QuarterLogic>
void foreach_quarter(QuarterLogic logic) {
    logic.template apply<qoords<0>>();
    logic.template apply<qoords<1>>();
    logic.template apply<qoords<2>>();
    logic.template apply<qoords<3>>();
}
#+end_src
#+depends:foreach_quarter :noweb qoords

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb foreach_quarter print_size print <<qoords")>>
struct chatty_lambda {
    template<typename Point>
    void apply() {
        print_size<Point>();
        print{rotate_from<0, Point>(-8, 4), "->", rotate_from<0, Point>(-16, 15)};
    }
};

int main() {
    foreach_quarter(chatty_lambda());
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
quarter_rotation_details::coordinates<0> -> 8 bytes (64 bits)
(-8, +4) -> (-16, +15)
quarter_rotation_details::coordinates<1> -> 8 bytes (64 bits)
(-4, -8) -> (-15, -16)
quarter_rotation_details::coordinates<2> -> 8 bytes (64 bits)
(+8, -4) -> (+16, -15)
quarter_rotation_details::coordinates<3> -> 8 bytes (64 bits)
(+4, +8) -> (+15, +16)
#+end_src


** Iteration on coordinates

Iteration on coordinates is not redundant with iteration on points, as can be done by directly iterating on =octasierp='s storage.
Indeed, the =x= and =y= coordinates can be used for other purposes than accessing an =octasierp='s points.

*** Iteration logic for quarter 0

=coordinates_logic= will contain the iteration logic for quarter 0.
#+name: foreach_coordinates_details
#+begin_src cpp :minipage
namespace foreach_coordinates_details {
template<class CoordinatesConsumer>
struct coordinates_logic {
    CoordinatesConsumer coordinates_consumer; // Should perhaps be a reference.
    const int extremum;

    template<typename Coords>
    void apply() {
        <<coordinates_logic/apply>>
    }
};
} // namespace foreach_coordinates_details
#+end_src
#+depends:foreach_coordinates_details :noweb qoords foreach_quarter

The implementation of =apply= is done in two steps, illustrated below:
# Execution disabled because manually modified.
#+begin_src python :eval never :exports results
<<Textual squarified net>>
<<quarter_rep>>
print(SquareNet(2, list(range(3)), quarters={0}, show_axis=True, point_rep=quarter_rep))
#+end_src

#+RESULTS:
#+begin_src text :minipage
   ^
+4 |  +-------+-B-B-B-S
+3 |  |       | B B B |
+2 |  |       | B B B |
+1 |  |       | B B B |
 0 |  +-------X-A-A-A-A
-1 |  |       |       |
-2 |  |       |       |
-3 |  |       |       |
-4 |  +-------+-------+
   +-------------------->
      4 3 2 1 0 1 2 3 4
      - - - -   + + + +
#+end_src
\\
Legend:
 - =A= :: The first step includes the extremum horizontally (the corner).
 - =B= :: The second step does not include the extremum horizontally but goes up to the extremum vertically.
 - =X= :: The north pole is excluded, because this point is specific to quarter 0.
 - =S= :: The south pole is excluded for the same reason.

#+name: coordinates_logic/apply
#+begin_src cpp :minipage
// First step.
auto point = rotate_from<0, Coords>(1, 0);
do {
    coordinates_consumer(point);
} while(++point.main.x <= extremum);
if(extremum == 1) return; // Special case for degree 0.

// Second step.
for(int j = 1; j <= extremum; ++j) {
    point = rotate_from<0, Coords>(1, j);
    do {
        coordinates_consumer(point);
    } while(++point.main.x < extremum);
}
#+end_src

*** Iteration on all quarters by rotation

All that remains to be done for the implementation of =foreach_coordinates= is to use =foreach_quarter= to transpose by rotation the logic defined above, and to include the north and south poles that were left out on purpose.
#+begin_src cpp :noweb-ref octasierp/foreach_coordinates :minipage
template<typename CoordinatesConsumer>
void foreach_coordinates(std::size_t degree, CoordinatesConsumer consumer) {
    using foreach_coordinates_details::coordinates_logic;
    const int extremum = 1 << degree;
    consumer(qoords<0>(0, 0)); // North pole.
    foreach_quarter(coordinates_logic{consumer, extremum});
    consumer(qoords<0>(extremum, extremum)); // South pole.
}
#+end_src
#+depends:octasierp/foreach_coordinates :noweb foreach_coordinates_details qoords foreach_quarter

*** Usage

It can be seen in the results below that the iteration order differs from the storage order.

#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb octasierp octasierp/foreach_coordinates squarenet_shadow print")>>

void illustration(std::size_t degree, const char* representation) {
    auto octa = octasierp(degree, '!');
    std::size_t last = 0;
    foreach_coordinates(degree, [&](const auto& coords) {
        octa[coords] = representation[last++];
    });
    squarenet_shadow(octa.bound(), [&octa](const auto& coords) {
        return octa[coords];
    });
}

int main() {
    const char* representation = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/*-+";
    print{"Degree 0:"};
    illustration(0, representation);

    print{"\nDegree 2:"};
    illustration(2, representation);
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Degree 0:
. . . . .
. . 2 5 .
. 3 0 1 .
. . 4 . .
. . . . .

Degree 2:
. . . . . . . . . . .
. . . . . k e f g + .
. w t q n j b c d . .
. v s p m i 8 9 a . .
. u r o l h 5 6 7 . .
. A z y x 0 1 2 3 4 .
. . D C B N R U X / .
. . G F E O S V Y * .
. . J I H P T W Z - .
. . M L K Q . . . . .
. . . . . . . . . . .
#+end_src


** Iteration on spontaneous coordinates

Spontaneous points are points that have just appeared at a given degree, so where the code from the previous section iterates on all coordinates of degree $\leq d$, this section will focus on coordinates of degree $= d$.

The illustration below shows the spontaneous points for quarter 0 at degree 3:
#+begin_src python :eval no-export :exports results
<<Textual quarter>>
d = 3
print(Quarter(d, list(range(d + 1)), quarter=0, display_points=['0', 'x', '^', '.']))
#+end_src

#+RESULTS:
#+begin_src text :minipage
+-.-^-.-x-.-^-.-0
| . . . . . . . |
| . ^ . ^ . ^ . |
| . . . . . . . |
| . ^ . x . ^ . |
| . . . . . . . |
| . ^ . ^ . ^ . |
| . . . . . . . |
X-.-^-.-x-.-^-.-0
#+end_src
Legend:
 - =X= :: Origin, aka north pole.
 - =0= :: Other points of degree 0.
 - =x= :: Points of degree 1.
 - =^= :: Points of degree 2.
 - =.= :: Spontaneous points of degree 3.

Looking only at quarter 0, spontaneous points can be divided in two categories, even and odd, according to their x coordinate.
For a given odd x coordinate, all valid y coordinate will correspond to a spontaneous point, whereas for even x coordinate, only odd y coordinates will correspond to a spontaneous point.

*** Boilerplate

#+begin_src cpp :noweb-ref octasierp/foreach_spontaneous :minipage
namespace foreach_spontaneous_details {
template<class SpontaneousConsumer>
struct spontaneous_logic {
    SpontaneousConsumer spontaneous_consumer;
    const int extremum;

    template<typename Coords>
    void apply() {
        <<spontaneous_logic/apply>>
    }
};
} // namespace foreach_spontaneous_details
#+end_src

*** Logic

Odd coordinates:
#+begin_src cpp :noweb-ref spontaneous_logic/apply :minipage
for(int i = 1; i < extremum; i += 2) {
    auto point = rotate_from<0, Coords>(i, 0);
    do {
        spontaneous_consumer(point);
    } while(++point.main.y <= extremum);
}
#+end_src

Even coordinates:
#+begin_src cpp :noweb-ref spontaneous_logic/apply :minipage
for(int i = 2; i < extremum; i += 2) {
    auto point = rotate_from<0, Coords>(i, 1);
    do {
        spontaneous_consumer(point);
    } while((point.main.y += 2) < extremum);
}
#+end_src

The logic implemented here will not work for degree 0.

*** Application on all quarters by rotation

Only degree 0 must be hardcoded, the rest can rely on the logic defined above and on =foreach_quarter=.
#+begin_src cpp :noweb-ref octasierp/foreach_spontaneous :minipage
template<class SpontaneousConsumer>
void foreach_spontaneous(std::size_t degree, SpontaneousConsumer consumer) {
    using foreach_spontaneous_details::spontaneous_logic;
    if(degree == 0) {
        consumer(qoords<0>(0, 0)); // North pole.
        consumer(qoords<0>(1, 0)); // Corner 0.
        consumer(qoords<0>(1, 1)); // South pole.
        consumer(qoords<1>(0, 1)); // Corner 1.
        consumer(qoords<2>(-1, 0)); // Corner 2.
        consumer(qoords<3>(0, -1)); // Corner 3.
    }
    foreach_quarter(spontaneous_logic{consumer, 1 << degree});
}
#+end_src
#+depends:octasierp/foreach_spontaneous :noweb qoords foreach_quarter

*** Usage

#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb octasierp octasierp/foreach_spontaneous squarenet_shadow print")>>

void illustration(std::size_t degree, const char* representation) {
    auto octa = octasierp(degree, '/');
    std::size_t last = 0;
    foreach_spontaneous(degree, [&](const auto& coords) {
        octa[coords] = representation[last++];
    });
    squarenet_shadow(octa.bound(), [&octa](const auto& coords) {
        return octa[coords];
    });
}

int main() {
    const char* representation = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/*-+";
    print{"Degree 0:"};
    illustration(0, representation);

    print{"\nDegree 1:"};
    illustration(1, representation);

    print{"\nDegree 2:"};
    illustration(2, representation);
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Degree 0:
. . . . .
. . 3 2 .
. 4 0 1 .
. . 5 . .
. . . . .

Degree 1:
. . . . . . .
. . . / 2 / .
. 5 4 3 1 . .
. / 6 / 0 / .
. . 7 9 a b .
. . 8 / . . .
. . . . . . .

Degree 2:
. . . . . . . . . . .
. . . . . / 4 / 9 / .
. l k j i h 3 b 8 . .
. / n / m / 2 / 7 . .
. g f e d c 1 a 6 . .
. / t / o / 0 / 5 / .
. . u y p A B C D E .
. . v / q / K / L / .
. . w z r F G H I J .
. . x / s / . . . . .
. . . . . . . . . . .
#+end_src


** Iteration on triangles

As with coordinates, iteration on triangles is defined on quarter 0 and then applied by rotation to the other quarters, with the help of =foreach_quarter=.
Triangles are divided in two sets, the safe zone and the right border.

Components of triangles in the safe zone have trivially valid coordinates, even though those coordinates might not belong to the current quarter (the points on the left border for quarter 0).

Components of triangles in the right border are more tricky because the rightmost coordinates are not valid, the valid coordinates are the mirrored ones (the points on the right of quarter 3 for quarter 0).

Here is an illustration of this division between safe zone and right border for quarter 0, at degree 2:
# Disabled because customised.
#+begin_src python :eval never :exports results
<<Textual squarified net>>
<<quarter_rep>>
print(SquareNet(2, list(range(3)), quarters={0}, show_axis=True, point_rep=quarter_rep))
#+end_src

#+RESULTS:
#+begin_src text :minipage
   ^
+4 |  +-------S-S-S-B-R
+3 |  |       S S S B /
+2 |  |       S S S B /
+1 |  |       S S S B /
 0 |  +-------S-S-S-B-R
-1 |  |       |       R
-2 |  |       |       R
-3 |  |       |       R
-4 |  +-------+-------+
   +-------------------->
      4 3 2 1 0 1 2 3 4
      - - - -   + + + +
#+end_src
\\
Legend:
 - =S= :: Safe zone.
 - =B= :: Buffer zone (points appearing both in safe triangles and in right border triangles).
 - =R= :: Right border (note that the south pole is special because it appears four times and must not be rotated).
 - =/= :: Mirrored points.

*** High level overview

The iteration logic is hidden in its own namespace, with =triangle_logic= corresponding here to =foreach_quarter='s =QuarterLogic=.
The =safe= int is the last index that can only refer to a canonical point.
In the previous illustration, this is the x value of the buffer zone.

#+begin_src cpp :noweb-ref octasierp/foreach_triangle :minipage
namespace foreach_triangle_details {
template<class TriangleConsumer>
struct triangle_logic {
    TriangleConsumer triangle_consumer;
    // Last index that can only refer to a canonical point.
    const int safe;

    template<typename Coords>
    void apply() {
        <<triangle_logic/apply/safe_zone>>
        <<triangle_logic/apply/right_border>>
    }
}; // struct triangle_logic
} // namespace foreach_triangle_details
#+end_src

The proper function delegates the work to =triangle_logic= and =foreach_quarter=, except for degree 0, which had to be hardcoded:
#+begin_src cpp :noweb-ref octasierp/foreach_triangle :minipage
template<typename TriangleConsumer>
void foreach_triangle(std::size_t degree, TriangleConsumer consumer) {
    using foreach_triangle_details::triangle_logic;
    if(degree == 0) {
        consumer(qoords<0>(0, 0), qoords<0>(1, 0), qoords<0>(0, 1));
        consumer(qoords<0>(1, 0), qoords<0>(1, 1), qoords<0>(0, 1));

        consumer(qoords<1>(0, 0), qoords<1>(0, 1), qoords<1>(-1, 0));
        consumer(qoords<1>(0, 1), qoords<1>(1, 1), qoords<1>(-1, 0));

        consumer(qoords<2>(0, 0), qoords<2>(-1, 0), qoords<2>(0, -1));
        consumer(qoords<2>(-1, 0), qoords<2>(1, 1), qoords<2>(0, -1));

        consumer(qoords<3>(0, 0), qoords<3>(0, -1), qoords<3>(1, 0));
        consumer(qoords<3>(0, -1), qoords<3>(1, 1), qoords<3>(1, 0));
        return;
    }
    foreach_quarter(triangle_logic{
        consumer,
        (1 << degree) - 1
    });
}
#+end_src
#+depends:octasierp/foreach_triangle :noweb qoords foreach_quarter

*** Safe zone

The first twelve iterations on quarter 0 at degree 2 are illustrated below, the points are all ordered in the same counterclockwise manner.
This will be useful later on because it is a way to encode the direction of the normal.
#+name: QuarterSequence
#+begin_src python :exports none
<<Textual squarified net>>

class QuarterSequence:
    def __init__(self, degree, separator=' -> '):
        self.degree = degree
        self.separator = separator
        self.lines = Quarter(
            self.degree,
            list(range(self.degree + 1)),
            display_points='.'
        ).repr()
        self.next_step = 1
        self.spacing = 2 ** (self.degree + 1) + len(self.separator) + 1

    def print_n(self, n, legend=False):
        if legend:
            legend_str = ''
            for i in range(n):
                step = '{}.'.format(self.next_step + i)
                legend_str += step
                if i < n - 1:
                    legend_str += ' ' * (self.spacing - len(step))
            self.next_step += n
            print(legend_str)

        for linum, line in enumerate(self.lines):
            sep = self.separator if linum == 2 ** (self.degree - 1) else ' ' * len(self.separator)
            print(sep.join([line] * n))
#+end_src

# Execution disabled because manual tweaking.
#+begin_src python :eval never :exports results
<<QuarterSequence>>
printer = QuarterSequence(2)
printer.print_n(6, legend=True)
print()
printer.print_n(6, legend=True)
#+end_src

#+begin_src text :minipage
1.           2.           3.           4.           5.           6.
+-.-.-.-.    +-.-.-.-.    +-.-.-.-.    +-.-.-.-.    +-.-.-.-.    +-.-.-.-.
| . . . |    | . . . |    | . . . |    | . . . |    | . . . |    | . . . |
| . . . | -> | . . . | -> | . . . | -> | . . . | -> | . . . | -> | . . . |
c . . . |    c b . . |    | c . . |    | c b . |    | . c . |    | . c b |
A-b-.-.-.    X-a-.-.-.    X-a-b-.-.    X-.-a-.-.    X-.-a-b-.    X-.-.-a-.

7.           8.           9.           10.          11.          12.
+-.-.-.-.    +-.-.-.-.    +-.-.-.-.    +-.-.-.-.    +-.-.-.-.    +-.-.-.-.
| . . . |    | . . . |    | . . . |    | . . . |    | . . . |    | . . . |
c . . . | -> c b . . | -> | c . . | -> | c b . | -> | . c . | -> | . c b |
a b . . |    | a . . |    | a b . |    | . a . |    | . a b |    | . . a |
X-.-.-.-.    X-.-.-.-.    X-.-.-.-.    X-.-.-.-.    X-.-.-.-.    X-.-.-.-.
#+end_src
\\
Legend:
 - =X= :: North pole.
 - =A, a, b, c= :: Points of the triangle.
 - =.= :: Other points of quarter 0.
\\

This progression in implemented in the following code block:
#+name: triangle_logic/apply/safe_zone
#+begin_src cpp :minipage
for(int j = 0; j <= safe; ++j) {
    auto a = rotate_from<0, Coords>(0, j);
    auto b = rotate_from<0, Coords>(1, j);
    auto c = rotate_from<0, Coords>(0, j + 1);
    while(true) {
        triangle_consumer(a, b, c);
        ++a.main.x;
        ++b.main.y;
        triangle_consumer(a, b, c);
        if(++c.main.x >= safe) // Since c is leftmost, if it is safe, at least one of the other are not.
            break;
        // a is already at the correct position, only b must be repositioned.
        ++b.main.x;
        --b.main.y;
    }
}
#+end_src

Each iteration of the for loop corresponds to a line in the illustration above.
The iterations continue until the very top of quarter 0.
Still using the example of quarter 0 at degree 2, here is the last triangle represented by the code above:

#+begin_src text :minipage
24.
+-.-c-b-.
| . . a |
| . . . |
| . . . |
X-.-.-.-.
#+end_src

*** Right border

Because of the fact that points on the right border do not belong to the current quarter, the iteration logic is separated in two lines, the left one handling the points of the buffer zone and the right one handling the points on the right border.

Here are all the points handled in this section for quarter 0, at degree 2:
# Disabled because customised.
#+begin_src python :eval never :exports results
<<QuarterSequence>>
printer = QuarterSequence(2)
printer.print_n(4, legend=True)
#+end_src

#+begin_src text :minipage
1.           2.           3.           4.
+-.-.-.-.    +-.-.-.-.    +-.-.-.-.    +-.-.-c-S
| . . . |    | . . . |    | . . c D    | . . a B
| . . . | -> | . . c D -> | . . a B -> | . . . |
| . . c D    | . . a B    | . . . |    | . . . |
X-.-.-a-z    X-.-.-.-.    X-.-.-.-.    X-.-.-.-.
#+end_src
\\
Legend:
 - =X= :: North pole.
 - =a= :: Bottom left point (always belongs to quarter 0).
 - =z= :: Initial bottom right point (corner 0, belongs to quarter 0).
 - =B= :: Other bottom right point (mirrored point, belongs to quarter 3).
 - =c= :: Top left point (always belongs to quarter 0).
 - =S= :: Final top right point (south pole, belongs to quarter 0).
 - =D= :: Other top right point (mirrored point, belongs to quarter 3).

Since the bottom right and top right points are actually on the quarter to the right of the current one, the =x= axis of their =right= point is the one being incremented instead of the =y= axis of their =main= point.
#+name: triangle_logic/apply/right_border
#+begin_src cpp :minipage
auto bottom_left  = rotate_from<0, Coords>(safe, 0);
auto bottom_right = rotate_from<0, Coords>(safe + 1, 0);
auto top_left     = rotate_from<0, Coords>(safe, 1);
auto top_right    = rotate_from<0, Coords>(safe + 1, -1);
while(true) {
    triangle_consumer(bottom_left, bottom_right, top_left);
    triangle_consumer(bottom_right, top_right, top_left);
    ++bottom_left.main.y;
    ++bottom_right.right.x;
    if(++top_left.main.y > safe)
        break;
    ++top_right.right.x;
}

// All points are correct for the last square, except the top right one, aka the south pole.
// This point is only valid for quarter 0, and must therefore not be rotated.
top_right = Coords(safe + 1, safe + 1);
triangle_consumer(bottom_left, bottom_right, top_left);
triangle_consumer(bottom_right, top_right, top_left);
#+end_src

*** Triangle cardinality

Looking once again at the squarified net visualisation above, we can see the following patterns:
 - All quarters have the same numbers of triangles ($\vert triangles_{total} \vert = 4 \times \vert triangles_{quarter_0} \vert$).
 - Triangles can be neatly arranged to form squares, with two triangles by square ($\vert triangles_{quarter_0} \vert = 2 \times \vert squares_{quarter_0} \vert$).
 - The number of those squares quadruples with each degree ($\vert squares_{quarter_0} \vert = 2^{2d}$, with $d$ being the degree).

From this, the number of triangles can be deduced to be $\vert triangles_{total} \vert = 8 \times 2^{2d} = 2^{2d + 3}$.

#+begin_src cpp :noweb-ref pointless_octasierp/public :minipage
std::size_t triangle_cardinality() const {
    return 1 << (2 * degree + 3);
}
#+end_src

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb pointless_octasierp out")>>

int main() {
    for(std::size_t degree = 0; degree < 4; ++degree) {
        pointless_octasierp octa(degree);
        out(
            "Triangle cardinality at degree ", degree, ": ",
            octa.triangle_cardinality(), '\n'
        );
    }
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Triangle cardinality at degree 0: 8
Triangle cardinality at degree 1: 32
Triangle cardinality at degree 2: 128
Triangle cardinality at degree 3: 512
#+end_src

*** Usage

The code below prints two squarenet shadows using octasierps constructed with the help of =foreach_triangle=.
The first octasierp (=order=) illustrate the order in which the points are first used as part of a triangle, while the second one (=counter=) illustrate the number of times a point is used as part of a triangle.
#+name: triangles_order_counter_shadow
#+begin_src cpp
void triangles_order_counter_shadow(std::size_t degree, const char* representation) {
    octasierp order(degree, ';');
    int last_repr = 0;
    int triangle_cardinality = 0;
    octasierp counter(degree, 0);

    foreach_triangle(degree, [&](const auto& a, const auto& b, const auto& c) {
        ++triangle_cardinality;
        for(const auto& coords: {a, b, c}) {
            if(order.bound().valid_coordinates(coords.x, coords.y)) {
                ++counter[coords];
                auto& point = order[coords];
                if(point == ';') {
                    point = representation[last_repr++];
                }
            } else {
                print{"Received invalid coordinate:", coords};
                print{"Triangle is", a, b, c};
            }
        }
    });

    print{
        order.bound().triangle_cardinality(), "triangles in theory",
        triangle_cardinality, "triangles in practice\n"
    };

    print{"Order:"};
    squarenet_shadow(order.bound(), [&order](const auto& coords) {
        return order[coords];
    });
    print{};
    print{"Counter:"};
    squarenet_shadow(counter.bound(), [&counter](const auto& coords) {
        switch(counter[coords]) {
          case 4:  return '4';
          case 6:  return '6';
          default: return 'E'; // Error.
        }
    });
}
#+end_src
#+depends:triangles_order_counter_shadow :noweb octasierp octasierp/foreach_triangle print <<qoords squarenet_shadow

**** Degree 0

#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb triangles_order_counter_shadow")>>

int main() {
    triangles_order_counter_shadow(0, "012345");
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
8 triangles in theory 8 triangles in practice

Order:
. . . . .
. . 2 3 .
. 4 0 1 .
. . 5 . .
. . . . .

Counter:
. . . . .
. . 4 4 .
. 4 4 4 .
. . 4 . .
. . . . .
#+end_src
\\

**** Degree 1

#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb triangles_order_counter_shadow")>>

int main() {
    triangles_order_counter_shadow(1, "0123456789abcdefgh");
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
32 triangles in theory 32 triangles in practice

Order:
. . . . . . .
. . . 4 5 8 .
. c a 2 3 . .
. b 9 0 1 6 .
. . e d h 7 .
. . g f . . .
. . . . . . .

Counter:
. . . . . . .
. . . 4 6 4 .
. 6 6 6 6 . .
. 4 6 4 6 4 .
. . 6 6 6 6 .
. . 6 4 . . .
. . . . . . .
#+end_src
\\

**** Degree 2

#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb triangles_order_counter_shadow")>>

int main() {
    triangles_order_counter_shadow(2, "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/*-+");
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
128 triangles in theory 128 triangles in practice

Order:
. . . . . . . . . . .
. . . . . g h i j o .
. E A w s c d e f . .
. D z v r 8 9 a b . .
. C y u q 2 3 5 7 . .
. B x t p 0 1 4 6 k .
. . I H G F V Y * l .
. . M L K J W Z - m .
. . Q P O N X / + n .
. . U T S R . . . . .
. . . . . . . . . . .

Counter:
. . . . . . . . . . .
. . . . . 4 6 6 6 4 .
. 6 6 6 6 6 6 6 6 . .
. 6 6 6 6 6 6 6 6 . .
. 6 6 6 6 6 6 6 6 . .
. 4 6 6 6 4 6 6 6 4 .
. . 6 6 6 6 6 6 6 6 .
. . 6 6 6 6 6 6 6 6 .
. . 6 6 6 6 6 6 6 6 .
. . 6 6 6 4 . . . . .
. . . . . . . . . . .
#+end_src
\\
Some observations:
 - The =k=, =l=, =m= and =n= points bear witness to the mirrored nature of the right border for quarter 0.
 - All points are part of six triangles, except the six initial points who belong to only four triangles.
   This is the expected result, as can be seen by looking at the visualisation of the squarified nets for degrees 0, 1 2 and 3 (included below).

#+attr_latex: :placement [H]
[[file:images/montage_net_squa_degree_0-3.png]]


** Iteration on segments

This section is heavily based on the iteration on triangles, with a few adjustements to filter out redundant segments.

#+begin_src cpp :noweb-ref octasierp/foreach_segment :minipage
namespace foreach_segment_details {
template<class SegmentConsumer>
struct segment_logic {
    SegmentConsumer segment_consumer;
    // Last index that can only refer to a canonical point.
    int safe;

    template<typename Coords>
    void apply()  {
        <<segment_logic/apply/safe_zone>>
        <<segment_logic/apply/borders>>
    }
}; // struct segment_logic
} // namespace foreach_segment_details
#+end_src

As with =foreach_triangle=, degree 0 is hardcoded.
#+begin_src cpp :noweb-ref octasierp/foreach_segment :minipage
template<typename SegmentConsumer>
void foreach_segment(std::size_t degree, SegmentConsumer consumer) {
    using foreach_segment_details::segment_logic;
    if(degree == 0) {
        consumer(qoords<0>(0, 0), qoords<0>(1, 0));
        consumer(qoords<0>(0, 1), qoords<0>(1, 0));
        consumer(qoords<0>(0, 1), qoords<0>(1, 1));

        consumer(qoords<1>(0, 0), qoords<1>(0, 1));
        consumer(qoords<1>(-1, 0), qoords<1>(0, 1));
        consumer(qoords<1>(-1, 0), qoords<1>(1, 1));

        consumer(qoords<2>(0, 0), qoords<2>(-1, 0));
        consumer(qoords<2>(0, -1), qoords<2>(-1, 0));
        consumer(qoords<2>(0, -1), qoords<2>(1, 1));

        consumer(qoords<3>(0, 0), qoords<3>(0, -1));
        consumer(qoords<3>(1, 0), qoords<3>(0, -1));
        consumer(qoords<3>(1, 0), qoords<3>(1, 1));
        return;
    }

    foreach_quarter(segment_logic{
        consumer,
        (1 << degree) - 1
    });
}
#+end_src
#+depends:octasierp/foreach_segment :noweb qoords foreach_quarter

*** Safe zone

The segments in the safe zone are handled in batches of three, as can be seen in the following illustration for quarter 0 at degree 2:
# Execution disabled because manual tweaking.
#+begin_src python :eval never :exports results
<<QuarterSequence>>
printer = QuarterSequence(2)
printer.print_n(6, legend=True)
print()
printer.print_n(6, legend=True)
#+end_src


#+begin_src text :minipage

1.           2.           3.           4.           5.           6.
+-.-.-.-.    +-.-.-.-.    +-.-.-.-.    +-.-.-.-.    +-.-.-.-.    +-.-.-.-.
| . . . |    | . . . |    | . . . |    | . . . |    | . . . |    | . . . |
| . . . | -> | . . . | -> | . . . | -> | . . . | -> | . . . | -> | . . . |
| . . . |    a . . . |    | a . . |    | . . . |    | a . . |    | . a . |
A-b-.-.-.    X-b-.-.-.    X-b-.-.-.    X-a-b-.-.    X-.-b-.-.    X-.-b-.-.

7.           8.           9.           10.          11.          12.
+-.-.-.-.    +-.-.-.-.    +-.-.-.-.    +-.-.-.-.    +-.-.-.-.    +-.-.-.-.
| . . . |    | . . . |    | . . . |    | . . . |    | . . . |    | . . . |
| . . . | -> | . . . | -> | . . . | -> | . . . | -> a . . . | -> | a . . |
| . . . |    | . a . |    | . . a |    a b . . |    | b . . |    | b . . |
X-.-a-b-.    X-.-.-b-.    X-.-.-b-.    X-.-.-.-.    X-.-.-.-.    X-.-.-.-.
#+end_src
\\
Legend:
 - =X= :: North pole.
 - =A, a, b= :: Points of the segment.
 - =.= :: Other points of quarter 0.
\\

Note that =a= is systematically to the left and/or above =b=.
This property is respected for all segments, and will be useful later on.

#+name: segment_logic/apply/safe_zone
#+begin_src cpp :minipage
for(int j = 0; j <= safe; ++j) {
    auto a = rotate_from<0, Coords>(0, j);
    auto b = rotate_from<0, Coords>(1, j);
    while(true) {
        segment_consumer(a, b);
        ++a.main.y;
        segment_consumer(a, b);
        ++a.main.x;
        segment_consumer(a, b);
        if(*a.main.x >= safe)
            break;
        --a.main.y;
        ++b.main.x;
    }
}
#+end_src

*** Top border

This section handles the points at the top of quarter 0, south pole included.
# Execution disabled because manual tweaking.
#+begin_src python :eval never :exports results
<<QuarterSequence>>
printer = QuarterSequence(2)
printer.print_n(4, legend=True)
#+end_src


#+begin_src text :minipage
1.           2.           3.           4.
a-b-.-.-S    +-a-b-.-S    +-.-a-b-S    +-.-.-a-B
| . . . |    | . . . |    | . . . |    | . . . |
| . . . | -> | . . . | -> | . . . | -> | . . . |
| . . . |    | . . . |    | . . . |    | . . . |
X-.-.-.-.    X-.-.-.-.    X-.-.-.-.    X-.-.-.-.
#+end_src
\\
Legend:
 - =X= :: North pole.
 - =S= :: South pole.
 - =a, b, B= :: Points of the segment.
 - =.= :: Other points of quarter 0.
\\

Note that the representation above is exhaustive for quarter 0 at degree 2.

#+begin_src cpp :noweb-ref segment_logic/apply/borders :minipage
auto a = rotate_from<0, Coords>(0, safe + 1);
auto b = rotate_from<0, Coords>(1, safe + 1);
while(true) {
    segment_consumer(a, b);
    if(++a.main.x >= safe)
        break;
    ++b.main.x;
}
// South pole.
b = Coords(safe + 1, safe + 1);
segment_consumer(a, b);
#+end_src

*** Right border

The right border is handled like the safe zone, except that the vertical segment is not included since it belongs to quarter 3 (or its rotated equivalent).
# Execution disabled because manual tweaking.
#+begin_src python :eval never :exports results
<<QuarterSequence>>
printer = QuarterSequence(2)
printer.print_n(4, legend=True)
print()
printer.print_n(4, legend=True)
#+end_src


#+begin_src text :minipage
1.           2.           3.           4.
+-.-.-.-S    +-.-.-.-S    +-.-.-.-S    +-.-.-.-S
| . . . |    | . . . |    | . . . |    | . . . |
| . . . | -> | . . . | -> | . . . | -> | . . a |
| . . . |    | . . a |    | . . a b    | . . . b
X-.-.-a b    X-.-.-.-b    X-.-.-.-.    X-.-.-.-.

5.           6.           7.           8.
+-.-.-.-S    +-.-.-.-S    +-.-.-.-S    +-.-.-a-S
| . . . |    | . . a |    | . . a b    | . . . b
| . . a b -> | . . . b -> | . . . | -> | . . . |
| . . . |    | . . . |    | . . . |    | . . . |
X-.-.-.-.    X-.-.-.-.    X-.-.-.-.    X-.-.-.-.
#+end_src
\\
Legend:
 - =X= :: North pole.
 - =S= :: South pole.
 - =a, b, B= :: Points of the segment.
 - =.= :: Other points of quarter 0.
\\

Once again, the representation above is exhaustive for quarter 0 at degree 2.
Another important thing to observe is that only =b= is located on the border, =a= is always a canonical point.

#+begin_src cpp :noweb-ref segment_logic/apply/borders :minipage
a = rotate_from<0, Coords>(safe, 0);
b = rotate_from<0, Coords>(safe + 1, 0);
while(true) {
    segment_consumer(a, b);
    ++a.main.y;
    segment_consumer(a, b);
    if(*a.main.y > safe)
        break;
    ++b.right.x; // This is mirrored logic.
}
#+end_src

*** Segment cardinality

I can't really explain the segment cardinality right now, the logic with which it was deduced escapes me now.
A path of reflection is the fact that the number of new points at degree $d$ is equal to the number of segments at degree $d - 1$, since new points appear in the middle of segments.

#+begin_src cpp :noweb-ref pointless_octasierp/public :minipage
std::size_t segment_cardinality() const {
    return 3 << (2 * degree + 1) << 1;
}
#+end_src

*** Usage

#+begin_src cpp :eval no-export :exports both
<<include(":noweb octasierp print qoords <<qoords octasierp/foreach_segment squarenet_shadow")>>

int main() {
    octasierp segments(2, '0');
    int segment_cardinality = 0;
    foreach_segment(segments.degree(), [&](const auto& a, const auto& b) {
        ++segments[a]; ++segments[b];
        ++segment_cardinality;
    });
    print{
        segments.bound().segment_cardinality(), "segments in theory",
        segment_cardinality, "segments in practice\n"
    };
    squarenet_shadow(segments.degree(), [&](const auto& coords) {
        return segments[coords];
    });
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
192 segments in theory 192 segments in practice

. . . . . . . . . . .
. . . . . 4 6 6 6 4 .
. 6 6 6 6 6 6 6 6 . .
. 6 6 6 6 6 6 6 6 . .
. 6 6 6 6 6 6 6 6 . .
. 4 6 6 6 4 6 6 6 4 .
. . 6 6 6 6 6 6 6 6 .
. . 6 6 6 6 6 6 6 6 .
. . 6 6 6 6 6 6 6 6 .
. . 6 6 6 4 . . . . .
. . . . . . . . . . .
#+end_src

Those results are echoing the ones obtained with =foreach_triangle=.
Intuitively, that is because the squarenet shadow above represents the number of neighbours of each point.


** Mirrored points

The goal of this section is to offer tools to manipulate mirrored points, first to detect them and then to unmirror them.
In the illustration below, for quarter 0 at degree 2, the mirror points to detect would be those represented by =\=, and they should be reverted to their =/= equivalents.

# Disabled because customised.
#+begin_src python :eval never :exports results
<<Textual squarified net>>
<<quarter_rep>>
print(SquareNet(2, list(range(3)), show_axis=True, point_rep=lambda q: ['a', '0'] if q == 0 else ['x']))
#+end_src

#+begin_src text :minipage
   ^
+4 |  +-------x-0-0-0-a
+3 |  x x x x x 0 0 0 /
+2 |  x x x x x 0 0 0 /
+1 |  x x x x x 0 0 0 /
 0 |  x-x-x-x-X-0-0-0-a
-1 |  | x x x x x x x \
-2 |  | x x x x x x x \
-3 |  | x x x x x x x \
-4 |  +-x-x-x-x-------+
   +-------------------->
      4 3 2 1 0 1 2 3 4
      - - - -   + + + +
#+end_src
\\
Legend:
 - =X= :: North pole.
 - =a= :: Other points of quarter 0 and degree 0.
 - =/= :: Non canonical mirrored points of quarter 0.
 - =\= :: Canonical version of those mirrored points, belonging to quarter 3.
 - =x= :: Other canonical points.

The non canonical points are not valid coordinates and should therefore be handled with care.

*** Canonical mirrored predicate

The public facing predicates in =coordinates= requires the degree to compute the extremum value that is mandatory to detect if a set of coordinates is mirrored.
#+begin_src cpp :noweb-ref coordinates<Quarter>/public :minipage
bool is_mirrored_canonical(int degree) const {
    return is_mirrored_canonical_impl(*this, 1 << degree);
}
#+end_src

The implementation is fairly straightforward with the help of the illustration above, with the exception of the south pole who is always mirrored for quarters 1, 2 and 3.
#+begin_src cpp :noweb-ref quarter_rotation_details/public :minipage
template<int Quarter>
bool is_mirrored_canonical_impl(const coordinates<Quarter>& coords, int extremum);

template<>
bool is_mirrored_canonical_impl<0>(const coordinates<0>& coords, int extremum) {
    return coords.x == extremum && coords.y < 0;
}
template<>
bool is_mirrored_canonical_impl<1>(const coordinates<1>& coords, int extremum) {
    return coords.y == extremum && coords.x > 0;
}
template<>
bool is_mirrored_canonical_impl<2>(const coordinates<2>& coords, int extremum) {
    return (coords.x == -extremum || coords.x == extremum) && coords.y > 0;
}
template<>
bool is_mirrored_canonical_impl<3>(const coordinates<3>& coords, int extremum) {
    return (coords.y == -extremum && coords.x < 0)
        || (coords.x == extremum && coords.y == extremum);
}
#+end_src

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb octasierp octasierp/foreach_triangle squarenet_shadow out")>>

int main() {
    for(int degree = 0; degree <= 2; ++degree) {
        octasierp octa(degree, '#');
        auto count_mirrored = [&octa, degree](const auto& a, const auto& b, const auto& c) {
            for(const auto& coords: {a, b, c}) {
                if(coords.is_mirrored_canonical(degree)) {
                    auto& point = octa[coords];
                    if(point == '#') point = '1';
                    else ++point;
                }
            }
        };

        foreach_triangle(degree, count_mirrored);
        out("Degree ", degree, ":\n");
        squarenet_shadow(octa.bound(), [&octa](auto coords) {
            return octa[coords];
        });
        out('\n');
    }
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Degree 0:
. . . . .
. . # 3 .
. # # # .
. . # . .
. . . . .

Degree 1:
. . . . . . .
. . . # 3 3 .
. 3 # # # . .
. # # # # # .
. . # # # 3 .
. . 3 # . . .
. . . . . . .

Degree 2:
. . . . . . . . . . .
. . . . . # 3 3 3 3 .
. 3 # # # # # # # . .
. 3 # # # # # # # . .
. 3 # # # # # # # . .
. # # # # # # # # # .
. . # # # # # # # 3 .
. . # # # # # # # 3 .
. . # # # # # # # 3 .
. . 3 3 3 # . . . . .
. . . . . . . . . . .

#+end_src

*** Unmirror

The name =unmirror= was chosen for the following reasons:
 - It implies a change to the object whereas =mirror= could as well be a predicate.
 - Since canonical points are used most of the time anyway, this operation will typically be used after a =is_mirrored= test, making it more natural to =unmirror=.

As usual, it is written as a public method relying on an external helper:
#+begin_src cpp :noweb-ref coordinates<Quarter>/public :minipage
coordinates& unmirror() {
    return unmirror_impl(*this);
}
#+end_src

The implementation consists of two things:
 1. Handling the south pole by rotating by the correct amount.
 2. Handling the other points by mirroring the right axis.

#+begin_src cpp :noweb-ref quarter_rotation_details/public
template<int Quarter>
coordinates<Quarter>& unmirror_impl(coordinates<Quarter>& coords);

template<> coordinates<0>& unmirror_impl<0>(coordinates<0>& coords) {
    coords.mirror_y(); return coords;
}
template<> coordinates<1>& unmirror_impl<1>(coordinates<1>& coords) {
    if(coords.x == coords.y && coords.x > 0)
        coords.rotate_left();
    else
        coords.mirror_x();
    return coords;
}
template<> coordinates<2>& unmirror_impl<2>(coordinates<2>& coords) {
    if(coords.x > 0 && coords.y > 0)
        coords.rotate_back();
    else
        coords.mirror_y();
    return coords;
}
template<> coordinates<3>& unmirror_impl<3>(coordinates<3>& coords) {
    if(coords.x > 0 && coords.y > 0)
        coords.rotate_right();
    else
        coords.mirror_x();
    return coords;
}
#+end_src

At first I thought that calling =unmirror= twice would leave the object in the same state as it was before, but the south pole required special attention so in the end that is not the case.
This operation must therefore be used carefully.

*** Iteration on *every* coordinates

=forevery_coordinates= is similar to =foreach_coordinates=, except that it also includes mirrored points, as illustrated below for quarter 0 at degree 2.

# Execution disabled because manually modified.
#+begin_src python :eval never :exports results
<<Textual squarified net>>
<<quarter_rep>>
print(SquareNet(2, list(range(3)), quarters={0}, show_axis=True, point_rep=quarter_rep))
#+end_src

#+RESULTS:
#+begin_src text :minipage
   ^
+4 |  +-------+-B-B-B-S
+3 |  |       | B B B /
+2 |  |       | B B B /
+1 |  |       | B B B /
 0 |  +-------X-A-A-A-A
-1 |  |       |       \
-2 |  |       |       \
-3 |  |       |       \
-4 |  +-------+-------+
   +-------------------->
      4 3 2 1 0 1 2 3 4
      - - - -   + + + +
#+end_src
\\
Legend:
 - =A= :: =foreach='s first step.
 - =B= :: =foreach='s second step.
 - =/= :: =forevery='s only step, aka the third step (non canonical mirrored points).
 - =\= :: Canonical version of those mirrored points, technically belonging to quarter 3.
 - =X= :: The north pole is excluded, because this point is specific to quarter 0.
 - =S= :: The south pole is excluded for the same reason.


=coordinates_logic/apply= from =foreach_coordinates= will be reused to implement the bulk of the iteration logic, the only logic specific to the =forevery= version is that of the the mirrored/redundant points (=/=):
#+begin_src cpp :noweb-ref octasierp/forevery_coordinates :minipage
namespace redundant_coordinates_details {
template<class CoordinatesConsumer>
struct coordinates_logic {
    CoordinatesConsumer coordinates_consumer; // Should perhaps be a reference (still).
    const int extremum;

    template<typename Coords>
    void apply() {
        auto point = rotate_from<0, Coords>(extremum, -1);
        do {
            coordinates_consumer(point);
        } while(++point.right.x < extremum); // This is mirrored logic.
    }
};
template<class T> using canonical_logic = foreach_coordinates_details::coordinates_logic<T>;
template<class T> using redundant_logic = coordinates_logic<T>;
} // namespace redundant_coordinates_details
#+end_src

Implementation of the proper function:
#+begin_src cpp :noweb-ref octasierp/forevery_coordinates :minipage
template<typename CoordinatesConsumer>
void forevery_coordinates(std::size_t degree, CoordinatesConsumer consumer) {
    using namespace redundant_coordinates_details;
    const int extremum = 1 << degree;

    // The canonical points are handled first.
    consumer(qoords<0>(0, 0)); // North pole.
    foreach_quarter(canonical_logic{consumer, extremum});
    consumer(qoords<0>(extremum, extremum)); // Canonical south pole.

    // Then the redundant points.
    foreach_quarter(redundant_logic{consumer, extremum});
    consumer(qoords<1>(extremum, extremum)); // Degree 1 mirrored south pole.
    consumer(qoords<2>(extremum, extremum)); // Degree 2 mirrored south pole.
    consumer(qoords<3>(extremum, extremum)); // Degree 3 mirrored south pole.
}
#+end_src
#+depends:octasierp/forevery_coordinates :noweb foreach_coordinates_details qoords foreach_quarter

The mirrored south poles are very confusing because, since =forevery_coordinates= produces canonical coordinates only, it is the mirrored version that must be produced, i.e. the version of the quarter to the left.

Redundant points are consumed after canonical points because the handling of the firsts can depend on that of the seconds.

*** Usage

=illustration= contains a kind of ad hoc reimplementation of =squarenet_shadow=
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb pointless_octasierp octasierp/forevery_coordinates out print :cpp vector")>>

void illustration(std::size_t degree, const char* representation) {
    auto octa = pointless_octasierp(degree);
    std::size_t side = (1 << (degree + 1)) + 1;
    std::vector<char> points(side * side, '!');
    std::size_t last = 0;

    forevery_coordinates(degree, [&](auto coords) {
        char repr;
        if(coords.is_mirrored_canonical(degree)) {
            repr = '_';
            coords.unmirror(); // Necessary because this is the canonical coordinates,
                               // from the right quarter.
        } else
            repr = representation[last++];
        int index = -(coords.y - octa.extreme_index) * side + coords.x + octa.extreme_index;
        points[index] = repr;
    });
    for(std::size_t j = 0; j < side; ++j) {
        for(std::size_t i = 0; i < side; ++i)
            out(' ', points[j * side + i]);
        print{};
    }
}

int main() {
    const char* representation = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/*-+";
    print{"Degree 0:"};
    illustration(0, representation);

    print{"\nDegree 2:"};
    illustration(2, representation);
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Degree 0:
 _ 2 5
 3 0 1
 _ 4 _

Degree 2:
 _ _ _ _ k e f g +
 w t q n j b c d _
 v s p m i 8 9 a _
 u r o l h 5 6 7 _
 A z y x 0 1 2 3 4
 _ D C B N R U X /
 _ G F E O S V Y *
 _ J I H P T W Z -
 _ M L K Q _ _ _ _
#+end_src


** Foreach adapters

This section contains helpers dedicated to adapting the behaviour of the foreach loops operating on octasierp coordinates.

*** Degree shifter

This utility's goal is to adapt foreach loops to higher degrees.
With it, the coordinates transmitted to a given consumer can be shifted by a number of degrees, making it possible to, say, iterate on all points of degree $\leq 2$ but with the coordinates those points would have at degree 4.

First, support for scalar multiplication of coordinates is needed:
#+begin_src cpp :noweb-ref coordinates<Quarter>/public :minipage
coordinates& operator*=(int n) {
    __private_x *= n;
    __private_y *= n;
    return *this;
}
#+end_src
\\

The code below adds =_shift= degrees to each coordinates transmitted to the given consumer.
In practice, this is simply a multiplication by $2^{\_shift}$.
This can be explained by the fact that each new subdivision degree adds a new point between each pre-existing one, thereby doubling the value of the =x= and =y= components.
#+name: degree_shifter
#+begin_src cpp :minipage
template<class Consumer>
struct degree_shifter {
    int shift;
    Consumer consumer;
    degree_shifter(int _shift, Consumer _consumer):
        shift(1 << _shift), consumer(_consumer)
    {}

    template<class... Coordinates>
    void operator()(Coordinates... coords) {
        shift_it(coords...);
        consumer(coords...);
    }

    void shift_it() const {}
    template<class Head, class... Tail>
    void shift_it(Head& head, Tail&... tail) {
        head *= shift;
        shift_it(tail...);
    }
};
#+end_src

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb degree_shifter octasierp/foreach_coordinates qoords <<qoords out")>>

int main() {
    auto print_coordinates = [](const auto& coords) {
        out(" ", coords, ';');
    };
    for(std::size_t shift = 0; shift < 3; ++shift) {
        out("\n\nCoordinates of degree 0 in an octasierp of degree ", shift, ":\n");
        foreach_coordinates(0, degree_shifter(shift, print_coordinates));
    }
}
#+end_src

#+RESULTS:
#+begin_src text :minipage


Coordinates of degree 0 in an octasierp of degree 0:
 (+0, +0); (+1, +0); (+0, +1); (-1, +0); (+0, -1); (+1, +1);

Coordinates of degree 0 in an octasierp of degree 1:
 (+0, +0); (+2, +0); (+0, +2); (-2, +0); (+0, -2); (+2, +2);

Coordinates of degree 0 in an octasierp of degree 2:
 (+0, +0); (+4, +0); (+0, +4); (-4, +0); (+0, -4); (+4, +4);
#+end_src

*** Foreach policies

The policies implemented here will allow the foreach functions to be used as template parameters.

#+name: ForeachCoordinates
#+begin_src cpp :minipage
struct ForeachCoordinates {
    template<class Consumer>
    static void apply(std::size_t degree, Consumer consumer) {
        foreach_coordinates(degree, consumer);
    }
};
#+end_src
#+depends:ForeachCoordinates :noweb octasierp/foreach_coordinates

#+name: ForeachSpontaneous
#+begin_src cpp :minipage
struct ForeachSpontaneous {
    template<class Consumer>
    static void apply(std::size_t degree, Consumer consumer) {
        foreach_spontaneous(degree, consumer);
    }
};
#+end_src
#+depends:ForeachSpontaneous :noweb octasierp/foreach_spontaneous

#+name: ForeachTriangle
#+begin_src cpp :minipage
struct ForeachTriangle {
    template<class Consumer>
    static void apply(std::size_t degree, Consumer consumer) {
        foreach_triangle(degree, consumer);
    }
};
#+end_src
#+depends:ForeachTriangle :noweb octasierp/foreach_triangle

#+name: ForeachSegment
#+begin_src cpp :minipage
struct ForeachSegment {
    template<class Consumer>
    static void apply(std::size_t degree, Consumer consumer) {
        foreach_segment(degree, consumer);
    }
};
#+end_src
#+depends:ForeachSegment :noweb octasierp/foreach_segment

#+name: ForeveryCoordinates
#+begin_src cpp :minipage
struct ForeveryCoordinates {
    template<class Consumer>
    static void apply(std::size_t degree, Consumer consumer) {
        forevery_coordinates(degree, consumer);
    }
};
#+end_src
#+depends:ForeveryCoordinates :noweb octasierp/forevery_coordinates

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb pointless_octasierp out ForeachCoordinates ForeachTriangle ForeachSegment ForeveryCoordinates")>>

template<class Foreach>
struct print_indexes {
    const pointless_octasierp& octa;
    print_indexes(std::size_t degree): octa(degree) {
        Foreach::apply(degree, *this);
    }

    void printall_impl() const {out(';');}

    template<typename Head, typename... Tail>
    void printall_impl(const Head& head, const Tail&... tail) const {
        out(", ", octa.index_of(head));
        printall_impl(tail...);
    }

    template<typename Head, typename... Tail>
    void operator()(const Head& head, const Tail&... tail) const {
        out(' ');
        out(octa.index_of(head));
        printall_impl(tail...);
    }
};

int main() {
    std::size_t degree = 0;
    out("Coordinates:    ");   print_indexes<ForeachCoordinates>{degree};
    out("\nAll coordinates:"); print_indexes<ForeveryCoordinates>{degree};
    out("\nTriangles:      "); print_indexes<ForeachTriangle>{degree};
    out("\nSegments:       "); print_indexes<ForeachSegment>{degree};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Coordinates:     0; 2; 3; 4; 5; 1;
All coordinates: 0; 2; 3; 4; 5; 1; 1; 1; 1;
Triangles:       0, 2, 3; 2, 1, 3; 0, 3, 4; 3, 1, 4; 0, 4, 5; 4, 1, 5; 0, 5, 2; 5, 1, 2;
Segments:        0, 2; 2, 3; 3, 1; 0, 3; 3, 4; 4, 1; 0, 4; 4, 5; 5, 1; 0, 5; 5, 2; 2, 1;
#+end_src

Those results make me think that I must have missed some clever trick to implement triangles and segments iteration in one go.

*** Adapt to representation

The adapters implemented here modify the behaviour of foreach policies by changing what is transmitted to the consumer depending on the first argument they receive.

When the first argument is a =std::size_t=, the consumer is used as-is:
#+name: adapt_repr/size_t
#+begin_src cpp :minipage
namespace adapt_repr {
template<class Foreach, class Consumer>
void apply(std::size_t degree, Consumer consumer) {
    Foreach::apply(degree, consumer);
}
} // namespace adapt_repr
#+end_src

The degree can be wrapped in =index_of= to produce indexes instead of raw coordinates:
#+name: adapt_repr/index_of
#+begin_src cpp :minipage
struct index_of {
    std::size_t degree;
};
namespace adapt_repr {
template<class Consumer>
struct to_index_consumer {
    pointless_octasierp octa;
    Consumer consumer;

    template<class... Coordinates>
    void operator()(Coordinates... coordinates) {
        consumer(octa.index_of(coordinates)...);
    }
};

template<class Foreach, class Consumer>
void apply(index_of wrapper, Consumer consumer) {
    Foreach::apply(
        wrapper.degree,
        to_index_consumer(pointless_octasierp{wrapper.degree}, consumer)
    );
}
} // namespace adapt_repr
#+end_src
#+depends:adapt_repr/index_of :noweb pointless_octasierp

Finally, when the first argument is an octasierp, the underlying points of the octasierp are produced:
#+name: adapt_repr/octasierp
#+begin_src cpp :minipage
namespace adapt_repr {
template<class Point, class Consumer>
struct to_points_consumer {
    octasierp<Point>& octa;
    Consumer consumer;

    template<class... Coordinates>
    void operator()(Coordinates... coordinates) {
        consumer(octa[coordinates]...);
    }
};

template<class Foreach, class Point, class Consumer>
void apply(octasierp<Point>& octa, Consumer consumer) {
    Foreach::apply(octa.degree(), to_points_consumer{octa, consumer});
}
} // namespace adapt_repr
#+end_src
#+depends:adapt_repr/octasierp :noweb octasierp
\\
The =apply_foreach/= code blocks below are pure syntactic sugar.
I opted to not simply name the actual implementation =apply= because this name is way too generic.
This way if there is a conflict with another =apply= function, it will still be possible to fall back on =adapt_repr::apply=.
#+name: apply_foreach
#+begin_src cpp :minipage
template<class Foreach, class Repr, class Consumer>
void apply(Repr repr, Consumer consumer) {
    adapt_repr::apply<Foreach>(repr, consumer);
}
#+end_src
# Commented out waiting for a fix of include.pl, see next TODO.
# #+depends:apply_foreach/size_t :noweb adapt_repr/size_t apply_foreach
# #+depends:apply_foreach/index_of :noweb adapt_repr/index_of apply_foreach
\\
Special care must be taken to pass an =octasierp= representation by reference, both to allow the actual points to be modified and to avoid a copy of this potentially huge object.
#+name: apply_foreach/octasierp
#+begin_src cpp :minipage
template<class Foreach, class Point, class Consumer>
void apply(octasierp<Point>& octa, Consumer consumer) {
    adapt_repr::apply<Foreach>(octa, consumer);
}
#+end_src
#+depends:apply_foreach/octasierp :noweb adapt_repr/octasierp
# TODO: Force include.pl to respect the order of dependencies. i.e. adapt_repr/index_of should be included before apply_foreach because of the way apply_foreach/index_of is defined. I should not have to hardcode low-level dependencies below (the adapt_repr/) to enforce a correct order.
#+depends:apply_foreach/* :noweb apply_foreach/octasierp adapt_repr/index_of adapt_repr/size_t apply_foreach
\\
Usage:
#+begin_src cpp :eval no-export :exports both :minipage :wrap "src text"
<<include(":noweb print cse_lambda octasierp apply_foreach/* ForeachCoordinates ForeachTriangle <<qoords")>>

int main() {
    octasierp octa(0, '-');
    char next_repr = 'a';
    apply<ForeachCoordinates>(octa, [&](auto& point) {
        point = next_repr++;
    });

    auto print_lambda = cse_lambda<print<>>();
    print{"Triangle coordinates:"};
    apply<ForeachTriangle>(octa.degree(), print_lambda);
    print{"\nTriangle indexes:"};
    apply<ForeachTriangle>(index_of{octa.degree()}, print_lambda);
    print{"\nTriangle points:"};
    apply<ForeachTriangle>(octa, print_lambda);
}
#+end_src

#+RESULTS:
#+begin_src text
Triangle coordinates:
(+0, +0) (+1, +0) (+0, +1)
(+1, +0) (+1, +1) (+0, +1)
(+0, +0) (+0, +1) (-1, +0)
(+0, +1) (+1, +1) (-1, +0)
(+0, +0) (-1, +0) (+0, -1)
(-1, +0) (+1, +1) (+0, -1)
(+0, +0) (+0, -1) (+1, +0)
(+0, -1) (+1, +1) (+1, +0)

Triangle indexes:
0 2 3
2 1 3
0 3 4
3 1 4
0 4 5
4 1 5
0 5 2
5 1 2

Triangle points:
a b c
b f c
a c d
c f d
a d e
d f e
a e b
e f b
#+end_src

*** Foreach subdivision

The foreach policy =ForeachSubdivision= iterates on each subdivisions that will occur when passing from =degree= to =degree + 1=.
It is rather concise because it uses the fact that a new point is created in between each segment.

I really prefer the foreach policies to the foreach function so =foreach_subdivision= is skipped.
#+name: ForeachSubdivision
#+begin_src cpp :minipage
struct ForeachSubdivision {
    template<class Consumer>
    static void apply(std::size_t degree, Consumer consumer) {
        ForeachSegment::apply(degree, degree_shifter(1, [&consumer,degree](auto a, auto b) {
            auto midpoint = b;
            if(b.is_mirrored_canonical(degree + 1))
                midpoint.unmirror();

            if(a.main.x != midpoint.main.x) // a is on the left.
                --midpoint.main.x;
            if(a.main.y != midpoint.main.y) // a is above.
                ++midpoint.main.y;

            consumer(midpoint, a, b);
        }));
    }
};
#+end_src
#+depends:ForeachSubdivision :noweb ForeachSegment degree_shifter

# Well technically =foreach_segment=.
Because of the way =ForeachSegment= has been implemented, it is guaranteed that all mirrored points are contained in =b=, this is why the mirroring only has to be tested on it.
This is also why =midpoint= does not need to be mirrored back, it is necessarily shifted away from the border, thereby becoming a canonical point.

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb print ForeachSubdivision adapt_repr/size_t apply_foreach <<qoords")>>

int main() {
    apply<ForeachSubdivision>(0, [](auto midpoint, auto a, auto b) {
        print{"The midpoint of", a, "and", b, "is", midpoint};
    });
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
The midpoint of (+0, +0) and (+2, +0) is (+1, +0)
The midpoint of (+0, +2) and (+2, +0) is (+1, +1)
The midpoint of (+0, +2) and (+2, +2) is (+1, +2)
The midpoint of (+0, +0) and (+0, +2) is (+0, +1)
The midpoint of (-2, +0) and (+0, +2) is (-1, +1)
The midpoint of (-2, +0) and (+2, +2) is (-2, +1)
The midpoint of (+0, +0) and (-2, +0) is (-1, +0)
The midpoint of (+0, -2) and (-2, +0) is (-1, -1)
The midpoint of (+0, -2) and (+2, +2) is (-1, -2)
The midpoint of (+0, +0) and (+0, -2) is (+0, -1)
The midpoint of (+2, +0) and (+0, -2) is (+1, -1)
The midpoint of (+2, +0) and (+2, +2) is (+2, -1)
#+end_src

*** Forevery subdivision

This foreach (well, forevery) policy iterates upon every subdivision occuring for all degrees, starting with degree 0.
The intended use case for this is the construction of an octasierp (the first six points must have already been constructed).

#+name: ForeverySubdivision
#+begin_src cpp :minipage
struct ForeverySubdivision {
    template<class Consumer>
    static void apply(std::size_t degree, Consumer consumer) {
        for(std::size_t sub_degree = 0; sub_degree < degree; ++sub_degree)
            ForeachSubdivision::apply(
                sub_degree,
                degree_shifter(degree - sub_degree - 1, consumer)
            );
    }
};
#+end_src
#+depends:ForeverySubdivision :noweb ForeachSubdivision degree_shifter

The following code will first construct an octasierp with each point represented by its degree of apparition, and then print its shadow:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb ForeverySubdivision octasierp apply_foreach/octasierp squarenet_shadow max")>>

int main() {
    octasierp apparition(2, '0');
    apply<ForeverySubdivision>(apparition, [&](auto& midpoint, auto& a, auto& b) {
        midpoint = max(a, b) + 1;
    });
    squarenet_shadow(apparition.degree(), [&](const auto& coords) {
        return apparition[coords];
    });
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
. . . . . . . . . . .
. . . . . 0 2 1 2 0 .
. 2 2 2 2 2 2 2 2 . .
. 1 2 1 2 1 2 1 2 . .
. 2 2 2 2 2 2 2 2 . .
. 0 2 1 2 0 2 1 2 0 .
. . 2 2 2 2 2 2 2 2 .
. . 2 1 2 1 2 1 2 1 .
. . 2 2 2 2 2 2 2 2 .
. . 2 1 2 0 . . . . .
. . . . . . . . . . .
#+end_src


** Binary degree

A naive C++ implementation of the binary degree function will look like this:
#+name: naive_bindeg
#+begin_src cpp :minipage
unsigned int naive_bindeg(unsigned int index, unsigned int degree) {
    if(index % 2 == 1 || degree == 0)
        return degree;
    return naive_bindeg(index >> 1, degree - 1);
}
#+end_src

Usage:
#+begin_src cpp :eval no-export :wrap "src text :minipage" :exports both :minipage
<<include(":noweb naive_bindeg print")>>

int main() {
    unsigned int degree = 3;
    unsigned int rightmost = 1 << degree;
    for(unsigned int i = 0; i <= rightmost; ++i) {
        print{{.sep=""}}("bindeg(", i, ", ", degree, ") = ", naive_bindeg(i, degree));
    }
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
bindeg(0, 3) = 0
bindeg(1, 3) = 3
bindeg(2, 3) = 2
bindeg(3, 3) = 3
bindeg(4, 3) = 1
bindeg(5, 3) = 3
bindeg(6, 3) = 2
bindeg(7, 3) = 3
bindeg(8, 3) = 0
#+end_src

The binary degree function will be fundamental to some octasierp operarations and can probably be optimised using =<strings.h>='s =ffs= (find first set).


* Octasierp policies
:PROPERTIES:
:header-args:cpp: :noweb no-export :eval never :main no
:END:

Where the previous section defined a set of primitives to manipulate octasierps, this section takes over by using those low-level primitives to craft higher-level policies that will define the shape and rendering of an octasierp.
There are three distinct types of octasierp policies:
 - Elevation policy :: Associates an elevation to each point of the octasierp.
 - Coloration policy :: Associates a color to each point of the octasierp.
 - Repartition policy :: Transforms elevations into 3d positions.

** Helpers

*** Octaform and planet properties

Octaforms are the result type of the octasierp growth function, the function responsible for constructing an octasierp.
This type also stores an octasierp's data while it is in construction.
It acts therefore as an exchange interface between the policies and lives inside its own namespace:

#+name: octaform
#+begin_src cpp :minipage
namespace octaform_impl {
<<octaform/impl>>
}
#+end_src
\\

Planet properties are the part of an octaform can be defined at the call site of the growth function.
Its actual content will be filled later, as needed.
#+begin_src cpp :noweb-ref octaform/impl :minipage
struct planet_properties {
    <<planet_properties/public>>
};
#+end_src
\\

The octaform implementation is split into the base and the proper implementation.
This split was necessary because the proper implementation must store the height getter and it turns out that this height getter is produced by the elevation policy that needs the octaform in the first place in order to produce it.

To resolve this circular dependency, the height getter is produced with the base implementation, and the base's data will simply be copied over to the proper implementation.

Here is the base:
#+begin_src cpp :noweb-ref octaform/impl :minipage
class octaform_base: public pointless_octasierp {
  public:
    const planet_properties& properties;

    octaform_base(
        std::size_t degree,
        const planet_properties& _properties
    ): pointless_octasierp(degree), properties(_properties)
    {}
};
#+end_src
\\

The proper implementation requires a vertex size that is included in =planet_properties=.
Being in this place will allow it to be tweaked at the call site to cram more information into a vertex.
#+begin_src cpp :noweb-ref planet_properties/public :minipage
std::size_t vertex_size = 6;
#+end_src
\\

Below is the outline of the actual implementation.
The =HeightGetter= is deliberately moved because it can amount to a wrapped vector of heights, which would be costly to copy.
#+begin_src cpp :noweb-ref octaform/impl :minipage
template<class HeightGetter>
struct octaform: public octaform_base {
    using height_type = typename HeightGetter::value_type;

    octaform(
        const octaform_base& base,
        HeightGetter&& _height
    ): octaform_base(base),
       height(std::move(_height))
    {
        <<octaform/ctor>>
    }

    HeightGetter height;
    std::vector<float> vertices;
    std::vector<unsigned int> indexes;

    <<octaform/public>>
};
#+end_src
#+depends:octaform :noweb pointless_octasierp :cpp vector span utility
\\

The methods ending with =ptr= and =span= serve to access the sub-vertices, with position and color being hardcoded as the first two sub-vertices:
#+begin_src cpp :noweb-ref octaform/public
// Static ptr and span getters.
template<std::size_t Offset>
auto offset_ptr(auto index) {
    return &vertices[properties.vertex_size * index + Offset];
}

template<std::size_t SpanSize, std::size_t Offset>
auto offset_span(auto index) {
    return std::span<float, SpanSize>(offset_ptr<Offset>(index), SpanSize);
}

auto position_ptr(auto index) {return offset_ptr<0>(index);}
auto color_ptr(auto index)    {return offset_ptr<3>(index);}
auto position_span(auto index) {return offset_span<3, 0>(index);}
auto color_span(auto index)    {return offset_span<3, 3>(index);}

// Dynamic ptr and span getters.
auto offset_ptr(auto index, auto offset) {
    return offset_ptr<0>(index) + offset;
}

template<std::size_t SpanSize>
auto offset_span(auto index, auto offset) {
    return std::span<float, SpanSize>(offset_ptr(index, offset), SpanSize);
}
#+end_src
\\

A few statistics about heights are stored in the =octaform=:
#+begin_src cpp :noweb-ref octaform/public :minipage
struct height_stats_t {
    height_type min_height;
    height_type max_height;
    height_type sea_height;
    height_type diff_height() const {return max_height - min_height;}
};
height_stats_t stats;
#+end_src

The stats are computed upon construction.
They are not always needed, as some combinations of policies will not use them at all, and furthermore the computations could be more efficient if they were done in the height policy itself because it knows more about its own nature than the =octaform= does.
But given the time computing height statistics takes when compared to the other operations performed by the policies, implementing a mechanism to compute them efficiently and store them only as needed would be a severe case of overengineering.
#+begin_src cpp :noweb-ref octaform/ctor :minipage
stats.min_height = height(0); stats.max_height = stats.min_height;
auto end_index = point_cardinality();
for(std::size_t i = 1; i < end_index; ++i) {
    float height_i = height(i);
    if(height_i < stats.min_height) stats.min_height = height_i;
    if(height_i > stats.max_height) stats.max_height = height_i;
}
stats.sea_height = stats.min_height + stats.diff_height() * properties.sea_level;
#+end_src
\\

To summarise the role of =octaform=, here is a short list of what it will make available to the octasierp policies:
 - All the interface of =pointless_octasierp= (via inheritance).
 - Whatever is inside =planet_properties= (via =.properties=).
 - The height associated with a given point (via =.height=).
 - A pointer and a span to a given sub-vertex (via the =*_ptr= and =*_span= methods).
 - Some statistics (via =.stats=).

The only exception to this is, as stated above, the elevation policy that only gets access to what is in the base implementation (that is to say the first two points).

Also note that while technically policies can directly access vertices and indexes, they are not supposed to.
I'm not a fan of using encapsulation when it would make both the implementation and the usage inconvenient so I prefer to leave those attributes public.

*** Octasierp growth function

=grow_octasierp= combines an elevation policy, a coloration policy and a repartition policy to generate an octasierp's data.

#+name: grow_octasierp
#+begin_src cpp :minipage
namespace octaform_impl {
template<class Elevation, class Coloration, class Repartition>
auto grow_octasierp(
    std::size_t degree, Elevation elevation,
    Coloration coloration, Repartition repartition,
    const planet_properties& properties=planet_properties{}
) {
    octaform_base base(degree, properties);
    octaform ofo(base, elevation(base));

    ofo.vertices.resize(repartition.size(ofo) * properties.vertex_size, -999999.f);
    coloration.fill_colors(ofo);
    repartition.fill_positions(ofo);
    ofo.indexes = repartition.compute_indexes(ofo);
    return ofo;
}
} // namespace octaform_impl
using octaform_impl::grow_octasierp;
#+end_src
#+depends:grow_octasierp :noweb octaform :cpp utility

This implementation de-facto defines the interfaces of the elevation, coloration and repartition policies.

*** Octasierp rendering function

This function's goal is to centralise octasierp rendering boilerplate while still being generic and tweakable enough to be useful for most cases.
The parameters =prerender= and =render= can be used to tweak the octasierp's state just before the first frame is rendered and at each frame.
#+name: render_octasierp
#+begin_src cpp
namespace render_octasierp_impl {
struct other_args {
    mandatory<const std::vector<float>&> vertices;
    std::vector<unsigned int> layout = {3, 3};
    mandatory<const std::vector<unsigned int>&> indexes;
    float scale=.6; float camlong=0; float camlat=0;
    glm::vec3 up={0, 0, 1};
    const char* screenshot=nullptr;
    const char* title="Octasierp rendering";
};

struct render_state {
    shader_unit<std::vector<float>> unit;
    orbital_camera camera;
};

template<class LambdaPreRender, class LambdaRender>
void render_octasierp(
    const shader_sources& sources, const other_args& args,
    LambdaPreRender prerender, LambdaRender render
) {
    lazy_window lazy(args.title);
    orbital_camera tmp_cam(
        {0, 0, 0}, 2, // Pointed at the origin, at a distance of 2.
        args.camlong, args.camlat, args.up
    );
    render_state state{
        shader_unit<std::vector<float>>(
            sources,
            transform().scale(args.scale),
            to_span(tmp_cam.view()),
            {.aspect=lazy.aspect()},
            {.content=*args.vertices,
             .layout=args.layout,
             .indexes=*args.indexes}
        ),
        std::move(tmp_cam)
    };
    auto sync_anchor = sync_window_size(state.unit, lazy);

    prerender(state);
    auto wrapped_render = [&]{render(state);};
    if(args.screenshot == nullptr)
        lazy.game_loop(wrapped_render);
    else
        gl_screen_first(lazy, args.screenshot, wrapped_render);
}
} // namespace render_octasierp_impl
using render_octasierp_impl::render_octasierp;
#+end_src
#+depends:render_octasierp :noweb orbital_camera lazy_window shader_unit transform to_span/glm sync_window_size gl_screen_first :cpp vector glm/glm.hpp

The lambda below can be used as a prerender that will render meshes as thick lines:
#+name: thick_lines
#+begin_src cpp :minipage
auto thick_lines = [](auto& ignore) {
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    glLineWidth(8);
};
#+end_src

This functor can be used to draw the model and make it spin every iteration at the specified angle along the specified axis:
#+name: drawspin
#+begin_src cpp :minipage
struct drawspin {
    float angle = .01;
    glm::vec3 axis = {0, 0, 1};
    void operator()(auto& state) {
        state.unit.draw();
        state.unit.with_model([this](auto& model) {
            model.rotate_rad(angle, axis);
        });
    }
};
#+end_src


** Colored squarenet

This section will define one policy of each type with the goal of rendering a squarenet in 3d, whose coloration will illustrate the storage order of points.

*** Constant elevation

An elevation policy takes the shape of a consumer of =octaform= returning a consumer of =std::size_t= (indexes).
With a constant elevation, those parameters can be safely ignored:
#+name: constant_elevation
#+begin_src cpp :minipage
template<typename T=float>
struct constant_elevation {
    constexpr bool is_uniform() const {return true;}
    const T elevation;

    struct result_type {
        using value_type = T;
        const T elevation;
        T operator()(const auto& ignored) const {return elevation;}
    };
    auto operator()(const auto& ignored) const {
        return result_type{elevation};
    }
};
#+end_src

*** RM5CY coloration

This coloration policy consists of using a red to magenta to cyan (5 times) to yellow gradient to color the vertices in their order of storage.
This slightly convoluted color scheme was chosen because a simpler one looks like a swastika when rendered with a squarenet repartition.

#+name: rm5cy_coloration
#+begin_src cpp :minipage
struct rm5cy_coloration {
    template<class Octaform>
    void fill_colors(Octaform& ofo) {
        rgb_interpolation<segarray, 8> gradient{
            1, 0, 0, // Red.
            1, 0, 1, // Magenta.
            0, 1, 1, // Cyan.
            0, 1, 1, // Cyan.
            0, 1, 1, // Cyan.
            0, 1, 1, // Cyan.
            0, 1, 1, // Cyan.
            1, 1, 0, // Yellow.
        };
        auto end = ofo.point_cardinality();
        for(std::size_t i = 0; i < end; ++i)
            gradient.fill(ofo.color_span(i), i, end);
    }
};
#+end_src
#+depends:rm5cy_coloration :noweb rgb_interpolation segarray

*** Squarenet repartition

This repartition policy computes the positions for a 3d squarenet, with the height being used as the z component.

#+name: squarenet_repartition
#+begin_src cpp :minipage
class squarenet_repartition {
  public:
    static std::size_t side(std::size_t degree) {
        return (1 << (degree + 1)) + 1;
    }

    template<class Octaform>
    std::size_t size(const Octaform& ofo) const {
        std::size_t squarenet_side = side(ofo.degree);
        return squarenet_side * squarenet_side;
    }

    template<class Octaform> void fill_positions(Octaform& ofo) {
        <<squarenet_repartition/fill_positions>>
    }

    template<class Octaform>
    std::vector<unsigned int> compute_indexes(const Octaform& ofo) const {
        <<squarenet_repartition/compute_indexes>>
    }

  private:
    std::unordered_map<std::pair<int, int>, std::size_t> redundant_indexes_;
};
#+end_src
#+depends:squarenet_repartition :noweb hash/pair pointless_octasierp adapt_repr/size_t apply_foreach ForeveryCoordinates ForeachTriangle :cpp utility vector unordered_map algorithm

The difficulty in filling positions comes from the need to handle non canonical (aka redundant) coordinates.
The indexes of those coordinates are kept around in =redundant_indexes_=, because they will be needed in the next step (indexes generation).

#+name: squarenet_repartition/fill_positions
#+begin_src cpp :minipage
auto next_mirrored = ofo.point_cardinality();
float side_ = side(ofo.degree);
apply<ForeveryCoordinates>(ofo.degree, [&](auto coords) {
    std::size_t index = ofo.index_of(coords);
    if(coords.is_mirrored_canonical(ofo.degree)) { // Redundant point.
        auto canonical = ofo.position_ptr(index);
        auto dest = ofo.position_ptr(next_mirrored);
        coords.unmirror();
        redundant_indexes_[{coords.x, coords.y}] = next_mirrored++;

        // x and y can be used as is.
        dest[0] = coords.x / side_; dest[1] = coords.y / side_;
        // Height and color data must be copied over from the canonical point.
        std::copy(canonical + 2, canonical + 6, dest + 2);
    } else { // Canonical point.
        auto dest = ofo.position_ptr(index);
        dest[0] = coords.x / side_; dest[1] = coords.y / side_;
        dest[2] = ofo.height(index);
    }
});
#+end_src

Since OpenGL indexes correspond to triangles, =ForeachTriangle= is used to generate them.
As mentioned before, the map =redundant_indexes_= associates a given redundant point to its index.

#+name: squarenet_repartition/compute_indexes
#+begin_src cpp :minipage
std::vector<unsigned int> result;
result.reserve(ofo.triangle_cardinality() * 3);

apply<ForeachTriangle>(ofo.degree, [&](auto a, auto b, auto c) {
    for(auto coords: {a, b, c}) {
        std::size_t index;
        if(coords.is_mirrored_canonical(ofo.degree)) {
            coords.unmirror();
            index = redundant_indexes_.at({coords.x, coords.y});
        } else {
            index = ofo.index_of(coords);
        }
        result.push_back(index);
    }
});

return result;
#+end_src

To avoid crashes, =computes_index= depends on =fill_positions= being called before, because is needs =redundant_indexes_= to be properly constructed.
This was in fact the main inspiration for =grow_octasierp= since using it guarantees that those methods are called in the correct order.

*** Rendering

No custom shaders are needed for rendering, =graphics.org= already defines a vertex shader that applies a model, view and projection matrix to its position, as well as a fragment shader that uses a color passed as an attribute.
The following include block can be used to include blocks from =graphics.org=:
#+name: graphics
#+begin_src sh :var args="" :results output :wrap "src cpp" :eval no-export :minipage
./litlib/include.pl "graphics.org" "$args"
#+end_src

Constructing a mesh is now simply a matter of calling =grow_octasierp= with the desired policies:
#+begin_src cpp :eval no-export :exports both :flags -std=c++20 -Wall -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb grow_octasierp constant_elevation rm5cy_coloration squarenet_repartition render_octasierp thick_lines drawspin :defs graphics.org window.org")>>

int main(){
    std::size_t degree = 3;
    auto mesh = grow_octasierp(
        degree,
        constant_elevation{0},
        rm5cy_coloration{},
        squarenet_repartition{}
    );

    render_octasierp(
        {.vertex =
         <<graphics(":noweb model_view_projection_vs :c-string")>>,
         .fragment =
         <<graphics(":noweb color_as_attribute_fs :c-string")>>},
        {.vertices=mesh.vertices, .indexes=mesh.indexes,
        .scale=1.2, .camlong=90, .camlat=0, .up={0, 1, 0},
        .screenshot="images/screencaps/gradient_squarenet.png",
        .title="Colored octanet"},
        thick_lines, drawspin{.axis={0, 1, 0}}
    );
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/gradient_squarenet.png]]
:end:

At first I wanted to use a neat multicolor gradient with two colors per quarter but because of the mirrored points, it was impossible to make it not look like a swastika.
That is why I settled on this color gradient with one red, one magenta, five cyan and one yellow.

It doesn't have this unfortunate look but still illustrates the point ordering and mirroring for quarter 0 with:
 - The six original points (and a few more) showing in red.
 - The canonical points of quarter 0 transitioning from red to magenta to cyan.
 - The orthodox points of the right border being a mirrored version of the yellow points from the end of quarter 3.


** Colored octasierp

The policies implemented in this section will allow us to render an octasierp in three dimensions, as if the final rendering from the previous section was folded in 3d.

*** RM5CY_BNWS coloration

This coloration is the same as the RM5CY, except for the north and south poles, which are respectively colored in black and white, to make the north/south axis stand out.

#+name: rm5cy_bnws_coloration
#+begin_src cpp :minipage
struct rm5cy_bnws_coloration {
    template<class Octaform>
    void fill_colors(Octaform& ofo) {
        rm5cy_coloration{}.fill_colors(ofo);
        auto pole = ofo.color_span(0); pole[0] = 0; pole[1] = 0; pole[2] = 0;
        pole      = ofo.color_span(1); pole[0] = 1; pole[1] = 1; pole[2] = 1;
    }
};
#+end_src
#+depends:rm5cy_bnws_coloration :noweb rm5cy_coloration

*** Generic index computation

For fully 3d repartition policies, indexes computation will not change as it will simply consist of using the indexes of triangles.
The function below can be used to perform this exact computation.

#+name: compute_octasierp_indexes
#+begin_src cpp :minipage
auto compute_octasierp_indexes(const pointless_octasierp& octa) {
    std::vector<unsigned int> result;
    result.reserve(octa.triangle_cardinality() * 3);
    apply<ForeachTriangle>(octa.degree, [&](auto a, auto b, auto c) {
        result.push_back(octa.index_of(a));
        result.push_back(octa.index_of(b));
        result.push_back(octa.index_of(c));
    });
    return result;
}
#+end_src
#+depends:compute_octasierp_indexes :noweb pointless_octasierp adapt_repr/size_t ForeachTriangle apply_foreach :cpp vector

A concise repartition policy can be made by inheriting from the following class:
#+name: octasierp_triangle_indexer
#+begin_src cpp
struct octasierp_triangle_indexer {
    template<class Octaform>
    std::size_t size(const Octaform& ofo) const {
        return ofo.point_cardinality();
    }

    template<class Octaform>
    auto compute_indexes(const Octaform& ofo) const {
        return compute_octasierp_indexes(ofo);
    }
};
#+end_src
#+depends:octasierp_triangle_indexer :noweb compute_octasierp_indexes

*** Octahedral repartition

#+name: octahedral_repartition
#+begin_src cpp :minipage
struct octahedral_repartition: public octasierp_triangle_indexer {
    template<class Octaform> void fill_positions(Octaform& ofo) {
        <<octahedral_repartition/fill_positions>>
    }
};
#+end_src
#+depends:octahedral_repartition :noweb octasierp_triangle_indexer apply_foreach adapt_repr/size_t ForeverySubdivision fill_midpoint/span :cpp array span

Computing positions for octahedral repartition is separated in two phases.
In the first phase, the desired height is ignored and the mesh is given a perfectly octahedral shape:
#+begin_src cpp :noweb-ref octahedral_repartition/fill_positions :minipage
auto dest = ofo.position_ptr(0); dest[0] =  0; dest[1] =  0; dest[2] =  1; // North pole.
dest      = ofo.position_ptr(1); dest[0] =  0; dest[1] =  0; dest[2] = -1; // South pole.
dest      = ofo.position_ptr(2); dest[0] =  1; dest[1] =  0; dest[2] =  0; // Corner 0.
dest      = ofo.position_ptr(3); dest[0] =  0; dest[1] =  1; dest[2] =  0; // Corner 1.
dest      = ofo.position_ptr(4); dest[0] = -1; dest[1] =  0; dest[2] =  0; // Corner 2.
dest      = ofo.position_ptr(5); dest[0] =  0; dest[1] = -1; dest[2] =  0; // Corner 3.

auto spanindex = [&](const auto& coords) {
    return ofo.position_span(ofo.index_of(coords));
};
apply<ForeverySubdivision>(ofo.degree, [&spanindex](auto& midpoint, const auto& a, const auto& b) {
    auto smid = spanindex(midpoint);
    auto sa = spanindex(a); auto sb = spanindex(b);
    fill_midpoint(smid, sa, sb);
});
#+end_src

In the second phase, the actual heights are applied to the octahedral shape.
The naïve implementation below will probably need some adjustment to properly work with non-constant height.
#+begin_src cpp :noweb-ref octahedral_repartition/fill_positions :minipage
auto end = size(ofo);
for(std::size_t i = 0; i < end; ++i) {
    dest = ofo.position_ptr(i);
    auto height = ofo.height(i);
    // auto normalised = glm::normalize(*reinterpret_cast<glm::vec<3, float, glm::packed_highp>*>(dest));
    // dest[0] *= normalised.x;
    dest[0] *= height; dest[1] *= height; dest[2] *= height;
}
#+end_src

*** Rendering

#+begin_src cpp :eval no-export :exports both :flags -std=c++20 -Wall -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb grow_octasierp constant_elevation rm5cy_bnws_coloration octahedral_repartition render_octasierp thick_lines drawspin :defs graphics.org window.org")>>

int main() {
    std::size_t degree = 3;
    auto mesh = grow_octasierp(
        degree,
        constant_elevation{1},
        rm5cy_bnws_coloration{},
        octahedral_repartition{}
    );

    render_octasierp(
        {.vertex =
         <<graphics(":noweb model_view_projection_vs :c-string")>>,
         .fragment =
         <<graphics(":noweb color_as_attribute_fs :c-string")>>},
        {.vertices=mesh.vertices, .indexes=mesh.indexes,
         .camlong=6, .camlat=6,
         .screenshot="images/screencaps/3d_octasierp.png",
         .title="Colored octasierp"},
        thick_lines, drawspin{}
    );
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/3d_octasierp.png]]
:end:


** Pseudo-sphere

The properties of the squarenet coordinates system can be abused to first transform squarenet coordinates into spherical coordinates and then into cartesian coordinates.
By doing so, an octasierp can be inflated into a pseudo-sphere.

*** Spherical converter

The following outline of =spherical_converter= handles the easy parts of the spherical conversion, that is to say:
 1. Computing the index of interesting slices of the octasierp.
    A slice is a plan that is both orthogonal to the north-south axis and passes through points defined at the current degree.
    Slices are numbered from the northermost to the southermost, starting at 0.
    This makes the =mid_slice= correspond to the equator and the =max_slice= to the south pole.
 2. Transforming spherical coordinates to cartesian coordinates (not that I understand what is actually going on, it is easy in the sense of being the application of a magical formula).
    See https://en.wikipedia.org/wiki/Spherical_coordinate_system.
 3. Setting a few useful constants.

The more tricky part will be to convert from octasierp coordinates to spherical coordinates.

#+name: spherical_converter
#+begin_src cpp
class spherical_converter {
  public:
    const int max_slice;
    const int mid_slice;

    spherical_converter(const pointless_octasierp& octa):
        max_slice(octa.extreme_index * 2),
        mid_slice(octa.extreme_index)
    {}

    struct cartesian_coordinates {
        float x;
        float y;
        float z;
    };

    struct spherical_coordinates {
        float polar;
        float azimuth;
        auto to_cartesian(float radius) {
            return cartesian_coordinates{
                .x=radius * cosf(azimuth) * sinf(polar),
                .y=radius * sinf(azimuth) * sinf(polar),
                .z=radius * cosf(polar)
            };
        }
    };

    <<spherical_converter/public>>

  private:
    static constexpr float pi = std::numbers::pi_v<float>;
    static constexpr float half_pi = pi / 2;
    <<spherical_converter/private>>
}; // class spherical_converter
#+end_src
#+depends:spherical_converter :noweb pointless_octasierp qoords :cpp numbers cmath

=convert_raw_quarter0= converts octasierp coordinates to spherical coordinates for quarter 0 only.

The distance from the north pole corresponds to the slice number (lines parallel to the equator), which can be converted to the =polar= coordinate using the principle that the first slice corresponds to a polar value of $0\ rad$ and the last slice to a polar value of $\pi\ rad$.
In a similar way, the azimuth corresponds to the angle from the north pole, with the following angles:
 - $0\ rad$ to corner 0.
 - $\frac{\pi}{2}\ rad$ to corner 1.
 - $\pi\ rad$ to corner 2.
 - $\frac{3 \pi}{2}\ rad$ to corner 3.

The =polar= and =azimuth= values will be multiplied by $\pi$ and $\frac{\pi}{2}$ later because it is easier this way.

#+begin_src cpp :noweb-ref spherical_converter/private
spherical_coordinates convert_raw_quarter0(int abs_x, int abs_y) const {
    // Expects both coordinates to be absolute values, since this is quarter 0.
    spherical_coordinates result;
    int slice = abs_x + abs_y;
    // out("[", abs_x, ", ", abs_y, "]");
    // out(" slice ", slice);
    if(slice >= mid_slice) { // Replace southern hemisphere with northern hemisphere equivalent.
        // out(" > ", mid_slice);
        abs_x = mid_slice - abs_x;
        abs_y = mid_slice - abs_y;
        std::swap(abs_x, abs_y);
        // out(" equiv northern: [", abs_x, ", ", abs_y, "]");
    } // else out(" <= ", mid_slice);

    if(abs_x >= abs_y) {
        // out(" first azimuth");
        if(abs_x == 0)
            result.azimuth = 0;
        else
            result.azimuth = float(abs_y) / (2 * abs_x);
    } else {
        // out(" second azimuth");
        result.azimuth = 1 - float(abs_x) / (2 * abs_y);
    }

    result.polar = float(slice) / max_slice;
    // out(" ", result, "\n");
    return result;
}
#+end_src

The user-facing method below uses the fact that quarter 1, 2 and 3 are left rotations of quarter 0 to compute the correct azimuth.

#+begin_src cpp :noweb-ref spherical_converter/public :minipage
template<int Quarter>
spherical_coordinates convert(qoords<Quarter>& coords) const {
    auto coords_q0 = qoords<0>::from<Quarter>(coords.x, coords.y);
    spherical_coordinates result = convert_raw_quarter0(coords_q0.x, coords_q0.y);
    result.azimuth += Quarter; // Quarter is the number of left rotations from quarter 0.
    result.azimuth *= half_pi;
    result.polar *= pi;
    return result;
}
#+end_src

Redirection operator:
#+name: <<spherical_coordinates
#+begin_src cpp :minipage
std::ostream& operator<<(
    std::ostream& os, const spherical_converter::spherical_coordinates& c
) {
    return os << "(polar=" << c.polar << ", azimuth=" << c.azimuth << ")";
}
#+end_src
#+depends:<<spherical_coordinates :noweb spherical_converter :cpp iostream

*** Spherical repartition

With its brutal use of lambdas and =reinterpret_cast=, =spherical_repartition= can fill pseudo-spherical coordinates for a whole octasierp.
The addresses returned by =get_dest= must point to three continuous floats whose ordering corresponds to x, y and z coordinates.

#+name: spherical_repartition
#+begin_src cpp :minipage
struct spherical_repartition: public octasierp_triangle_indexer {
    template<class Octaform> void fill_positions(Octaform& ofo) {
        using sphc = spherical_converter::cartesian_coordinates;
        spherical_converter to_spherical(ofo);
        apply<ForeachCoordinates>(ofo.degree, [&](auto coords) {
            auto index = ofo.index_of(coords);
            *reinterpret_cast<sphc*>(ofo.position_ptr(index)) = to_spherical.convert(coords).to_cartesian(ofo.height(index));
        });
    }
};
#+end_src
#+depends:spherical_repartition :noweb octasierp_triangle_indexer spherical_converter adapt_repr/size_t ForeachCoordinates

*** Rendering

#+begin_src cpp :eval no-export :exports both :flags -std=c++20 -Wall -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb grow_octasierp constant_elevation rm5cy_bnws_coloration spherical_repartition render_octasierp thick_lines drawspin :defs graphics.org window.org")>>

int main() {
    std::size_t degree = 3;
    auto mesh = grow_octasierp(
        degree,
        constant_elevation{1},
        rm5cy_bnws_coloration{},
        spherical_repartition{}
    );

    render_octasierp(
        {.vertex =
         <<graphics(":noweb model_view_projection_vs :c-string")>>,
         .fragment =
         <<graphics(":noweb color_as_attribute_fs :c-string")>>},
        {.vertices=mesh.vertices, .indexes=mesh.indexes,
         .camlong=6, .camlat=6,
         .screenshot="images/screencaps/spherical_octasierp.png",
         .title="Pseudo-spherical octasierp"},
         thick_lines, drawspin{}
    );
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/spherical_octasierp.png]]
:end:

As can be seen in the picture above, this way of transforming coordinates is flawed because the lines are squished around the four corners.
I kinda like the effect though.


** Accidented landscape with midpoint displacement

The general principle of midpoint displacement consist of computing heights by starting from a few origin points.
Then the heights of a midpoint (a new point between some of those origin points) can be calculated by averaging the heights of its origins and adding a random (but controlled) amount.
This processus can generate an accidented landscape, reminding of mountaineous terrain.

*** Midpoint displacement adapted to octasierps

When adapted to an octasierp, the midpoint displacement algorithm gives better results with an additional initialisation phase, during which all height computations are independant, i.e. no midpoints are used.

This initialisation phase is represented by the parameter =init_degree=, the last degree whose height is independant of its surroundings, this parameter should be smaller or equal to the actual degree of the octasierp.
The =seed= parameter is used to initialise the random number generator, =average= is the initial height and =range= corresponds to the greatest variation of height possible.
With the default values, this means that the height will vary between 0.965 and 1.035.

#+name: midpoint_displacement_octasierp
#+begin_src cpp :minipage
namespace midpoint_octasierp_impl {
struct kwargs {
    mandatory<std::size_t> init_degree;
    unsigned int seed=162342;
    float average=1; float range=.07;
};
auto midpoint_displacement_octasierp(const pointless_octasierp& octa, const kwargs& args) {
    auto init_degree = *args.init_degree;
    if(init_degree > octa.degree) // Avoid overflows in the initialisation phase.
        init_degree = octa.degree;

    std::vector<float> result(octa.point_cardinality(), -999999);
    <<midpoint_displacement_octasierp/impl>>
    return result;
}
}
using midpoint_octasierp_impl::midpoint_displacement_octasierp;
#+end_src
#+depends:midpoint_displacement_octasierp :noweb mandatory pointless_octasierp ForeachSpontaneous ForeachSubdivision adapt_repr/size_t apply_foreach degree_shifter :cpp random
\\
To keep some coherence in the generated heights, the further the algorithm progresses, the smaller the random element must be.
Another way to formulate this is the closer the points are, the smaller their average height difference must be, otherwise the heights might as well be fully randomised.
The approach adopted here is analogous to dividing the range by two:
#+begin_src cpp :noweb-ref midpoint_displacement_octasierp/impl :minipage
auto make_distribution = [&args](std::size_t shift) {
    auto delta = args.range / (2 << shift);
    return std::uniform_real_distribution<float>(-delta, delta);
};
#+end_src
\\
As mentioned before, during the initialisation phase, the points heights are kept independant:
#+begin_src cpp :noweb-ref midpoint_displacement_octasierp/impl :minipage
std::mt19937_64 engine(args.seed);
auto distrib = make_distribution(0);
for(std::size_t current = 0; current <= init_degree; ++current) {
    apply<ForeachSpontaneous>(
        current,
        degree_shifter(octa.degree - current, [&](auto coords) {
            result[octa.index_of(coords)] = args.average + distrib(engine);
        })
    );
}
#+end_src
\\
The proper midpoint displacement occurs here, using =ForeachSubdivision=, with the random height displacement getting smaller each new degree.
#+begin_src cpp :noweb-ref midpoint_displacement_octasierp/impl :minipage
auto middisp_algorithm = [&](auto midpoint, auto a, auto b) {
    result[octa.index_of(midpoint)] =
        (result[octa.index_of(a)] + result[octa.index_of(b)]) / 2 + distrib(engine);
};
for(std::size_t parent = init_degree; parent < octa.degree; ++parent) {
    distrib = make_distribution(parent - init_degree + 1);
    apply<ForeachSubdivision>(
        parent,
        degree_shifter(octa.degree - parent - 1, middisp_algorithm)
    );
}
#+end_src

*** Midpoint elevation (policy)

Here is an implementation of the elevation policy relying on the midpoint displacement function shown above.

#+name: midpoint_elevation
#+begin_src cpp
struct midpoint_elevation {
    constexpr bool is_uniform() const {return false;}
    const midpoint_octasierp_impl::kwargs& args;

    struct result_type {
        using value_type = float;
        const std::vector<float> storage;
        float operator()(const auto index) const {
            return storage[index];
        }
    };

    template<class Octaform>
    auto operator()(const Octaform& ofo) const {
        return result_type{midpoint_displacement_octasierp(ofo, args)};
    }
};
#+end_src
#+depends:midpoint_elevation :noweb midpoint_displacement_octasierp :cpp vector

*** Rendering

#+begin_src cpp :eval no-export :exports both :flags -std=c++20 -Wall -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb grow_octasierp midpoint_elevation rm5cy_bnws_coloration spherical_repartition render_octasierp thick_lines drawspin :defs graphics.org window.org")>>

int main() {
    std::size_t degree = 3;
    auto mesh = grow_octasierp(
        degree,
        midpoint_elevation{{.init_degree=0, .range=.3}},
        rm5cy_bnws_coloration{},
        spherical_repartition{}
    );

    render_octasierp(
        {.vertex =
         <<graphics(":noweb model_view_projection_vs :c-string")>>,
         .fragment =
         <<graphics(":noweb color_as_attribute_fs :c-string")>>},
        {.vertices=mesh.vertices, .indexes=mesh.indexes,
         .camlong=6, .camlat=6,
         .screenshot="images/screencaps/spherical_midpoint_octasierp.png",
         .title="Midpoint-displaced pseudo-spherical octasierp"},
         thick_lines, drawspin{}
    );
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/spherical_midpoint_octasierp.png]]
:end:


** Height coloration

*** Scale translation

Because adjusting the sea level is a feature of this project, a planetary color scheme must be separated in two, a color scheme for the terrain above the sea and another for the terrain below:
#+name: planetary_color_scheme
#+begin_src cpp
struct planetary_color_scheme {
    rgb_scaled_interpolation<float> below_sea;
    rgb_scaled_interpolation<float> above_sea;
};
#+end_src
#+depends:planetary_color_scheme :noweb rgb_scaled_interpolation

The hard work of height coloration is done by =rgb_scaled_interpolation=, aka the color scheme.
The function below only does a small adaptation of each color scheme and checks the actual height to see whether one or the other shoud be applied to a given index.

#+name: height_coloration_octasierp
#+begin_src cpp :minipage
template<class Octaform>
void height_coloration_octasierp(
    Octaform& ofo, const planetary_color_scheme& color_scheme
) {
    auto below = color_scheme.below_sea;
    auto above = color_scheme.above_sea;
    transform_scaled_interpolation(below, ofo.stats.min_height, ofo.stats.sea_height);
    transform_scaled_interpolation(above, ofo.stats.sea_height, ofo.stats.max_height);
    auto end_index = ofo.point_cardinality();

    for(std::size_t i = 0; i < end_index; ++i) {
        auto height = ofo.height(i);
        if(height <= ofo.stats.sea_height)
            below.fill(ofo.color_span(i), height);
        else
            above.fill(ofo.color_span(i), height);
    }
}
#+end_src
#+depends:height_coloration_octasierp :noweb pointless_octasierp planetary_color_scheme transform_scaled_interpolation

Note that the function above depends on the =sea_level= property that must be added to =planet_properties=:

#+begin_src cpp :noweb-ref planet_properties/public :minipage
float sea_level = .5;
#+end_src

*** GFG Color scheme

The color scheme below was adapted from godefarig, my previous procedural planet generator.
#+name: gfg_color_scheme
#+begin_src cpp :minipage
planetary_color_scheme gfg_color_scheme{
    .below_sea = {{
        {0, {0, 0, 0}},     // black
        {15, {0, 0, .07}},  // abyss
        {73, {0, .05, .3}}, // deep waters
        {90, {0, .6, 9}}    // surface waters
    }}, .above_sea = {{
        {0, {0, .6, 9}},       // continuation of surface waters
        {8, {.05, .28, .05}},  // light green
        {12, {.05, .28, .05}}, // light green
        {16, {.1, .23, .1}},   // dark green
        {20, {.06, .2, .05}},  // darker green
        {28, {.02, .1, 0}},    // darkest green
        {34, {.28, .12, .08}}, // mountain (light dirt)
        {38, {.2, .1, .05}},   // mountain (dirt)
        {50, {.2, .2, .2}},    // mountain (rock)
        {90, {1, 1, 1}}        // snow
    }}
};
#+end_src
#+depends:gfg_color_scheme :noweb planetary_color_scheme

*** Policy

#+name: height_coloration
#+begin_src cpp
struct height_coloration {
    const planetary_color_scheme& color_scheme;

    template<class Octaform>
    void fill_colors(Octaform& ofo) {
        height_coloration_octasierp(ofo, color_scheme);
    }
};
#+end_src
#+depends:height_coloration :noweb planetary_color_scheme height_coloration_octasierp :cpp array

*** Rendering

This first rendering uses the same parameter as the previous ones, but with height coloration.
#+begin_src cpp :eval no-export :exports both :flags -std=c++20 -Wall -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb grow_octasierp midpoint_elevation height_coloration gfg_color_scheme spherical_repartition render_octasierp thick_lines drawspin :defs graphics.org window.org")>>

int main() {
    std::size_t degree = 3;
    auto mesh = grow_octasierp(
        degree,
        midpoint_elevation{{.init_degree=0, .range=.3}},
        height_coloration{gfg_color_scheme},
        spherical_repartition{}
    );

    render_octasierp(
        {.vertex =
         <<graphics(":noweb model_view_projection_vs :c-string")>>,
         .fragment =
         <<graphics(":noweb color_as_attribute_fs :c-string")>>},
        {.vertices=mesh.vertices, .indexes=mesh.indexes,
         .camlong=6, .camlat=6,
         .screenshot="images/screencaps/gfgocta_deg3_wireframe.png",
         .title="Midpoint-displaced height-colored pseudo-spherical octasierp"},
         thick_lines, drawspin{}
    );
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/gfgocta_deg3_wireframe.png]]
:end:


Since height coloration at degree 3 is not very impressive, the code below renders at degree 8, with triangles instead of wireframe and with better midpoint displacement parameters:
#+begin_src cpp :eval no-export :exports both :flags -std=c++20 -Wall -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb grow_octasierp midpoint_elevation height_coloration gfg_color_scheme spherical_repartition render_octasierp nothing drawspin :defs graphics.org window.org")>>

int main() {
    std::size_t degree = 8;
    auto mesh = grow_octasierp(
        degree,
        midpoint_elevation{{.init_degree=3}},
        height_coloration{gfg_color_scheme},
        spherical_repartition{},
        {.sea_level=.6}
    );

    render_octasierp(
        {.vertex =
         <<graphics(":noweb model_view_projection_vs :c-string")>>,
         .fragment =
         <<graphics(":noweb color_as_attribute_fs :c-string")>>},
        {.vertices=mesh.vertices, .indexes=mesh.indexes,
         .camlong=6, .camlat=6,
         .screenshot="images/screencaps/gfgocta_deg8_triangles.png",
         .title="Midpoint-displaced height-colored pseudo-spherical octasierp"},
        nothing, drawspin{.angle=.005, .axis={0, 1, 1}}
    );
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/gfgocta_deg8_triangles.png]]
:end:


** Phong shading

Phong shading is a way to approximate lighting via 3 components, ambient, diffuse and specular.
An mandatory prerequisite of Phong shading is vertices normals, they must therefore be computed and send to a new shader program implementing Phong shading.

*** Computation of normals

The normals will be directly written to the octaform via =fill_octasierp_normals=.

#+name: fill_octasierp_normals
#+begin_src cpp
namespace yls_normal_computation {
<<yls_normal_computation/scope>>

template<class Octaform>
void fill_octasierp_normals(Octaform& ofo, std::size_t normal_offset) {
    <<fill_octasierp_normals/scope>>
}
} // namespace yls_normal_computation
using yls_normal_computation::fill_octasierp_normals;
#+end_src
#+depends:fill_octasierp_normals :noweb adapt_repr/size_t :cpp array vector glm/glm.hpp

To compute the vertices normals, the first step will be to compute the triangles normals and, for each vertex to record which triangles it is a part of, in an instance of =neighbouring_normals=:
#+begin_src cpp :noweb-ref yls_normal_computation/scope
struct neighbouring_normals {
    std::array<int, 6> indexes = {-1, -1, -1, -1, -1, -1};
    char next = 0;
    void push(auto index) {
        indexes[next++] = index;
    }
};
#+end_src

Triangle normals are computed via a cross product of two of its edges:
#+begin_src cpp :noweb-ref fill_octasierp_normals/scope
std::vector<neighbouring_normals> adjacent(ofo.point_cardinality());

auto position_as_vec3 = [&ofo](auto index) {
    return *reinterpret_cast<glm::vec3*>(ofo.position_ptr(index));
};

auto tricard = ofo.triangle_cardinality();
std::vector<glm::vec3> triangle_normals(tricard);
for(std::size_t i = 0; i < tricard; ++i) {
    auto i3 = 3 * i;
    auto a = ofo.indexes[i3]; auto b = ofo.indexes[i3 + 1]; auto c = ofo.indexes[i3 + 2];
    adjacent[a].push(i); adjacent[b].push(i); adjacent[c].push(i);
    triangle_normals[i] = glm::cross(
        position_as_vec3(b) - position_as_vec3(a),
        position_as_vec3(c) - position_as_vec3(a)
    );
}
#+end_src

The normal of a vertex is implemented here as the normalised sum of the normals of neighbouring triangles:
#+begin_src cpp :noweb-ref fill_octasierp_normals/scope
for(std::size_t i = 0; i < adjacent.size(); ++i) {
    auto dest_ptr = reinterpret_cast<glm::vec3*>(ofo.offset_ptr(i, normal_offset));
    auto neighbours = adjacent[i];
    auto normal = [&](auto index) {return triangle_normals[neighbours.indexes[index]];};
    if(neighbours.indexes[4] == -1) // Initial point (poles and corners).
        *dest_ptr = glm::normalize(normal(0) + normal(1) + normal(2) + normal(3));
    else // 6-neighbours point.
        *dest_ptr = glm::normalize(
            normal(0) + normal(1) + normal(2) +
            normal(3) + normal(4) + normal(5)
        );
}
#+end_src

*** Shaders

This implementation of Phong shading was adapted from the basic lightning page of =learnopengl.com= (https://learnopengl.com/Lighting/Basic-Lighting).

Vertex shader:
#+name: phong_vs
#+begin_src glsl
#version 330 core
layout (location = 0) in vec3 position;
layout (location = 1) in vec3 color;
layout (location = 2) in vec3 normal;

out vec3 position_fs;
out vec3 color_fs;
out vec3 normal_fs;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main() {
    gl_Position = projection * view * model * vec4(position, 1.0f);
    position_fs = vec3(model * vec4(position, 1));
    color_fs = color;
    normal_fs = mat3(transpose(inverse(model))) * normal;
}
#+end_src

Fragment shader:
#+name: phong_fs
#+begin_src glsl
#version 330 core
out vec4 color_out;
in vec3 position_fs;
in vec3 color_fs;
in vec3 normal_fs;

uniform vec3 light_color = vec3(1, 1, 1);
uniform vec3 light_position = vec3(6, 5, -2);
uniform vec3 camera_position;
uniform float ambient_strength = .085;
uniform float specular_strength = .5;
uniform float specular_exponent = 64;

void main() {
    // Ambient.
    vec3 ambient = ambient_strength * light_color;

    // Diffuse.
    vec3 normal = normalize(normal_fs);
    vec3 surface_to_light = normalize(light_position - position_fs);
    float diffuse_brightness = max(dot(normal, surface_to_light), 0);
    vec3 diffuse = diffuse_brightness * light_color;

    // Specular.
    vec3 surface_to_camera = normalize(camera_position - position_fs);
    vec3 reflection_dir = reflect(-surface_to_light, normal);
    float specular_coeff = pow(max(dot(surface_to_camera, reflection_dir), 0), specular_exponent);
    vec3 specular = specular_strength * specular_coeff * light_color;

    color_out = vec4((ambient + diffuse + specular) * color_fs, 1.);
}
#+end_src

*** Rendering

The specular component is much too strong and makes the planet looks like it is made of plastic but I love the shinyness of this effect (it's made more obvious by the rotation so it's not as shocking in the capture below).

#+begin_src cpp :eval no-export :exports both :flags -std=c++20 -Wall -I include -ldl -lGL -lglfw src/glad.c
<<include(":noweb grow_octasierp midpoint_elevation height_coloration gfg_color_scheme spherical_repartition fill_octasierp_normals uniform_3f render_octasierp drawspin :defs graphics.org window.org")>>

int main() {
    std::size_t degree = 8;
    auto mesh = grow_octasierp(
        degree,
        midpoint_elevation{{.init_degree=3}},
        height_coloration{gfg_color_scheme},
        spherical_repartition{},
        {.vertex_size=9, .sea_level=.6}
    );

    fill_octasierp_normals(mesh, 6);
    auto send_camera_position = [](auto& state) {
        auto position = state.camera.position();
        state.unit.template send<uniform_3f>("camera_position", position.x, position.y, position.z);
    };

    render_octasierp(
        {.vertex =
         <<include(":noweb phong_vs :c-string")>>,
         .fragment =
         <<include(":noweb phong_fs :c-string")>>},
        {.vertices=mesh.vertices, .layout={3, 3, 3}, .indexes=mesh.indexes,
         .camlong=6, .camlat=6,
         .screenshot="images/screencaps/gfgocta_phong.png",
         .title="Midpoint-displaced height-colored pseudo-spherical Phong-shaded octasierp"},
        send_camera_position, drawspin{.angle=.005, .axis={0, 1, 1}}
    );
}
#+end_src

#+RESULTS:
:results:
[[file:images/screencaps/gfgocta_phong.png]]
:end:


* Diagrams generation

The diagrams are generated in python, using Gizeh for the geometry and =moviepy= for stiching images together into animations, inspired by this [[http://zulko.github.io/blog/2014/09/20/vector-animations-with-python/][blogpost]].

They can be installed via pip:
#+begin_src bash :eval never :minipage
pip install --user gizeh moviepy
#+end_src


Images are saved in the =images= folder and the scripts are supposed to be executed (that is to say after they have been tangled) from the root of the project like so:
#+begin_src bash :minipage
./script/your-favorite-script.sh
#+end_src

** Colors
:PROPERTIES:
:header-args:python+: :noweb-ref "Colors"
:END:

I use a =SimpleNamespace= to store some colors that I want to use (the names are probably innacurate).
The obvious alternative would be to use a =class= but that would be tedious to initialize, or a =dict= but I want to be able to access members through the dot operator.

#+begin_src python :minipage
from types import SimpleNamespace
colors = SimpleNamespace(
    canard=(0, .6, .6),
    turquoise=(0, 1, 1),
    orange=(1, .5, 0),
    mandarine=(1, .8, 0),
    purple=(.4, 0, .4),
    violet=(.6, .2, .6),
    black=(0, 0, 0),
    evergrey=(.5, .5, .5),
    white=(1, 1, 1),
    forest=(0, .4, 0),
    grass=(0, .6, .2),
    ocean=(0, .2, .8),
    river=(0, .4, .8),
    air=(0, 0, 0, 0)
)
#+end_src

Here are some color palettes:

#+begin_src python :minipage
palette_colorful = [
    (colors.canard, colors.turquoise),
    (colors.purple, colors.violet),
    (colors.orange, colors.mandarine),
    (colors.black, colors.white),
    (colors.black, colors.white)
]
palette_gfg = [
    (colors.white, colors.canard),
    (colors.canard, colors.purple),
    (colors.purple, colors.orange),
    (colors.orange, colors.black),
    (colors.black, colors.white)
]
palette_gfgpoints = [
    (colors.air, colors.canard),
    (colors.air, colors.purple),
    (colors.air, colors.orange),
    (colors.air, colors.evergrey),
    (colors.air, colors.air),
    (colors.air, colors.canard)
]
palette_psyche = [
    (colors.canard, colors.white),
    (colors.orange, colors.white),
    (colors.purple, colors.white),
    (colors.black, colors.white),
    (colors.black, colors.white),
]
#+end_src


** Basic =Geometry=
:PROPERTIES:
:header-args:python+: :noweb-ref "Geometric primitives"
:END:

The class =Geometry= is here to provide an abstraction about the way a subdivided object is to be drawn.
For the moment, geometric primitives only have two caracteristics at a given degree of subdivision :
 - their color as a tuple of three or four floats =(r, g, b)= or =(r, g, b, a)=, and
 - their size as a factor by which to multiply a reference size.

Thus, =Geometry= is initialised with:
 - A color palette (a list of colors).
 - A size policy (a function  $f : \mathbb{N} \rightarrow \mathbb{R}^+$ associating a subdivision degree to a desired size).

The geometry parameters for degree $d$ can then simply be obtained with square brackets indexing (like =geometry[d]=), thanks to the method =__getitem__=.

#+begin_src python :minipage
class Geometry(object):
    def __init__(self,
                 degree,
                 color_palette=[(0, 0, 0)],
                 size_policy=None
    ):
        self.color_palette = color_palette
        if size_policy is None:
            self.size_policy = decrease_size_linearly(degree)
        else:
            self.size_policy = size_policy

    def __getitem__(self, current):
        return self.color_palette[current % len(self.color_palette)],\
            self.size_policy(current)
#+end_src

*** Decrease size linearly

The default element size policy is to decrease the size of a primitive linearly with the degree of subdivision.
Thus, the aim of this policy is to provide a factor $factor_{current}$ by which to multiply an initial size such that $1 \geq factor_{current} \geq minFactor$, where $current$ is the current degree of subdivision.

We know that $factor_0 = 1$ and $factor_{degree} = minFactor$.
Since we want to decrease the size linearly, we also know that $factor_{current} = a \times current + b$, thus

\begin{equation*}
  \begin{cases}
    a \times 0 + b = 1 & \Leftrightarrow b = 1\\
    a \times degree + b = minFactor & \Leftrightarrow a = \frac{minFactor -1}{degree}
  \end{cases}
\end{equation*}

We finally obtain the function $factor_{current} = \frac{minFactor - 1}{degree} \times current + 1$.
This function is not defined when $degree = 0$ so this needs to be addressed as a special case.

After playing a bit with the $minFactor$ value, it looks like .25 is a good value.

#+begin_src python :minipage
def decrease_size_linearly(degree, min_factor=.25, scale=1):
    def result(current):
        if degree == 0:
            return 1
        return (current * (min_factor - 1) / degree + 1) * scale
    return result
#+end_src

I added a =scale= parameter to easily be able to make things bigger while keeping the linear relationship between degrees.


** Triangle
:PROPERTIES:
:header-args:python+: :eval never
:END:

A =Triangle= represents one of the triangles of an octasierp net, its properties are:
#+attr_latex: :float left :center nil
| -- =degree=:          | The degree of subdivision.                              |
| -- =initial_width=:   | The width of the first element.                         |
| -- =points_geometry=: | =Geometry= object describing how points are to be drawn |
| -- =lines_geometry=:  | =Geometry= object describing how lines are to be drawn  |

A =Triangle= has no coordinates of its own because the coordinates of its constituent points will be used in =generate=, whose role is to create a Gizeh object representing the geometry of the triangle, whereas =geometry= does the recursive calculations regarding all the points and lines of the final figure.
In =__init__=, a value of =0= is used to represent the default geometry which is a color palette of black and a size policy of linear decrease.
=None= is not used because it means to not draw anything.

#+begin_src python :noweb-ref "Triangle"
import gizeh as gz

<<Geometric primitives>>

class Triangle(object):
    def __init__(self, degree, initial_width, points_geometry=0, lines_geometry=0, background_color=None):
        self.degree = degree
        self.initial_width = initial_width
        if points_geometry == 0:
            self.points_geometry = Geometry(degree)
        else:
            self.points_geometry = points_geometry
        if lines_geometry == 0:
            self.lines_geometry = Geometry(degree)
        else:
            self.lines_geometry = lines_geometry
        self.background_color = background_color

    def generate(self, a, b, c):
        points, lines = self.geometry(a, b, c)
        if self.background_color is not None:
            lines.insert(0, self.make_background(a, b, c))
        return gz.Group(lines + points)

    def geometry(self, a, b, c, current=0):
        lines = self.make_lines(a, b, c, current)
        points = self.make_points(a, b, c, current)
        <<Subdivise triangle>>

    <<Triangle/>>
#+end_src

*** Lines, points and background generation

The lines characteristics at a given level are deduced from the dedicated geometry object:
#+begin_src python :noweb-ref Triangle/ :minipage
def make_lines(self, a, b, c, current):
    if self.lines_geometry is None:
        return []
    color, factor = self.lines_geometry[current]
    width = max(1, self.initial_width * factor)
    return [gz.polyline(
        [a, b, c],
        close_path=True,
        stroke_width=width,
        stroke=color
    )]
#+end_src

A similar approach is done for points, with two differences:
 1. They are scaled a bit ($\times 1.2$) because they are used to hide the corners of lines.
 2. They are generated via translation.
#+begin_src python :noweb-ref Triangle/ :minipage
def make_points(self, a, b, c, current):
    if self.points_geometry is None:
        return []
    color, factor = self.points_geometry[current]
    width = max(1, self.initial_width * factor * 1.2)
    point = gz.circle(r=width, fill=color)
    return list(map(point.translate, (a, b, c)))
#+end_src

Background generation is similar to lines generation, except that the lines are drawn and the fill color is set to =background_color=.
#+begin_src python :noweb-ref Triangle/ :minipage
def make_background(self, a, b, c):
    return gz.polyline(
        [a, b, c],
        close_path=True,
        stroke_width=0,
        fill=self.background_color
    )
#+end_src

*** Subdivise triangle
:PROPERTIES:
:header-args:python+: :noweb-ref "Subdivise triangle"
:END:

Now that the geometric elements have been dealt with, only the recursive calls - or lack thereof - remains.
The generation is over when the maximal degree has been reached:
#+begin_src python :minipage
if current == self.degree:
    return points, lines
#+end_src

Otherwise, we make recursive calls to =geometry=, using the midpoints of the three original points.
The order of the points and of the lines is important because the graphical elements are drawn in the order of their apparition and we want to make sure that the earliest subdivisions are drawn over the subsequent ones.
#+begin_src python :minipage
ab = midpoint(a, b)
ac = midpoint(a, c)
bc = midpoint(b, c)
for sierpinski in [(a, ab, ac), (b, ab, bc), (c, ac, bc), (ab, ac, bc)]:
    recurse_points, recurse_lines = self.geometry(*sierpinski, current + 1)
    lines = recurse_lines + lines # order is important
    points = recurse_points + points
return points, lines
#+end_src

With =midpoint= being defined as:
#+begin_src python :noweb-ref "Triangle" :minipage
def midpoint(left, right):
    return ((left[0] + right[0]) / 2, (left[1] + right[1]) / 2)
#+end_src


** Octasierp net

=Octanet= represent the net of an octasierp through its evolution from an octahedron to a quasi-squaregrid.
This evolution will be tracked through a =progress= parameter:
 - When $progress = 0$, it is octahedron net shaped.
 - When $progress = 1$, it is quasi-squaregrid shaped.
 - When $0 < progress < 1$, its shape is deduced by interpolating the value of the central angle.

Below is the basic structure of this class and its dependencies.
The sections below will fill the missing parts in =<<Before Octanet>>= and =<<Octanet/>>=.

#+name: Octanet
#+begin_src python :minipage
<<Triangle>>
<<Colors>>

import math

<<Before Octanet>>

class Octanet(object):
    <<Octanet/>>
#+end_src

*** Computations independant of progress

Everything that does not depend on =progress= is computed in =__init__=:
#+begin_src python :noweb-ref Octanet/
def __init__(
        self, scale, degree=0, points_geometry=0, lines_geometry=0,
        triangle_background=None, surface_parameters={}
):
    self.degree = degree
    self.side = int(50 * scale) # Bugs may arise at very low scale.
    stroke_width = scale
    horizontal_margin = int(5 * scale)
    vertical_margin = int(15 * scale)

    altitude = math.sqrt(3) * (self.side / 2)
    width = int(4 * altitude)
    height = 2 * self.side
    left = horizontal_margin
    right = width + horizontal_margin
    bottom = height + vertical_margin

    self.x_ab = (left + right) /2
    self.y_a = bottom - self.side / 2
    self.y_b = bottom - self.side * 1.5

    self.surface_parameters = {
        'width': width + 2 * horizontal_margin,
        'height': height + 2 * vertical_margin,
        'bg_color': (1, 1, 1)
    }
    self.surface_parameters.update(surface_parameters)

    triangle = Triangle(
        degree, stroke_width,
        points_geometry=points_geometry, lines_geometry=lines_geometry,
        background_color=triangle_background
    )
    self.triangles = triangle.generate
#+end_src

*** Net construction according to progress

=make_net= uses basic trigonometry to compute the coordinate of the first quarter at the desired =progress= value.
This quarter is then cloned and rotated three times to form the complete figure.

#+begin_src python :noweb-ref Octanet/
def make_net(self, progress):
    vertical_correction = progress * self.side / 2
    angle = math.pi / 3 + progress * (math.pi / 6)

    y_a = self.y_a - vertical_correction
    y_b = self.y_b - vertical_correction
    a = (self.x_ab, y_a)
    b = (self.x_ab, y_b)

    cosa = math.cos(angle)
    sina = math.sin(angle)

    x_c = -sina * (y_b - y_a) + self.x_ab
    y_c = cosa * (y_b - y_a) + y_a
    c = (x_c, y_c)

    t1 = self.triangles(a, b, c)
    twin_point = ((self.x_ab + x_c) / 2, (y_b + y_c) / 2)
    t2 = t1.rotate(math.pi, twin_point)

    first_quarter = gz.Group([t1, t2])
    second_quarter = first_quarter.rotate(-angle, a)
    third_quarter = first_quarter.rotate(-2 * angle, a)
    fourth_quarter = first_quarter.rotate(angle, a)

    return gz.Group([first_quarter, second_quarter, third_quarter, fourth_quarter])
#+end_src

*** Surface creation and export

=draw= creates a Gizeh surface, draws the =Octanet= on it and returns it.
This Gizeh surface can be manipulated directly, or can be directly saved to a png.
#+begin_src python :noweb-ref Octanet/ :minipage
def draw(self, progress=0):
    surface = gz.Surface(**self.surface_parameters)
    self.make_net(progress).draw(surface)
    return surface

def write_to_png(self, filename, progress=0):
    self.draw(progress).write_to_png(filename)
#+end_src

Writing to svg requires a different surface, not given directly by Gizeh.
#+begin_src python :noweb-ref Octanet/ :minipage
def write_to_svg(self, filename, progress=0):
    surface = SVGSurface(filename, **self.surface_parameters)
    self.make_net(progress).draw(surface)
    surface.finish()
#+end_src

Below is defined the surface in question.
This is almost copy-pasted from Gizeh's own =PDFSurface=.
#+begin_src python :noweb-ref "Before Octanet" :minipage
import cairocffi as cairo
class SVGSurface(object):
    def __init__(self, filename, width, height, bg_color=None):
        self.width = width
        self.height = height
        self._cairo_surface = cairo.SVGSurface(filename, width, height)
        if bg_color is not None:
            gz.rectangle(2 * width, 2 * height, fill=bg_color).draw(self)

    def get_new_context(self):
        return cairo.Context(self._cairo_surface)

    def flush(self):
        self._cairo_surface.flush()

    def finish(self):
        self._cairo_surface.finish()
#+end_src


** Illustration: degrees 0 through 3

We use the =Octanet= class defined above to create the 8 images corresponding to the degrees 0 through 3 of the octahedron and the quasi-square version:
#+begin_src python :tangle script/octasierp_net_0-3.py :eval no-export :minipage
<<Octanet>>

for degree in range(4):
    net = Octanet(scale=10, degree=degree)
    net.write_to_png('net_octa_degree_{}.png'.format(degree), 0)
    net.write_to_png('net_squa_degree_{}.png'.format(degree), 1)
#+end_src

The code above is then called by a bash script who annotates and stitches the images together with imagemagick's =mogrify= and =montage=:
#+begin_src bash :tangle script/illustration_0_through_3.sh :shebang "#!/usr/bin/env bash" :eval no-export :results silent :minipage
python3 script/octasierp_net_0-3.py

function make_montage(){
    base=net_${version}_degree_

    for degree in 0 1 2 3
    do
        mogrify -size 600x400 -pointsize 60\
                -annotate +770+$vertical "degree = $degree"\
                $base$degree.png
    done

    montage ${base}{0,1,2,3}.png -geometry 600x400 images/montage_${base}0-3.png
    # -background none
    rm ${base}{0,1,2,3}.png
}

mkdir -p images

version=octa
vertical=1165
make_montage

version=squa
vertical=1250
make_montage
#+end_src


** Logo creation

Yliss's logo is an octasierp net at degree 3 with big colorful points and no lines.
To achieve the big points, =decrease_size_linearly= is scaled 3 times and is slightly abused by initialising it with a degree of 4.
This makes the linear size decrease slightly less prononced.

#+name: Yliss logo definition
#+begin_src python :tangle script/animations.py :minipage
<<Octanet>>

degree = 3
light=[colors.canard, colors.purple, colors.orange, colors.evergrey]
colorful_oversized = Geometry(
    degree,
    color_palette=light,
    size_policy=decrease_size_linearly(degree=4, scale=3)
)
yliss_logo = Octanet(
    scale=10, degree=degree,
    lines_geometry=None,
    points_geometry=colorful_oversized,
    triangle_background=colors.black,
    surface_parameters={'bg_color': colors.air}
)
#+end_src

The definition above is reused to generate the proper logo, in its octahedral shape but also its quasi-squaregrid equivalent.
#+begin_src python :results silent :eval no-export :minipage
<<Yliss logo definition>>
yliss_logo.write_to_svg('images/octahedron_logo.svg', 0)
yliss_logo.write_to_svg('images/square_logo.svg', 1)
yliss_logo.write_to_png('images/octahedron_logo.png', 0)
yliss_logo.write_to_png('images/square_logo.png', 1)
#+end_src

#+caption: Octahedron net
[[file:images/octahedron_logo.png]]

#+caption: Octahedron as quasi square
[[file:images/square_logo.png]]

The logos are generated in svg and png.
I originally planned to use the svg version since it is scalable but I went against it because I felt it was too big:
#+begin_src bash :exports both :eval yes :wrap "src text :minipage" :minipage
du -sh images/{octahedron,square}_logo.{svg,png} | sort -rh
#+end_src

#+RESULTS:
#+begin_src text :minipage
776K	images/octahedron_logo.svg
640K	images/square_logo.svg
200K	images/octahedron_logo.png
100K	images/square_logo.png
#+end_src

Finally, using the same logo definition, an animation from octahedron to quasi-squarenet is stitched together:

#+begin_src python :results silent :eval no-export
<<Yliss logo definition>>

animation_duration = 1.5
freeze_duration = .5
total_duration = animation_duration + freeze_duration
fps = 30
def generate_frame(time):
    return yliss_logo.draw(time / animation_duration).get_npimage()

from multiprocessing import Pool
pool = Pool()

import numpy as np
frames = list(pool.map(
    generate_frame,
    np.linspace(0, animation_duration, int(fps * animation_duration))
))
pool.close()
pool.join()

idx = 0
def next_frame(_):
    global idx
    idx += 1
    return frames[idx - 1] if idx <= len(frames) else frames[-1]

from moviepy.editor import VideoClip
clip = VideoClip(next_frame, duration=total_duration)
clip.write_videofile('images/net_to_square_degree{}.mp4'.format(degree), fps=fps)
#+end_src


* Textual representation
:PROPERTIES:
:CUSTOM_ID: textual_quarter
:header-args:python+: :eval never
:END:


This section contains the implementation of the class used to produce the various ASCII-style representations of squarified-net quarters.
Here is a breakdown of the arguments accepted by Quarter's init:
 - =degree= is the degree of subdivision.
 - =appearance= is the degree of appearance to eventually display.
 - =quarter= is the index of the quarter (between 1 and 4).
 - =display_redundant= commands how redundant points should be shown in the representation.
 - =display_point= contains points representations for each degree.
   The last representation will be repeated through if the list is too short.

The inclusion of =appearance= in the arguments means that only points appearing at the degree =appearance= are included in the representation.
I'll explain later how to make a representation including all the points or only the points in a given list.

#+name: Textual quarter
#+begin_src python :noweb no-export :minipage
<<Textual quarter dependencies>>
<<Textual quarter utils>>

class Quarter:
    <<Textual quarter constants>>

    def __init__(
            self, degree, appearance=None, quarter=0,
            display_redundant=False, display_points=['x']
    ):
        self.degree = degree
        self.appearance = appearance
        self.quarter = quarter % 4
        self.display_redundant = display_redundant
        self.display_points = display_points
        self.valid_points = Quarter.IS_POINT | set(self.display_points)

        <<Textual quarter init>>

    <<Textual quarter methods>>

<<Textual quarter helper functions>>
#+end_src

** Character set

The character set used to describe a quarter is not supposed to be changed, that's why it is defined at the class level.
#+begin_src python :noweb-ref "Textual quarter constants" :minipage
HORIZONTAL = '-'
EMPTY = ' '
VERTICAL = '|'
CORNER = '+'
COLLISION = 'E'
REDUNDANT = 'v'
NORTH_POLE_POINT = 'X'
NORTH_POLE = 'o'
#+end_src
=CORNER= is not a great name because it already means the 4 corners of the world of an octasierp but here it is the litteral corners of one quarter (two of which happen to be corners in the octasierp sense).

We also define the set of character that can collide and the set of character that are a point.
They are complementary in the sense that their intersection is empty and their union is the whole character set.
#+begin_src python :noweb-ref "Textual quarter constants" :minipage
CAN_COLLIDE = {
    HORIZONTAL, EMPTY, VERTICAL,
    CORNER, NORTH_POLE
}
IS_POINT = {COLLISION, REDUNDANT, NORTH_POLE_POINT}
#+end_src

We want the caller to be able to select the redundant character.
This is done based on the value of =display_redundant= ; any value other than =True= will be interpreted as the an attempt to override the default redundant character.
#+begin_src python :noweb-ref "Textual quarter init" :minipage
if self.display_redundant is True:
    self.redundant = Quarter.REDUNDANT
elif self.display_redundant is not False:
    self.redundant = self.display_redundant
    self.valid_points.add(self.redundant)
#+end_src

Every degree of appearance must have its representation:
#+begin_src python :noweb-ref "Textual quarter init" :minipage
if self.appearance is None:
    max_appearance = 0
elif type(self.appearance) is int:
    max_appearance = self.appearance
elif type(self.appearance) is list:
    max_appearance = max(self.appearance)
else:
    raise TypeError('Unexpected appearance type: ' + type(self.appearance))

if len(self.display_points) < max_appearance + 1:
    self.display_points += self.display_points[-1:] * (max_appearance + 1 - len(self.display_points))
#+end_src


** Generate a raw representation

This method is the core of the text representation logic.
Its role is to create a string where every character except =\n= maps to the real corresponding point.
It should not be called by an end user, as it still needs to be prettyfied and it has its own =appearance= argument which restricts the representation to one specific degree of appearance.
The assembly steps required will be the subject of the next sections.

With that being said, this method is a perfect example of why designing code using (poorly) observed artifacts rather than carefully deduced knowledge will result in a terrible unmaintanable mess.
But hey, it works.

In retrospect, it would have been much better to start from the central point since it is obviously a center of symmetry.
Even with that in mind, I will not bother redesigning the code below because once again hey, it works^{tm}.
If you don't understand how this code works, don't worry, neither do I.
#+begin_src python :noweb-ref "Textual quarter methods" :minipage
def raw(self, appearance=None):
    # Length of the sides.
    length = pow(2, self.degree) + 1

    # Special case without points.
    if appearance is None:
        tb_common = Quarter.HORIZONTAL * (length - 2)\
            + Quarter.CORNER
        top = Quarter.CORNER + tb_common
        bottom = Quarter.NORTH_POLE + tb_common
        emptyline = Quarter.VERTICAL + Quarter.EMPTY * (length - 2)\
            + Quarter.VERTICAL
        return [top] + [emptyline] * (length - 2) + [bottom]

    # Special case with corner points.
    if appearance == 0:
        if self.quarter == 0:
            topright = self.display_points[appearance] # Technically south pole
            bottomleft = Quarter.NORTH_POLE_POINT
        else:
            bottomleft = Quarter.NORTH_POLE
            if self.display_redundant:
                topright = self.redundant
            else:
                topright = Quarter.CORNER
        top = Quarter.CORNER + Quarter.HORIZONTAL * (length - 2) + topright
        bottom = bottomleft\
            + Quarter.HORIZONTAL * (length - 2) + self.display_points[appearance]
        emptyline = Quarter.VERTICAL + Quarter.EMPTY * (length - 2)\
            + Quarter.VERTICAL
        return [top] + [emptyline] * (length - 2) + [bottom]

    # Number of points in odd and even lines.
    npoints_even = pow(2, appearance - 1)
    npoints_odd = pow(2, appearance) - 1

    # Number of spaces separating points in the middle
    # for odd and even lines.
    nspaces_odd = pow(2, self.degree - appearance) - 1
    nspaces_even = 2 * nspaces_odd + 1

    # Number of even lines.
    nlines_even = pow(2, appearance - 1) - 1

    # Construct composite strings.
    small_horizontal = Quarter.HORIZONTAL * nspaces_odd
    big_horizontal = Quarter.HORIZONTAL * nspaces_even
    small_empty = Quarter.EMPTY * nspaces_odd
    big_empty = Quarter.EMPTY * nspaces_even

    # Build lines.
    right_vertical = self.redundant if self.display_redundant else Quarter.VERTICAL
    tb_common = small_horizontal\
        + big_horizontal.join([self.display_points[appearance]] * npoints_even)\
        + small_horizontal + Quarter.CORNER
    top = Quarter.CORNER + tb_common
    bottom = Quarter.NORTH_POLE + tb_common
    emptylines = [
        Quarter.VERTICAL + Quarter.EMPTY * (length - 2) + Quarter.VERTICAL
    ] * nspaces_odd
    oddline = Quarter.VERTICAL + small_empty\
        + small_empty.join([self.display_points[appearance]] * npoints_odd)\
        + small_empty + right_vertical
    evenline = Quarter.VERTICAL + small_empty\
        + big_empty.join([self.display_points[appearance]] * npoints_even)\
        + small_empty + Quarter.VERTICAL

    # Assemble the quarter this is like str.join but with list
    fulllines = [top] + ([oddline, evenline]) * nlines_even\
        + [oddline, bottom]
    def joinlines():
        it = iter(fulllines)
        yield next(it)
        for el in it:
            for empty in emptylines:
                yield empty
            yield el

    return list(joinlines())
#+end_src


** Generate the final representation

Here are handled the forementioned assembly steps, in the following method:
#+begin_src python :noweb no-export :noweb-ref "Textual quarter methods" :minipage
def repr(self):
    <<Assemble the degrees of appearance>>
    <<Rotate the quarter>>
    <<Apply horizontal compensation>>
#+end_src

The =Quarter= class is represented as a list of lines.
To put icing on the cake, we also handle a string version of the representation:
#+begin_src python :noweb-ref "Textual quarter methods" :minipage
def __str__(self):
    return '\n'.join(self.repr())
#+end_src

=__str__= is a magic method that is called when a =str= conversion is applied by Python.
Since a =str= conversion is automatically applied in code when =print= is called, code like src_python[:exports code]{print(quarter0)} will be enough to print the representation, which is great syntactic sugar in my opinion.

*** Assemble the degrees of appearance

When dealing with a list of degrees of appearance, they are merged together.
#+name: Assemble the degrees of appearance
#+begin_src python :minipage
if type(self.appearance) is list:
    assert len(self.appearance) > 0
    assembly = self.raw(self.appearance[0])
    for appearance in self.appearance[1:]:
        assembly = self.merge_raw_quarters(
            assembly,
            self.raw(appearance),
            self.valid_points
        )
else:
    assembly = self.raw(self.appearance)
#+end_src

To implement =merge_raw_quarters=, we first need to be able to merge two lines together.
With this textual representation, we just have to iterate through the two lines simultaneously and prioritise the point character above every other.
I also output a collision character when two points collide, because that would mean either a repetition in =appearance= or a mistake in =merge_quarter_lines= and I want both failures to be obvious.

#+begin_src python :noweb-ref "Textual quarter utils" :minipage
def merge_quarter_lines(left, right, valid_points):
    buffer = []
    for cleft, cright in zip(left, right):
        if cright in valid_points:
            if cleft in Quarter.CAN_COLLIDE:
                buffer += cright
            else:
                buffer += Quarter.COLLISION
        else:
            buffer += cleft
    return ''.join(buffer)
#+end_src

The actual merging method simply uses =merge_quarter_lines= to merge every line into a new list:
#+begin_src python :noweb-ref "Textual quarter methods" :minipage
def merge_raw_quarters(self, left, right, valid_points):
    return list(merge_quarter_lines(l, r, valid_points) for l, r in zip(left, right))
#+end_src

Because =reduce= is no longer a primitive in Python3, it must be imported:
#+begin_src python :noweb-ref "Textual quarter dependencies" :minipage
from functools import reduce
#+end_src

*** Rotate the quarter

To put the quarter into the right orientation, we do =quarter= left rotations.
It would be faster, for example, to do one right rotation when =quarter == 3= but there is no need for optimisation right now.
#+name: Rotate the quarter
#+begin_src python :minipage
for _ in range(self.quarter):
    assembly = rotate_quarter_representation_left(assembly)
#+end_src

Rotating the representation left is a succession of two tricks:
 1. Replacing vertical characters with horizontal ones and /vice versa/.
 2. Replacing lines with columns, in inverse order (that's what =reversed(list(zip(*lines)))= does).
#+begin_src python :noweb-ref "Textual quarter utils" :minipage
def rotate_quarter_representation_left(lines):
    replacement = {Quarter.HORIZONTAL: Quarter.VERTICAL,
                   Quarter.VERTICAL: Quarter.HORIZONTAL}
    def replace(sequence):
        return ''.join(
            replacement[char] if char in replacement
            else char
            for char in sequence
        )
    return [newline for newline in map(replace, reversed(list(zip(*lines))))]
#+end_src

*** Apply horizontal compensation

Applying horizontal compensation is a must because vertical text space is roughly twice as big as horizontal text space, so the representation is excessively vertical:
#+begin_src python :eval no-export :exports both :minipage
<<Textual quarter>>
print('\n'.join(Quarter(2).raw(2)))
#+end_src

#+RESULTS:
#+begin_src text :minipage
+x-x+
|xxx|
|x x|
|xxx|
ox-x+
#+end_src

Horizontal compensation is the last step to produce the final representation so we are ready to return:
#+name: Apply horizontal compensation
#+begin_src python :minipage
return horizontal_compensation(assembly)
#+end_src


The horizontal compensation function simply pads the top and bottom lines with horizontal characters and the other lines with empty characters.
#+begin_src python :noweb-ref "Textual quarter utils" :minipage
def horizontal_compensation(lines):
    buffer = [Quarter.HORIZONTAL.join(lines[0])]       # Top.
    for line in lines[1:-1]:
        buffer.append(Quarter.EMPTY.join(line))        # Others.
    buffer.append(Quarter.HORIZONTAL.join(lines[-1]))  # Bottom.
    return buffer
#+end_src

Now the text representation looks much better:
#+begin_src python :eval no-export :exports both :minipage
<<Textual quarter>>
print('\n'.join(horizontal_compensation(Quarter(2).raw(2))))
#+end_src

#+RESULTS:
#+begin_src text :minipage
+-x---x-+
| x x x |
| x   x |
| x x x |
o-x---x-+
#+end_src


** Demonstration
:PROPERTIES:
:header-args:python+: :exports both :eval no-export
:END:

#+begin_src python :exports both :minipage
<<Textual quarter>>
for degree in range(2, 5):
    print(Quarter(degree=degree, appearance=2, quarter=0))
#+end_src

#+RESULTS:
#+begin_src text :minipage
+-x---x-+
| x x x |
| x   x |
| x x x |
o-x---x-+
+---x-------x---+
|               |
|   x   x   x   |
|               |
|   x       x   |
|               |
|   x   x   x   |
|               |
o---x-------x---+
+-------x---------------x-------+
|                               |
|                               |
|                               |
|       x       x       x       |
|                               |
|                               |
|                               |
|       x               x       |
|                               |
|                               |
|                               |
|       x       x       x       |
|                               |
|                               |
|                               |
o-------x---------------x-------+
#+end_src


** Textual squarified net representation

Textual representation of a squarified octasierp net is generated with the  =SquareNet= class.
Most of the work has already been done in =Quarter= so the arguments are the same, except for:
 - =quarter= which becomes =quarters=, illustrating that what's left to be done is to assemble the four quarters together.
 - =show_axis= is a specific argument to include the axis and their gradation in the final representation.
 - =point_rep= associates a quarter to a point representation.

The caller can choose to represent only a subset of the quarter by specifying for example src_python[:exports code]{SquareNet(degree, appearance, quarters={0,1})} to include only quarters 0 and 1.
The excluded quarters will be represented devoid of points.

#+name: Textual squarified net
#+begin_src python :minipage
<<Textual quarter>>
<<SquareNet utils>>
class SquareNet:
    def __init__(
            self, degree, appearance=None, quarters={0, 1, 2, 3},
            display_redundant=False, show_axis=False, point_rep=lambda quarter: ['x']
    ):
        self.degree = degree
        self.appearance = appearance
        self.quarters = [Quarter(
            degree=degree,
            appearance=appearance if n in quarters else None,
            quarter=n,
            display_redundant=display_redundant,
            display_points=point_rep(n)
        ) for n in range(4)]
        self.show_axis = show_axis

    <<Final squarified net representation>>
#+end_src

*** Vertical and horizontal contatenation

To generate the final representation, we have to first concatenate horizontally quarter 0 with quarter 1 and quarter 2 with quarter 3.
Then only one vertical concatenation on the results of those two previous concatenations remain to be done.
Like with =Quarter=, =repr= returns a list of lines:
#+begin_src python :noweb-ref "Final squarified net representation" :minipage
def repr(self):
    valid_points_top = self.quarters[1].valid_points | self.quarters[0].valid_points
    top = cat_quarter_horizontally(
        self.quarters[1].repr(),
        self.quarters[0].repr(),
        valid_points_top
    )

    valid_points_bottom = self.quarters[2].valid_points | self.quarters[3].valid_points
    bottom = cat_quarter_horizontally(
        self.quarters[2].repr(),
        self.quarters[3].repr(),
        valid_points_bottom
    )

    result = cat_quarter_vertically(top, bottom, valid_points_top | valid_points_bottom)
    if self.show_axis:
        <<Add axis to SquareNet representation>>
    return result
#+end_src

And =__str__=, the string equivalent:
#+begin_src python :noweb-ref "Final squarified net representation" :minipage
def __str__(self):
    return '\n'.join(self.repr())
#+end_src

The vertical concatenation is the easiest ; since the representation is a list of lines, all lines are concatenated, except the central one (the one in common between the two quarters), which is merged:
#+begin_src python :noweb-ref "SquareNet utils" :minipage
def cat_quarter_vertically(top, bottom, valid_points):
    return top[:-1] + [merge_quarter_lines(top[-1], bottom[0], valid_points)] + bottom[1:]
#+end_src

The horizontal concatenation is a little bit longer because it goes against our vertically-oriented representation.
It's not that complicated because =merge_quarter_lines= can merge columns as well as lines:
#+begin_src python :noweb-ref "SquareNet utils" :minipage
def cat_quarter_horizontally(left, right, valid_points):
    right_of_left = [line[-1] for line in left]
    left_of_right = [line[0] for line in right]
    merged_column = merge_quarter_lines(right_of_left, left_of_right, valid_points)
    return [
        l[:-1] + merged_column[i] + r[1:]
        for i, (l, r) in enumerate(zip(left, right))
    ]
#+end_src

We can now represent for example the last points of all quarters of a squarified net of degree 2, with the redundant points:
#+begin_src python :eval no-export :exports both :minipage
<<Textual squarified net>>
print(SquareNet(2, 2, quarters={0, 1, 2, 3}, display_redundant=True))
#+end_src

#+RESULTS:
#+begin_src text :minipage
+-v---v-+-x---x-+
x x x x x x x x v
| x   x | x   x |
x x x x x x x x v
+-x---x-o-x---x-+
v x x x x x x x x
| x   x | x   x |
v x x x x x x x x
+-x---x-+-v---v-+
#+end_src

*** Add axis to representation
:PROPERTIES:
:header-args:python+: :noweb-ref "Add axis to SquareNet representation"
:END:

First of all we create the gradations with the help of =lenhalf=, the length of strictly positive (and strictly negative) values on the gradations.
For example the =gradations= of a squarified net of degree 2 will be =[-4, -3, -2, -1, 0, 1, 2, 3, 4]= and =lenhalf= will be =4=.
#+begin_src python :minipage
lenhalf = len(top) - 1
gradations = list(range(lenhalf, 0, -1))
gradations = list(map(str, gradations + [0] + list(reversed(gradations))))
#+end_src

The left axis is split into three part:
 1. The axis proper.
 2. The gradation.
 3. The legend (plus and minus signs).
#+begin_src python :minipage
leftax = '^|' + '|' * len(result)
leftgrad = ' ' + ''.join(reversed(gradations))
leftleg = ' ' + '+' * lenhalf + ' ' + '-' * lenhalf
#+end_src

Same thing for the bottom axis:
#+begin_src python :minipage
bottomax = '   +' + '--' * len(result) + '-->'
bottomgrad = '      ' + ' '.join(gradations)
bottomleg = '      ' + '- ' * lenhalf + ' ' + ' +' * lenhalf
#+end_src

Finally we modify the =result= by first inserting the left axis into each line and then appending the bottom axis to it.
#+begin_src python :minipage
result = [
    leg + grad + ' ' + ax + '  ' + line
    for leg, grad, ax, line in zip(
            leftleg, leftgrad, leftax, [''] + result
    )
] + [bottomax, bottomgrad, bottomleg]
# Remove extraneous space, I can't bear the thought.
result[0] = result[0].rstrip(' ')
#+end_src


Demonstration time:
#+begin_src python :eval no-export :exports both :noweb-ref no :minipage
<<Textual squarified net>>
print(SquareNet(2, [0, 2], show_axis=True))
#+end_src

#+RESULTS:
#+begin_src text :minipage
   ^
+4 |  +-------x-x---x-x
+3 |  x x x x x x x x |
+2 |  | x   x | x   x |
+1 |  x x x x x x x x |
 0 |  x-x---x-X-x---x-x
-1 |  | x x x x x x x x
-2 |  | x   x | x   x |
-3 |  | x x x x x x x x
-4 |  +-x---x-x-------+
   +-------------------->
      4 3 2 1 0 1 2 3 4
      - - - -   + + + +
#+end_src

Note that this representation will break if we ever try to include gradations greater than 9, because it assumes that gradations are single-digit numbers.
The last degree for which a correct axis can be made is therefore degree 3 with its gradations going from -8 to 8.
It would be possible to make it work with higher degrees but degree 3 covers my needs regarding this feature.


** Utils

Utilities dedicated to help with the manipulation of the textual representation.

*** Edition of a list of strings (listr)

Because strings are immutable, editing a list of strings in place is a pain.
The following takes a list of strings applies a list of replacement (a 3-uple composed of the line number, the row number and the replacement string) to it.

#+name: listr_replace
#+begin_src python :minipage
def listr_replace(listr, replacements):
    for row, col, content in replacements:
        listr[row] = listr[row][:col] + content + listr[row][col+1:]
#+end_src


* References
 - https://en.wikipedia.org/wiki/Find_first_set#CTZ

 - http://old.cescg.org/CESCG97/marak/index.html (erosion, move)

 - https://news.ycombinator.com/item?id=8681899, http://experilous.com/1/blog/post/procedural-planet-generation (planet generation, move)

 - http://jsfiddle.net/rL0qmee9/ (procedural generation bookmarks, move)

 - https://www.w3schools.com/colors/colors_picker.asp (color palettes)
