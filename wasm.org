#+property: header-args:bash :noweb no-export :results output
* Prelude
** About this file

This is an exploration of C++ to WebAssembly compilation aimed at testing whether I could manage to run Yliss in a web browser.

** Tangle block to temporary file

#+name: tangle-to-file
#+begin_src bash
function die() {
    echo "$@"
    exit
}

if [ -z "$block" ]; then
    die "; missing block name to process."
fi

here=$PWD
tmp=/tmp/litlib-tangle
rm $tmp -fr; mkdir -p $tmp; cd $tmp

source="$block.cpp";

function print_block() {
    "$here/litlib/include.pl" "$here/wasm.org" ":exit-with-error :noweb $block"
}

print_block > "$source" || die "; Failed to tangle \`$block\`."
#+end_src

* Compiling C++ the hard way

I followed the post https://surma.dev/things/c-to-webassembly/, but using C++ instead of C, so the content in this section in not really my own, this is just a way to explore the subject a bit by building a few code blocks around C++ to WebAssembly compilation.

The example C pseudo-add function can be reused, but will this time be manipulated as C++ code:
#+name: bad-add-function
#+begin_src cpp
int add(int a, int b) {
    return a * a + b;
}
#+end_src

** C++ to LLVM IR

The =tangle-to-file= operation defined in the prelude is invoked here, and the generated =$source= file is fed to =clang++=, thus producing LLVM-IR (the result is saved to =$block.ll=).
#+name: cc-ll
#+begin_src bash
<<tangle-to-file>>
clang++ --target=wasm32 -emit-llvm -c -S "$source" -x "$language"
#+end_src

For visualisation purposes, this block picks up where =cc-ll= left off and print the generated LLVM IR, wrapped in a nice =llvm= block:
#+name: print-ll
#+begin_src bash :wrap src llvm :var block="" language="c++"
<<cc-ll>>
cat "$block.ll" # The generated file still needs to be printed.
#+end_src

#+Call: print-ll("bad-add-function")

#+RESULTS:
#+begin_src llvm
; ModuleID = 'bad-add-function.cpp'
source_filename = "bad-add-function.cpp"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32"

; Function Attrs: noinline nounwind optnone mustprogress
define hidden i32 @_Z3addii(i32 %0, i32 %1) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  store i32 %0, i32* %3, align 4
  store i32 %1, i32* %4, align 4
  %5 = load i32, i32* %3, align 4
  %6 = load i32, i32* %3, align 4
  %7 = mul nsw i32 %5, %6
  %8 = load i32, i32* %4, align 4
  %9 = add nsw i32 %7, %8
  ret i32 %9
}

attributes #0 = { noinline nounwind optnone mustprogress "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 12.0.1"}
#+end_src

** C++ to WebAssembly object file

This will transform the LLVM IR code produced by =cc-ll= into a WebAssembly object file (the result is saved to =$block.o=):
#+name: cc-wasmo
#+begin_src bash :var block="" language="c++"
<<cc-ll>>
llc -march=wasm32 -filetype=obj "$block.ll"
#+end_src

Information from a WebAssembly object file can be dumped with =wasm-objdump=.
The WebAssembly Binary Toolkit is necessary for this operation (a common package name seems to be =wabt=, otherwise see https://github.com/WebAssembly/wabt).

#+name: dump-wasmo
#+begin_src bash :var block="" language="c++" :wrap src default
<<cc-wasmo>>
wasm-objdump -x "$block.o"
#+end_src

#+Call: dump-wasmo("bad-add-function")

#+RESULTS:
#+begin_src default

bad-add-function.o:	file format wasm 0x1

Section Details:

Type[1]:
 - type[0] (i32, i32) -> i32
Import[2]:
 - memory[0] pages: initial=0 <- env.__linear_memory
 - global[0] i32 mutable=1 <- env.__stack_pointer
Function[1]:
 - func[0] sig=0 <_Z3addii>
Code[1]:
 - func[0] size=44 <_Z3addii>
Custom:
 - name: "linking"
  - symbol table [count=2]
   - 0: F <_Z3addii> func=0 binding=global vis=hidden
   - 1: G <env.__stack_pointer> global=0 undefined binding=global vis=default
Custom:
 - name: "reloc.CODE"
  - relocations for section: 3 (Code) [1]
   - R_WASM_GLOBAL_INDEX_LEB offset=0x000006(file=0x00005e) symbol=1 <env.__stack_pointer>
Custom:
 - name: "producers"
#+end_src
