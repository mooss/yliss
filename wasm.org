#+property: header-args:bash :noweb no-export :results output
#+property: header-args:js :results output

* Prelude

This is an exploration of C++ to WebAssembly compilation aimed at testing whether I could manage to run Yliss in a web browser.

** Literate tools

Here are defined some tools that will be used throughout this document.

*** Code block inclusion

#+name: include
#+begin_src bash :var __blocks_to_include="" __org_sources="litlib/bash.org wasm.org"
./litlib/include.pl "$__org_sources" ":noweb $__blocks_to_include"
#+end_src

*** Code block execution                                           :noexport:

#+name: exec
#+begin_src bash :var noweb=""
noweb=":__blocks_to_exec $noweb"
<<include("assertions", "litlib/bash.org")>>
source <(./litlib/include.pl 'wasm.org' ":noweb $__blocks_to_exec")
#+end_src

*** Tangle block to temporary file

Tangling to a temporary file will involve moving to another directory.
It is mandatory to keep the current directory somewhere in memory to make it possible to call the include script from there.
For the following code block to work, it must be included before any change of directory.
#+name: HERE
#+begin_src bash :eval never
HERE="$PWD"
#+end_src

Printing a block from this file:
#+name: print-local-block
#+begin_src bash :eval never
function print-local-block() {
    "$HERE/litlib/include.pl" "$HERE/wasm.org" ":exit-with-error :noweb $@"
}
#+end_src
#+depends:print-local-block :noweb HERE

Tangle function:
#+name: tangle
#+begin_src bash :eval never
function tangle() {
    if ! print-local-block "$1" > "$2"; then
        error=$(cat "$2")
        stop "#error Failed to tangle \`$1\` ($error)."
    fi
}
#+end_src
#+depends:tangle :noweb print-local-block stop

Moving to dedicated temporary directory:
#+name: tangle-to-.cpp
#+begin_src bash :eval never
assert declared block
tmp=/tmp/litlib-tangle
rm $tmp -fr; mkdir -p $tmp; cd $tmp
tangle "$block" "$block.cpp"
#+end_src
#+depends:tangle-to-.cpp :noweb tangle assertions


* Compiling C++ the hard way

I followed the post https://surma.dev/things/c-to-webassembly/, but using C++ instead of C, so the content in this section in not really my own, this is just a way to explore the subject a bit by building a few code blocks around C++ to WebAssembly compilation.

The example C pseudo-add function can be reused, but will this time be manipulated as C++ code:
#+name: bad-add-function
#+begin_src cpp
WASM_EXPORT int add(int a, int b) {
    return a * a + b;
}
#+end_src
#+depends:bad-add-function :noweb wasm-export

Since add is C++ code, it needs to have C linkage to prevent its name from being mangled.
The =WASM_EXPORT= macro comes from https://medium.com/@dougschaefer/going-straight-to-clang-for-webassembly-928df1484430.

#+name: wasm-export
#+begin_src cpp
#define WASM_EXPORT __attribute__((visibility("default"))) extern "C"
#+end_src

** C++ to LLVM IR

The =tangle-to-.cpp= operation defined in the prelude is invoked here (since it is declared as a dependency), and the generated =$block.cpp= file is fed to =clang++=, thus producing LLVM-IR (the result is saved to =$block.ll=).
#+name: cc-ll
#+begin_src bash :eval never
clang++ --target=wasm32 -emit-llvm -c -S "$block.cpp" -x c++
#+end_src
#+depends:cc-ll :noweb tangle-to-.cpp

For visualisation purposes, this block picks up where =cc-ll= left off and print the generated LLVM IR, wrapped in a nice =llvm= block:
#+name: print-ll
#+begin_src bash :wrap src llvm :var block=""
<<include("cc-ll")>>
cat "$block.ll"
#+end_src

#+Call: print-ll("bad-add-function")

#+RESULTS:
#+begin_src llvm
; ModuleID = 'bad-add-function.cpp'
source_filename = "bad-add-function.cpp"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32"

; Function Attrs: noinline nounwind optnone mustprogress
define i32 @add(i32 %0, i32 %1) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  store i32 %0, i32* %3, align 4
  store i32 %1, i32* %4, align 4
  %5 = load i32, i32* %3, align 4
  %6 = load i32, i32* %3, align 4
  %7 = mul nsw i32 %5, %6
  %8 = load i32, i32* %4, align 4
  %9 = add nsw i32 %7, %8
  ret i32 %9
}

attributes #0 = { noinline nounwind optnone mustprogress "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 12.0.1"}
#+end_src

** C++ to WebAssembly object file

This will transform the LLVM IR code produced by =cc-ll= into a WebAssembly object file (the result is saved to =$block.o=):
#+name: cc-wasm-obj
#+begin_src bash :eval never
llc -march=wasm32 -filetype=obj "$block.ll"
#+end_src
#+depends:cc-wasm-obj :noweb cc-ll

Information from a WebAssembly object file can be dumped with =wasm-objdump=.
The WebAssembly Binary Toolkit is necessary for this operation (a common package name seems to be =wabt=, otherwise see https://github.com/WebAssembly/wabt).

#+name: dump-wasmo
#+begin_src bash :var block="" :wrap src default
<<include("cc-wasm-obj")>>
wasm-objdump -x "$block.o"
#+end_src

#+Call: dump-wasmo("bad-add-function")

#+RESULTS:
#+begin_src default

bad-add-function.o:	file format wasm 0x1

Section Details:

Type[1]:
 - type[0] (i32, i32) -> i32
Import[2]:
 - memory[0] pages: initial=0 <- env.__linear_memory
 - global[0] i32 mutable=1 <- env.__stack_pointer
Function[1]:
 - func[0] sig=0 <add>
Code[1]:
 - func[0] size=44 <add>
Custom:
 - name: "linking"
  - symbol table [count=2]
   - 0: F <add> func=0 binding=global vis=default
   - 1: G <env.__stack_pointer> global=0 undefined binding=global vis=default
Custom:
 - name: "reloc.CODE"
  - relocations for section: 3 (Code) [1]
   - R_WASM_GLOBAL_INDEX_LEB offset=0x000006(file=0x00005e) symbol=1 <env.__stack_pointer>
Custom:
 - name: "producers"
#+end_src

** WebAssembly object file linking

The only missing step to produce a WebAssembly module is to link the object file.
=cc-wasm-LONG= builds upon the previous steps to achieve this.
It, and other derived blocks, are suffixed with =-LONG= because they are using unnecessary steps that are only here to illustrate the compilation process.

#+name: cc-wasm-LONG
#+begin_src bash
wasm-ld --no-entry --export-all -o "$block.wasm" "$block.o"
#+end_src
#+depends:cc-wasm-LONG :noweb cc-wasm-obj

I don't currently have a better visualisation than showing the disk usage (=du=) of the wasm module:
#+name: du-wasm-LONG
#+begin_src bash :var block="" :wrap src text
<<include("cc-wasm-LONG")>>
du -bh "$block.wasm"
#+end_src

#+Call: du-wasm-LONG("bad-add-function")

#+RESULTS:
#+begin_src text
347	bad-add-function.wasm
#+end_src


* Testing WebAssembly

** Direct execution via Node.js

This JavaScript template will be used to load a WebAssembly file and execute additional code after loading.
The =//litlib-insert-*-here= strings will first need to be replaced with the desired value.
#+name: nodejs-template
#+begin_src js
// .wasm loading code from https://thecodebarbarian.com/getting-started-with-webassembly-in-node.js.html.
const fs = require('fs');
const buf = fs.readFileSync('//litlib-insert-wasm-path-here');
// Immediately Invoked Function Expression from https://www.codeproject.com/Articles/5308531/NodeJS-await-is-only-valid-in-async-function.
(async function() {
    const wasm = await WebAssembly.instantiate(new Uint8Array(buf)).
          then(res => res.instance.exports);
    //litlib-insert-js-here
})();
#+end_src

This function can be used to do this replacement:
#+name: instantiate-wasm-template
#+begin_src bash
function instantiate-wasm-template() {
    __template_block="$1"; __wasm_path="$2"; __js_path="$3"; __instantiation_path="$4"
    # Perl template instantiation inspired by https://unix.stackexchange.com/a/49438.
    # Perl's substitution /e modifier means to evaluate the right-hand side as an expression.
    perl -pe "s|//litlib-insert-wasm-path-here|$__wasm_path|; s|//litlib-insert-js-here|\`cat '$__js_path'\`|e"\
         <(print-local-block "$__template_block") > "$__instantiation_path"
}
#+end_src
#+depends:instantiate-wasm-template :noweb print-local-block

This fetches the block described by =$js_block= and uses it to instantiate the Node.js template.
#+name: cc-nodejs-impl
#+begin_src bash
assert declared js_block
js_template="$js_block-template.js"
nodejs_dest="$js_block-instantiated.js"
tangle "$js_block" "$js_template"
instantiate-wasm-template nodejs-template "$block.wasm" "$js_template" "$nodejs_dest"
#+end_src
#+depends:cc-nodejs-impl :noweb assertions tangle instantiate-wasm-template
#+depends:cc-nodejs-LONG :noweb cc-wasm-LONG cc-nodejs-impl

Only the execution remains:
#+name: exec-nodejs-LONG
#+begin_src bash :var block="" js_block="" :wrap src text
set -Ee
<<include("cc-nodejs-LONG")>>
node "$nodejs_dest" 2>&1
#+end_src

#+name: bad-add-function-js
#+begin_src js
console.log(wasm);
console.log("add(4, 1) is: " + wasm.add(4, 1));
#+end_src

#+Call: exec-nodejs-LONG("bad-add-function", "bad-add-function-js")

#+RESULTS:
#+begin_src text
[Object: null prototype] {
  memory: Memory [WebAssembly.Memory] {},
  __wasm_call_ctors: [Function: 0],
  add: [Function: 1],
  __dso_handle: Global [WebAssembly.Global] {},
  __data_end: Global [WebAssembly.Global] {},
  __global_base: Global [WebAssembly.Global] {},
  __heap_base: Global [WebAssembly.Global] {},
  __memory_base: Global [WebAssembly.Global] {},
  __table_base: Global [WebAssembly.Global] {}
}
add(4, 1) is: 17
#+end_src

17 is the expected result since the =add= function squares its first parameter and appends its second to the result.

** Skipping the optional steps (from C++ straight to WebAssembly)

The compilation process can be shortened from /C++ -> LLVM IR -> WebAssembly object file -> WebAssembly module/ to the bare minimum /C++ -> WebAssembly module/.
Note that this time, optimisations (=-O2 -flto -Wl,--lto-O2=) have been enabled.

#+name: cc-wasm
#+begin_src bash
clang++ -x c++ --target=wasm32 -nostdlib -o "$block.wasm"\
        -Wl,--no-entry -Wl,--export-all\
        -O2 -flto -Wl,--lto-O2\
        "$block.cpp"
#+end_src
#+depends:cc-wasm :noweb tangle-to-.cpp

*** Blocks derived from =cc-wasm=

The blocks defined are the equivalent of their =-LONG= form presented previously.

#+depends:cc-nodejs :noweb cc-wasm cc-nodejs-impl

#+name: du-wasm
#+begin_src bash :var block="" :wrap src text
<<include("cc-wasm")>>
du -bh "$block.wasm"
#+end_src

#+name: exec-nodejs
#+begin_src bash :var block="" js_block="" :wrap src text
<<include("cc-nodejs")>>
node "$nodejs_dest" 2>&1
#+end_src

*** Testing derived blocks

#+Call: du-wasm("bad-add-function")

#+RESULTS:
#+begin_src text
253	bad-add-function.wasm
#+end_src

#+Call: exec-nodejs("bad-add-function", "bad-add-function-js")

#+RESULTS:
#+begin_src text
[Object: null prototype] {
  memory: Memory [WebAssembly.Memory] {},
  __wasm_call_ctors: [Function: 0],
  add: [Function: 1],
  __dso_handle: Global [WebAssembly.Global] {},
  __data_end: Global [WebAssembly.Global] {},
  __global_base: Global [WebAssembly.Global] {},
  __heap_base: Global [WebAssembly.Global] {},
  __memory_base: Global [WebAssembly.Global] {},
  __table_base: Global [WebAssembly.Global] {}
}
add(4, 1) is: 17
#+end_src

As expected, the optimised wasm has a smaller footprint and the result is the same.

** HTML generation

HTML can be generated using the same principle as Node.js, i.e. by filling the template below:

#+name: html-template
#+begin_src html
<!DOCTYPE html>
<meta charset="utf-8"/>
<script type="module">
 async function init() {
     const wasm = await WebAssembly.instantiateStreaming(fetch("//litlib-insert-wasm-path-here")).
                                    then(res => res.instance.exports);
     //litlib-insert-js-here
 }
 init();
</script>
#+end_src

Instantiation of the HTML template:
#+name: cc-html
#+begin_src bash
assert declared js_block
js_template="$js_block-template.js"
html_dest="$js_block-instantiated.html"
tangle "$js_block" "$js_template"
instantiate-wasm-template html-template "$block.wasm" "$js_template" "$html_dest"
#+end_src
#+depends:cc-html :noweb cc-wasm assertions tangle instantiate-wasm-template

This can be used to print the result of the instantiation:
#+name: print-html
#+begin_src bash :var block="" js_block="" :wrap src html
<<include("cc-html")>>
cat "$html_dest"
#+end_src

#+Call: print-html("bad-add-function", "bad-add-function-js")

#+RESULTS:
#+begin_src html
<!DOCTYPE html>
<meta charset="utf-8"/>
<script type="module">
 async function init() {
     const wasm = await WebAssembly.instantiateStreaming(fetch("bad-add-function.wasm")).
                                    then(res => res.instance.exports);
     console.log(wasm);
console.log("add(4, 1) is: " + wasm.add(4, 1));

 }
 init();
</script>
#+end_src

** File server

Browsers are reluctant to work with files from local storage so testing the html requires to setup a file server.
The simplest one I found is Python3's file server, to use it just paste the following line in a terminal:
#+begin_src bash :eval never
python -m http.server 16234 --directory /tmp/litlib-tangle
#+end_src

** Open with Firefox

A call to this block will compile everything and open the HTML file in Firefox:
#+name: open-html
#+begin_src bash :var block="" js_block="" :wrap src text
<<include("cc-html")>>
url="http://0.0.0.0:16234/$html_dest"
echo "Will open \`$url\` with Firefox."
firefox --new-window "$url"
#+end_src

#+Call: open-html("bad-add-function", "bad-add-function-js")

#+RESULTS:
#+begin_src text
Will open `http://0.0.0.0:16234/bad-add-function-js-instantiated.html` with Firefox.
#+end_src
