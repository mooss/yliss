#+property: header-args:bash :noweb no-export :results output
#+property: header-args:js :results output

* Prelude

This is an exploration of C++ to WebAssembly compilation aimed at testing whether I could manage to run Yliss in a web browser.

** Literate tools

Here are defined some tools that will be used throughout this document.

*** Code block inclusion

#+name: include
#+begin_src bash :var __blocks_to_include="" __org_sources="litlib/bash.org wasm.org"
./litlib/include.pl "$__org_sources" ":noweb $__blocks_to_include"
#+end_src

*** Code block execution                                           :noexport:

#+name: exec
#+begin_src bash :var noweb=""
noweb=":__blocks_to_exec $noweb"
<<include("assertions", "litlib/bash.org")>>
source <(./litlib/include.pl 'wasm.org' ":noweb $__blocks_to_exec")
#+end_src

*** Tangle block to temporary file

Tangling to a temporary file will involve moving to another directory.
It is mandatory to keep the current directory somewhere in memory to make it possible to call the include script from there.
For the following code block to work, it must be included before any change of directory.
#+name: HERE
#+begin_src bash :eval never
HERE="$PWD"
#+end_src

Printing a block from this file:
#+name: print-local-block
#+begin_src bash :eval never
function print-local-block() {
    "$HERE/litlib/include.pl" "$HERE/wasm.org" ":exit-with-error :noweb $@"
}
#+end_src
#+depends:print-local-block :noweb HERE

Tangle function:
#+name: tangle
#+begin_src bash :eval never
function tangle() {
    if ! print-local-block "$1" > "$2"; then
        error=$(cat "$2")
        stop "#error Failed to tangle \`$1\` ($error)."
    fi
}
#+end_src
#+depends:tangle :noweb print-local-block stop

Moving to dedicated temporary directory:
#+name: tangle-to-.cpp
#+begin_src bash :eval never
assert declared block
tmp=/tmp/litlib-tangle
rm $tmp -fr; mkdir -p $tmp; cd $tmp
tangle "$block" "$block.cpp"
#+end_src
#+depends:tangle-to-.cpp :noweb tangle assertions


* Compiling C++ the hard way

I followed the post https://surma.dev/things/c-to-webassembly/, but using C++ instead of C, so the content in this section in not really my own, this is just a way to explore the subject a bit by building a few code blocks around C++ to WebAssembly compilation.

The example C pseudo-add function can be reused, but will this time be manipulated as C++ code:
#+name: bad-add-function
#+begin_src cpp
int add(int a, int b) {
    return a * a + b;
}
#+end_src

** C++ to LLVM IR

The =tangle-to-.cpp= operation defined in the prelude is invoked here (since it is declared as a dependency), and the generated =$block.cpp= file is fed to =clang++=, thus producing LLVM-IR (the result is saved to =$block.ll=).
#+name: cc-ll
#+begin_src bash :eval never
clang++ --target=wasm32 -emit-llvm -c -S "$block.cpp" -x c++
#+end_src
#+depends:cc-ll :noweb tangle-to-.cpp

For visualisation purposes, this block picks up where =cc-ll= left off and print the generated LLVM IR, wrapped in a nice =llvm= block:
#+name: print-ll
#+begin_src bash :wrap src llvm :var block=""
<<include("cc-ll")>>
cat "$block.ll"
#+end_src

#+Call: print-ll("bad-add-function")

#+RESULTS:
#+begin_src llvm
; ModuleID = 'bad-add-function.cpp'
source_filename = "bad-add-function.cpp"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32"

; Function Attrs: noinline nounwind optnone mustprogress
define hidden i32 @_Z3addii(i32 %0, i32 %1) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  store i32 %0, i32* %3, align 4
  store i32 %1, i32* %4, align 4
  %5 = load i32, i32* %3, align 4
  %6 = load i32, i32* %3, align 4
  %7 = mul nsw i32 %5, %6
  %8 = load i32, i32* %4, align 4
  %9 = add nsw i32 %7, %8
  ret i32 %9
}

attributes #0 = { noinline nounwind optnone mustprogress "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 12.0.1"}
#+end_src

A problem with the LLVM IR produced this way is that the =add= function is compiled as =@_Z3addii=, whereas I would expect it to be simply called =add=.

** C++ to WebAssembly object file

This will transform the LLVM IR code produced by =cc-ll= into a WebAssembly object file (the result is saved to =$block.o=):
#+name: cc-wasm-obj
#+begin_src bash :eval never
llc -march=wasm32 -filetype=obj "$block.ll"
#+end_src
#+depends:cc-wasm-obj :noweb cc-ll

Information from a WebAssembly object file can be dumped with =wasm-objdump=.
The WebAssembly Binary Toolkit is necessary for this operation (a common package name seems to be =wabt=, otherwise see https://github.com/WebAssembly/wabt).

#+name: dump-wasmo
#+begin_src bash :var block="" :wrap src default
<<include("cc-wasm-obj")>>
wasm-objdump -x "$block.o"
#+end_src

#+Call: dump-wasmo("bad-add-function")

#+RESULTS:
#+begin_src default

bad-add-function.o:	file format wasm 0x1

Section Details:

Type[1]:
 - type[0] (i32, i32) -> i32
Import[2]:
 - memory[0] pages: initial=0 <- env.__linear_memory
 - global[0] i32 mutable=1 <- env.__stack_pointer
Function[1]:
 - func[0] sig=0 <_Z3addii>
Code[1]:
 - func[0] size=44 <_Z3addii>
Custom:
 - name: "linking"
  - symbol table [count=2]
   - 0: F <_Z3addii> func=0 binding=global vis=hidden
   - 1: G <env.__stack_pointer> global=0 undefined binding=global vis=default
Custom:
 - name: "reloc.CODE"
  - relocations for section: 3 (Code) [1]
   - R_WASM_GLOBAL_INDEX_LEB offset=0x000006(file=0x00005e) symbol=1 <env.__stack_pointer>
Custom:
 - name: "producers"
#+end_src

** WebAssembly object file linking

The only missing step to produce a WebAssembly module is to link the object file.
=cc-wasm-WIP= builds upon the previous steps to achieve this.

#+name: cc-wasm-WIP
#+begin_src bash
wasm-ld --no-entry --export-all -o "$block.wasm" "$block.o"
#+end_src
#+depends:cc-wasm-WIP :noweb cc-wasm-obj

I don't currently have a better visualisation than showing the disk usage (=du=) of the wasm module:
#+name: du-wasm-WIP
#+begin_src bash :var block=""
<<include("cc-wasm-WIP")>>
du -bh "$block.wasm"
#+end_src

#+Call: du-wasm-WIP("bad-add-function")

#+RESULTS:
:results:
363	bad-add-function.wasm
:end:


* Testing WebAssembly

** Direct execution via Node.js

This JavaScript template will be used to load a WebAssembly file and execute additional code after loading.
The =//litlib-insert-*-here= strings will first need to be replaced with the desired value.
#+name: nodejs-template
#+begin_src js
const fs = require('fs');
const buf = fs.readFileSync('//litlib-insert-wasm-path-here');
// Immediately Invoked Function Expression from https://www.codeproject.com/Articles/5308531/NodeJS-await-is-only-valid-in-async-function.
(async function() {
    const wasm = await WebAssembly.instantiate(new Uint8Array(buf)).
          then(res => res.instance.exports);
    //litlib-insert-js-here
})();
#+end_src

This function can be used to do this replacement:
#+name: instantiate-wasm-template
#+begin_src bash
function instantiate-wasm-template() {
    __wasm_path="$1"; __js_path="$2"; __instantiation_path="$3"
    # Perl template instantiation inspired by https://unix.stackexchange.com/a/49438.
    # Perl's substitution /e modifier means to evaluate the right-hand side as an expression.
    perl -pe "s|//litlib-insert-wasm-path-here|$__wasm_path|; s|//litlib-insert-js-here|\`cat '$__js_path'\`|e"\
         <(print-local-block nodejs-template) > "$__instantiation_path"
}
#+end_src
#+depends:instantiate-wasm-template :noweb print-local-block

This fetches the block described by =$js_block= and uses it to instantiate the Node.js template.
#+name: cc-nodejs-WIP
#+begin_src bash
assert declared js_block
js_template="$js_block-template.js"
nodejs_dest="$js_block-instantiated.js"
tangle "$js_block" "$js_template"
instantiate-wasm-template "$block.wasm" "$js_template" "$nodejs_dest"
#+end_src
#+depends:cc-nodejs-WIP :noweb cc-wasm-WIP instantiate-wasm-template

Only the execution remains:
#+name: exec-nodejs-WIP
#+begin_src bash :var block="" js_block="" :wrap src text
<<include("cc-nodejs-WIP")>>
node "$nodejs_dest" 2>&1
#+end_src

Since the function is exported as =_Z3addii= and not as =add=, this must be reflected by the =$js_block=:
#+name: bad-add-function-js-WIP
#+begin_src js
console.log(wasm);
console.log("add(4, 1) is: " + wasm._Z3addii(4, 1));
#+end_src

#+Call: exec-nodejs-WIP("bad-add-function", "bad-add-function-js-WIP")

#+RESULTS:
#+begin_src text
[Object: null prototype] {
  memory: Memory [WebAssembly.Memory] {},
  __wasm_call_ctors: [Function: 0],
  _Z3addii: [Function: 1],
  __dso_handle: Global [WebAssembly.Global] {},
  __data_end: Global [WebAssembly.Global] {},
  __global_base: Global [WebAssembly.Global] {},
  __heap_base: Global [WebAssembly.Global] {},
  __memory_base: Global [WebAssembly.Global] {},
  __table_base: Global [WebAssembly.Global] {}
}
add(4, 1) is: 17
#+end_src

17 is the expected result since the =add= function squares its first parameter and appends its second to the result.

