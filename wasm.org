#+property: header-args:bash :noweb no-export :results output

* Prelude

This is an exploration of C++ to WebAssembly compilation aimed at testing whether I could manage to run Yliss in a web browser.

** Literate tools

Here are defined some tools that will be used throughout this document.

*** Code block inclusion

#+name: include
#+begin_src bash :var __blocks_to_include="" __org_sources="litlib/bash.org wasm.org"
./litlib/include.pl "$__org_sources" ":noweb $__blocks_to_include"
#+end_src

*** Code block execution                                           :noexport:

#+name: exec
#+begin_src bash :var noweb=""
noweb=":__blocks_to_exec $noweb"
<<include("noweb-suite", "litlib/bash.org")>>
source <(./litlib/include.pl 'wasm.org' ":noweb $__blocks_to_exec")
#+end_src

*** Tangle block to temporary file

Tangling to a temporary file will involve moving to another directory.
It is mandatory to keep the current directory somewhere in memory to make it possible to call the include script from there.
For the following code block to work, it must be included before any change of directory.
#+name: HERE
#+begin_src bash :eval never
HERE="$PWD"
#+end_src

Tangle function:
#+name: tangle
#+begin_src bash :eval never
function print_local_block() {
    "$HERE/litlib/include.pl" "$HERE/wasm.org" ":exit-with-error :noweb $@"
}

function tangle() {
    if ! print_local_block "$1" > "$2"; then
        error=$(cat "$2")
        stop "#error Failed to tangle \`$1\` ($error)."
    fi
}
#+end_src
#+depends:tangle :noweb HERE stop

Moving to dedicated temporary directory:
#+name: tangle-to-.cpp
#+begin_src bash :eval never
assert declared block
tmp=/tmp/litlib-tangle
rm $tmp -fr; mkdir -p $tmp; cd $tmp
tangle "$block" "$block.cpp"
#+end_src
#+depends:tangle-to-.cpp :noweb tangle noweb-suite


* Compiling C++ the hard way

I followed the post https://surma.dev/things/c-to-webassembly/, but using C++ instead of C, so the content in this section in not really my own, this is just a way to explore the subject a bit by building a few code blocks around C++ to WebAssembly compilation.

The example C pseudo-add function can be reused, but will this time be manipulated as C++ code:
#+name: bad-add-function
#+begin_src cpp
int add(int a, int b) {
    return a * a + b;
}
#+end_src

** C++ to LLVM IR

The =tangle-to-.cpp= operation defined in the prelude is invoked here (since it is declared as a dependency), and the generated =$block.cpp= file is fed to =clang++=, thus producing LLVM-IR (the result is saved to =$block.ll=).
#+name: cc-ll
#+begin_src bash :eval never
clang++ --target=wasm32 -emit-llvm -c -S "$block.cpp" -x c++
#+end_src
#+depends:cc-ll :noweb tangle-to-.cpp

For visualisation purposes, this block picks up where =cc-ll= left off and print the generated LLVM IR, wrapped in a nice =llvm= block:
#+name: print-ll
#+begin_src bash :wrap src llvm :var block=""
<<include("cc-ll")>>
cat "$block.ll"
#+end_src

#+Call: print-ll("bad-add-function")

#+RESULTS:
#+begin_src llvm
; ModuleID = 'bad-add-function.cpp'
source_filename = "bad-add-function.cpp"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32"

; Function Attrs: noinline nounwind optnone mustprogress
define hidden i32 @_Z3addii(i32 %0, i32 %1) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  store i32 %0, i32* %3, align 4
  store i32 %1, i32* %4, align 4
  %5 = load i32, i32* %3, align 4
  %6 = load i32, i32* %3, align 4
  %7 = mul nsw i32 %5, %6
  %8 = load i32, i32* %4, align 4
  %9 = add nsw i32 %7, %8
  ret i32 %9
}

attributes #0 = { noinline nounwind optnone mustprogress "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="generic" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 12.0.1"}
#+end_src

A problem with the LLVM IR produced this way is that the =add= function is compiled as =@_Z3addii=, whereas I would expect it to be simply called =add=.

** C++ to WebAssembly object file

This will transform the LLVM IR code produced by =cc-ll= into a WebAssembly object file (the result is saved to =$block.o=):
#+name: cc-wasm-obj
#+begin_src bash :eval never
llc -march=wasm32 -filetype=obj "$block.ll"
#+end_src
#+depends:cc-wasm-obj :noweb cc-ll

Information from a WebAssembly object file can be dumped with =wasm-objdump=.
The WebAssembly Binary Toolkit is necessary for this operation (a common package name seems to be =wabt=, otherwise see https://github.com/WebAssembly/wabt).

#+name: dump-wasmo
#+begin_src bash :var block="" :wrap src default
<<include("cc-wasm-obj")>>
wasm-objdump -x "$block.o"
#+end_src

#+Call: dump-wasmo("bad-add-function")

#+RESULTS:
#+begin_src default

bad-add-function.o:	file format wasm 0x1

Section Details:

Type[1]:
 - type[0] (i32, i32) -> i32
Import[2]:
 - memory[0] pages: initial=0 <- env.__linear_memory
 - global[0] i32 mutable=1 <- env.__stack_pointer
Function[1]:
 - func[0] sig=0 <_Z3addii>
Code[1]:
 - func[0] size=44 <_Z3addii>
Custom:
 - name: "linking"
  - symbol table [count=2]
   - 0: F <_Z3addii> func=0 binding=global vis=hidden
   - 1: G <env.__stack_pointer> global=0 undefined binding=global vis=default
Custom:
 - name: "reloc.CODE"
  - relocations for section: 3 (Code) [1]
   - R_WASM_GLOBAL_INDEX_LEB offset=0x000006(file=0x00005e) symbol=1 <env.__stack_pointer>
Custom:
 - name: "producers"
#+end_src
